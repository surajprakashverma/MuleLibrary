[
  {
    "id": "CH13-0001",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Connector Fundamentals",
    "subtopic": "connector purpose",
    "difficulty": "Easy",
    "question": "What is the primary purpose of a MuleSoft connector?",
    "options": {
      "A": "Transform payloads only",
      "B": "Provide standardized access to external systems",
      "C": "Replace API-led architecture",
      "D": "Handle error logging exclusively"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors abstract complexity and provide standardized access to external systems.",
      "incorrect": {
        "A": "Transformations are handled separately.",
        "C": "Connectors complement API-led architecture.",
        "D": "Error logging is not their sole purpose."
      }
    }
  },
  {
    "id": "CH13-0002",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Connector Fundamentals",
    "subtopic": "built-in vs custom",
    "difficulty": "Medium",
    "question": "When should a custom connector be created instead of using a built-in connector?",
    "options": {
      "A": "When authentication is required",
      "B": "When no existing connector meets protocol or feature needs",
      "C": "When payload size is large",
      "D": "When retries are needed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom connectors are used when built-in connectors cannot satisfy requirements.",
      "incorrect": {
        "A": "Authentication is supported by built-in connectors.",
        "C": "Payload size is unrelated.",
        "D": "Retries are handled at flow level."
      }
    }
  },
  {
    "id": "CH13-0003",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Connector Configuration",
    "subtopic": "connection reuse",
    "difficulty": "Medium",
    "question": "Why should connector configurations be reused across flows?",
    "options": {
      "A": "To increase API limits",
      "B": "To ensure consistency and reduce resource usage",
      "C": "To simplify transformations",
      "D": "To avoid validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusing configurations ensures consistent behavior and efficient resource usage.",
      "incorrect": {
        "A": "API limits are unaffected.",
        "C": "Transformations are separate.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH13-0004",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Connector Configuration",
    "subtopic": "connection pooling",
    "difficulty": "Hard",
    "question": "What is the benefit of connection pooling in connectors?",
    "options": {
      "A": "Eliminates authentication",
      "B": "Improves performance by reusing connections",
      "C": "Reduces payload size",
      "D": "Disables retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connection pooling reduces overhead by reusing established connections.",
      "incorrect": {
        "A": "Authentication is still required.",
        "C": "Payload size is unrelated.",
        "D": "Retries are still applicable."
      }
    }
  },
  {
    "id": "CH13-0005",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "use case selection",
    "difficulty": "Medium",
    "question": "Which Salesforce Connector operation is best suited for synchronizing large datasets?",
    "options": {
      "A": "Create",
      "B": "Update",
      "C": "Upsert",
      "D": "Bulk operation"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Bulk operations are optimized for large data volumes.",
      "incorrect": {
        "A": "Create is record-by-record.",
        "B": "Update is not optimized for bulk.",
        "C": "Upsert alone does not ensure bulk efficiency."
      }
    }
  },
  {
    "id": "CH13-0006",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "upsert behavior",
    "difficulty": "Medium",
    "question": "What is the primary advantage of using upsert with Salesforce Connector?",
    "options": {
      "A": "Bypasses validation rules",
      "B": "Handles create and update in a single operation",
      "C": "Improves query performance",
      "D": "Eliminates external IDs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Upsert simplifies logic by combining create and update behavior.",
      "incorrect": {
        "A": "Validation rules still apply.",
        "C": "Query performance is unrelated.",
        "D": "External IDs are usually required."
      }
    }
  },
  {
    "id": "CH13-0007",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "transaction handling",
    "difficulty": "Hard",
    "question": "Why should database operations be grouped within a transaction scope?",
    "options": {
      "A": "To increase throughput",
      "B": "To ensure atomicity and consistency",
      "C": "To simplify mappings",
      "D": "To avoid connection pooling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactions ensure all operations succeed or fail together.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Mappings are unaffected.",
        "D": "Pooling still applies."
      }
    }
  },
  {
    "id": "CH13-0008",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "prepared statements",
    "difficulty": "Medium",
    "question": "Why are prepared statements recommended in database connectors?",
    "options": {
      "A": "They increase API limits",
      "B": "They prevent SQL injection and improve performance",
      "C": "They eliminate transactions",
      "D": "They simplify error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Prepared statements enhance security and execution efficiency.",
      "incorrect": {
        "A": "API limits are unrelated.",
        "C": "Transactions are still required.",
        "D": "Error handling remains necessary."
      }
    }
  },
  {
    "id": "CH13-0009",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "idempotency",
    "difficulty": "Medium",
    "question": "How can file-based integrations achieve idempotency?",
    "options": {
      "A": "By renaming or archiving processed files",
      "B": "By increasing polling frequency",
      "C": "By disabling retries",
      "D": "By hard-coding file paths"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Archiving or renaming prevents reprocessing the same file.",
      "incorrect": {
        "B": "Polling frequency increases duplication risk.",
        "C": "Retries are still needed.",
        "D": "Hard-coding paths is unsafe."
      }
    }
  },
  {
    "id": "CH13-0010",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "timeout configuration",
    "difficulty": "Medium",
    "question": "Why should timeouts be explicitly configured for HTTP connectors?",
    "options": {
      "A": "To improve payload mapping",
      "B": "To prevent threads from blocking indefinitely",
      "C": "To disable retries",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeouts protect system resources from hanging calls.",
      "incorrect": {
        "A": "Mapping is unrelated.",
        "C": "Retries may still be required.",
        "D": "OAuth is unaffected."
      }
    }
  },

  {
    "id": "CH13-0011",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "connector selection",
    "difficulty": "Easy",
    "question": "What should primarily guide connector selection for a use case?",
    "options": {
      "A": "Popularity of the connector",
      "B": "Target system protocol and capabilities",
      "C": "Payload size only",
      "D": "Ease of testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connector choice depends on the target systemâ€™s interface and features.",
      "incorrect": {
        "A": "Popularity is irrelevant.",
        "C": "Payload size is secondary.",
        "D": "Testing ease is not primary."
      }
    }
  },
  {
    "id": "CH13-0012",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "sync pattern",
    "difficulty": "Easy",
    "question": "Which use case is best suited for synchronous connector usage?",
    "options": {
      "A": "High-volume batch processing",
      "B": "User-facing request-response interactions",
      "C": "Event streaming",
      "D": "Scheduled bulk jobs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "User-facing flows require immediate responses.",
      "incorrect": {
        "A": "Batch processing should be asynchronous.",
        "C": "Streaming is event-driven.",
        "D": "Scheduled jobs are asynchronous."
      }
    }
  },
  {
    "id": "CH13-0013",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "async pattern",
    "difficulty": "Medium",
    "question": "Why are asynchronous connectors preferred for long-running operations?",
    "options": {
      "A": "They remove the need for error handling",
      "B": "They improve scalability and resilience",
      "C": "They simplify authentication",
      "D": "They bypass system limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Async processing avoids blocking and scales better.",
      "incorrect": {
        "A": "Error handling is still required.",
        "C": "Authentication remains the same.",
        "D": "Limits still apply."
      }
    }
  },
  {
    "id": "CH13-0014",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Error Scenarios",
    "subtopic": "connector exceptions",
    "difficulty": "Medium",
    "question": "How should connector-specific exceptions be handled?",
    "options": {
      "A": "Ignored silently",
      "B": "Mapped to meaningful integration errors",
      "C": "Always retried",
      "D": "Converted to payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mapping exceptions improves observability and recovery.",
      "incorrect": {
        "A": "Ignoring hides failures.",
        "C": "Not all errors are retryable.",
        "D": "Errors should not be payloads."
      }
    }
  },
  {
    "id": "CH13-0015",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Performance",
    "subtopic": "connector reuse",
    "difficulty": "Medium",
    "question": "What performance issue arises from creating multiple connector instances unnecessarily?",
    "options": {
      "A": "Reduced payload size",
      "B": "Excessive resource consumption",
      "C": "Improved throughput",
      "D": "Simpler configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unnecessary instances waste connections and memory.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Throughput may degrade.",
        "D": "Configuration becomes complex."
      }
    }
  },
  {
    "id": "CH13-0016",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "credential storage",
    "difficulty": "Easy",
    "question": "Where should connector credentials be stored?",
    "options": {
      "A": "Hard-coded in flows",
      "B": "Secure properties or secret managers",
      "C": "Logged for debugging",
      "D": "Shared across environments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure storage prevents credential exposure.",
      "incorrect": {
        "A": "Hard-coding is insecure.",
        "C": "Logging secrets is dangerous.",
        "D": "Secrets must be environment-specific."
      }
    }
  },
  {
    "id": "CH13-0017",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "least privilege",
    "difficulty": "Medium",
    "question": "Why should connector users follow least privilege?",
    "options": {
      "A": "To increase API limits",
      "B": "To minimize security exposure",
      "C": "To simplify testing",
      "D": "To disable validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege limits impact of compromised access.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Testing is unaffected.",
        "D": "Validation remains active."
      }
    }
  },
  {
    "id": "CH13-0018",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "connector metrics",
    "difficulty": "Easy",
    "question": "Which metric is most useful for monitoring connector health?",
    "options": {
      "A": "Payload size",
      "B": "Error rate and latency",
      "C": "Number of flows",
      "D": "Connector name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error rates and latency reveal runtime issues.",
      "incorrect": {
        "A": "Payload size alone is insufficient.",
        "C": "Flow count is unrelated.",
        "D": "Names provide no insight."
      }
    }
  },
  {
    "id": "CH13-0019",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Patterns",
    "subtopic": "fan-out",
    "difficulty": "Medium",
    "question": "Which connector use case matches a fan-out pattern?",
    "options": {
      "A": "Single system sync",
      "B": "Publishing data to multiple downstream systems",
      "C": "Database lookup",
      "D": "Authentication flow"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fan-out distributes data to multiple targets.",
      "incorrect": {
        "A": "Single sync is not fan-out.",
        "C": "Lookups are point operations.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH13-0020",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Patterns",
    "subtopic": "fan-in",
    "difficulty": "Medium",
    "question": "When is a fan-in connector pattern appropriate?",
    "options": {
      "A": "Sending data to many systems",
      "B": "Aggregating data from multiple sources",
      "C": "Replacing APIs",
      "D": "Handling UI requests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fan-in consolidates data from multiple systems.",
      "incorrect": {
        "A": "That describes fan-out.",
        "C": "APIs are not replaced.",
        "D": "UI requests are separate."
      }
    }
  },

  {
    "id": "CH13-0021",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "connector abstraction",
    "difficulty": "Medium",
    "question": "Why should connectors be wrapped by System APIs?",
    "options": {
      "A": "To increase API limits",
      "B": "To isolate consumers from backend changes",
      "C": "To simplify payload mapping",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs abstract connector and backend complexity.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Mapping is separate.",
        "D": "Retries are still required."
      }
    }
  },
  {
    "id": "CH13-0022",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "configuration externalization",
    "difficulty": "Easy",
    "question": "Why should connector endpoints be externalized?",
    "options": {
      "A": "To hard-code values",
      "B": "To support environment-specific configuration",
      "C": "To reduce logging",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Externalization allows safe promotion across environments.",
      "incorrect": {
        "A": "Hard-coding is risky.",
        "C": "Logging remains important.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH13-0023",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "retry strategy",
    "difficulty": "Medium",
    "question": "What should determine retry strategy for connector calls?",
    "options": {
      "A": "Connector popularity",
      "B": "Nature of error and idempotency",
      "C": "Payload size",
      "D": "Flow name"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries must consider error type and side effects.",
      "incorrect": {
        "A": "Popularity is irrelevant.",
        "C": "Payload size is secondary.",
        "D": "Flow name is irrelevant."
      }
    }
  },
  {
    "id": "CH13-0024",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Anti-Patterns",
    "subtopic": "point-to-point",
    "difficulty": "Medium",
    "question": "Why is heavy point-to-point connector usage discouraged?",
    "options": {
      "A": "It increases flexibility",
      "B": "It creates tight coupling and maintenance issues",
      "C": "It improves performance",
      "D": "It reduces governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Point-to-point integrations scale poorly and increase coupling.",
      "incorrect": {
        "A": "Flexibility is reduced.",
        "C": "Performance often degrades.",
        "D": "Governance becomes harder."
      }
    }
  },
  {
    "id": "CH13-0025",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Anti-Patterns",
    "subtopic": "hard-coded logic",
    "difficulty": "Easy",
    "question": "Why is hard-coding connector behavior considered risky?",
    "options": {
      "A": "It improves speed",
      "B": "It reduces adaptability and increases technical debt",
      "C": "It simplifies testing",
      "D": "It improves observability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hard-coding makes change difficult and error-prone.",
      "incorrect": {
        "A": "Speed gains are minimal.",
        "C": "Testing becomes harder.",
        "D": "Observability is unaffected."
      }
    }
  },
  {
    "id": "CH13-0026",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Use Cases",
    "subtopic": "bulk loads",
    "difficulty": "Medium",
    "question": "Which connector characteristic is critical for bulk load use cases?",
    "options": {
      "A": "Low latency",
      "B": "High throughput and batch support",
      "C": "Synchronous execution",
      "D": "UI responsiveness"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk loads prioritize throughput over immediate response.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "Bulk loads are asynchronous.",
        "D": "UI is irrelevant."
      }
    }
  },
  {
    "id": "CH13-0027",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Use Cases",
    "subtopic": "real-time sync",
    "difficulty": "Medium",
    "question": "What is a key requirement for real-time synchronization use cases?",
    "options": {
      "A": "Eventual consistency only",
      "B": "Low latency and immediate feedback",
      "C": "Large batch size",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Real-time sync requires fast responses.",
      "incorrect": {
        "A": "Eventual consistency may not be acceptable.",
        "C": "Batching increases delay.",
        "D": "Retries should be automated."
      }
    }
  },
  {
    "id": "CH13-0028",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Observability",
    "subtopic": "correlation ids",
    "difficulty": "Easy",
    "question": "Why should connector calls include correlation IDs?",
    "options": {
      "A": "To increase API limits",
      "B": "To enable end-to-end traceability",
      "C": "To simplify authentication",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs link requests across systems.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication is unaffected.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH13-0029",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Governance",
    "subtopic": "connector standards",
    "difficulty": "Medium",
    "question": "Why should enterprises define connector usage standards?",
    "options": {
      "A": "To slow down development",
      "B": "To ensure consistency, security, and maintainability",
      "C": "To eliminate flexibility",
      "D": "To reduce testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards prevent fragmentation and security issues.",
      "incorrect": {
        "A": "Standards enable safe speed.",
        "C": "Flexibility is guided, not removed.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH13-0030",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Governance",
    "subtopic": "connector lifecycle",
    "difficulty": "Easy",
    "question": "What should be considered part of connector lifecycle management?",
    "options": {
      "A": "Initial development only",
      "B": "Versioning, monitoring, and retirement",
      "C": "Payload mapping only",
      "D": "Authentication only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors must be managed throughout their lifecycle.",
      "incorrect": {
        "A": "Lifecycle extends beyond development.",
        "C": "Mapping is only one aspect.",
        "D": "Authentication is only one concern."
      }
    }
  },
  {
    "id": "CH13-0031",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design principle",
    "difficulty": "Easy",
    "question": "Which principle best guides connector-based integration design?",
    "options": {
      "A": "Tight coupling",
      "B": "Loose coupling and abstraction",
      "C": "Hard-coded behavior",
      "D": "Minimal monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and reuse.",
      "incorrect": {
        "A": "Tight coupling increases risk.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0032",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam focus",
    "difficulty": "Easy",
    "question": "What do connector-related exam questions primarily test?",
    "options": {
      "A": "Connector syntax",
      "B": "Appropriate selection and use case reasoning",
      "C": "UI configuration steps",
      "D": "File system paths"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize choosing the right connector for the scenario.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "UI steps are secondary.",
        "D": "Paths are not tested."
      }
    }
  },
  {
    "id": "CH13-0033",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term connector success?",
    "options": {
      "A": "Quick implementation",
      "B": "Product-oriented lifecycle ownership",
      "C": "Minimal governance",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors require ongoing monitoring and improvement.",
      "incorrect": {
        "A": "Quick fixes increase risk.",
        "C": "Governance is necessary.",
        "D": "Ad-hoc fixes cause instability."
      }
    }
  },
  {
    "id": "CH13-0034",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "key takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for connectors in enterprise integrations?",
    "options": {
      "A": "Use as many connectors as possible",
      "B": "Use connectors thoughtfully within an API-led architecture",
      "C": "Avoid abstraction",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors are tools that must fit within a broader architecture.",
      "incorrect": {
        "A": "Overuse increases complexity.",
        "C": "Abstraction is critical.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0035",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise success",
    "difficulty": "Easy",
    "question": "Which approach best ensures connector success at scale?",
    "options": {
      "A": "Ad-hoc development",
      "B": "Standardization, governance, and monitoring",
      "C": "Minimal testing",
      "D": "Hard-coded credentials"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scale requires discipline and visibility.",
      "incorrect": {
        "A": "Ad-hoc approaches do not scale.",
        "C": "Testing is essential.",
        "D": "Hard-coding is insecure."
      }
    }
  },
  {
    "id": "CH13-0036",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "integration maturity",
    "difficulty": "Easy",
    "question": "What indicates mature connector usage?",
    "options": {
      "A": "Direct point-to-point calls",
      "B": "Abstracted connectors with monitoring and governance",
      "C": "Minimal documentation",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is shown through abstraction and operational discipline.",
      "incorrect": {
        "A": "Point-to-point increases risk.",
        "C": "Documentation is required.",
        "D": "Retries should be automated."
      }
    }
  },
  {
    "id": "CH13-0037",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability lesson",
    "difficulty": "Easy",
    "question": "What connector practice best supports scalability?",
    "options": {
      "A": "Stateful flows",
      "B": "Stateless, reusable connector usage",
      "C": "Hard-coded endpoints",
      "D": "Manual configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless reuse allows horizontal scaling.",
      "incorrect": {
        "A": "State limits scalability.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual config is error-prone."
      }
    }
  },
  {
    "id": "CH13-0038",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security reminder",
    "difficulty": "Easy",
    "question": "What security practice is most critical when using connectors?",
    "options": {
      "A": "Broad permissions",
      "B": "Least privilege and secure credential storage",
      "C": "Hard-coded secrets",
      "D": "Disabled auditing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security failures often originate from poor credential handling.",
      "incorrect": {
        "A": "Broad permissions increase risk.",
        "C": "Hard-coding is unsafe.",
        "D": "Auditing is necessary."
      }
    }
  },
  {
    "id": "CH13-0039",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design takeaway",
    "difficulty": "Easy",
    "question": "Which design choice best future-proofs connector-based integrations?",
    "options": {
      "A": "Direct system coupling",
      "B": "Abstraction and loose coupling",
      "C": "Minimal testing",
      "D": "Ad-hoc error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling allows systems to evolve independently.",
      "incorrect": {
        "A": "Direct coupling increases fragility.",
        "C": "Testing is mandatory.",
        "D": "Error handling must be structured."
      }
    }
  },
  {
    "id": "CH13-0040",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "What best summarizes effective use of connectors in MuleSoft?",
    "options": {
      "A": "Use connectors directly everywhere",
      "B": "Use connectors within governed, API-led designs",
      "C": "Avoid abstraction layers",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors are most effective when used within API-led architecture.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0041",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "query optimization",
    "difficulty": "Medium",
    "question": "Why should SOQL queries be optimized when used through the Salesforce Connector?",
    "options": {
      "A": "To simplify DataWeave transformations",
      "B": "To reduce API consumption and improve performance",
      "C": "To bypass authentication",
      "D": "To avoid using external IDs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Efficient queries reduce API calls and response time.",
      "incorrect": {
        "A": "Transformations are independent of queries.",
        "C": "Authentication is always required.",
        "D": "External IDs are unrelated to queries."
      }
    }
  },
  {
    "id": "CH13-0042",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "streaming api",
    "difficulty": "Medium",
    "question": "When is the Salesforce Streaming API most appropriate?",
    "options": {
      "A": "Bulk historical data loads",
      "B": "Real-time event-driven updates",
      "C": "Scheduled nightly jobs",
      "D": "Metadata deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming API supports near real-time event notifications.",
      "incorrect": {
        "A": "Bulk API suits historical loads.",
        "C": "Scheduled jobs are batch-oriented.",
        "D": "Metadata API handles deployments."
      }
    }
  },
  {
    "id": "CH13-0043",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "idempotent methods",
    "difficulty": "Medium",
    "question": "Which HTTP method is inherently idempotent when used via the HTTP Connector?",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "PATCH",
      "D": "CONNECT"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PUT produces the same result when repeated with the same payload.",
      "incorrect": {
        "A": "POST is not idempotent.",
        "C": "PATCH may not be idempotent.",
        "D": "CONNECT is not used for resource updates."
      }
    }
  },
  {
    "id": "CH13-0044",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "retry handling",
    "difficulty": "Hard",
    "question": "Which scenario should NOT be retried automatically for HTTP connector calls?",
    "options": {
      "A": "Temporary network timeout",
      "B": "HTTP 500 server error",
      "C": "HTTP 400 validation error",
      "D": "Transient DNS resolution failure"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "400-level errors indicate client-side issues that retries will not fix.",
      "incorrect": {
        "A": "Network timeouts are retryable.",
        "B": "Server errors may be transient.",
        "D": "DNS failures can be temporary."
      }
    }
  },
  {
    "id": "CH13-0045",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "fetch size",
    "difficulty": "Medium",
    "question": "Why is fetch size important when reading large datasets using the Database Connector?",
    "options": {
      "A": "It controls authentication scope",
      "B": "It balances memory usage and performance",
      "C": "It avoids SQL joins",
      "D": "It disables transactions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proper fetch size prevents memory exhaustion while maintaining throughput.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Joins are query-level concerns.",
        "D": "Transactions are independent."
      }
    }
  },
  {
    "id": "CH13-0046",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "result streaming",
    "difficulty": "Hard",
    "question": "What is the benefit of streaming database results instead of loading all rows at once?",
    "options": {
      "A": "Improved security",
      "B": "Reduced memory footprint",
      "C": "Faster authentication",
      "D": "Simpler SQL syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming processes records incrementally, reducing memory usage.",
      "incorrect": {
        "A": "Security is unaffected.",
        "C": "Authentication speed is unchanged.",
        "D": "SQL syntax is unrelated."
      }
    }
  },
  {
    "id": "CH13-0047",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "polling strategy",
    "difficulty": "Medium",
    "question": "What is a key drawback of aggressive file polling?",
    "options": {
      "A": "Improved latency",
      "B": "Higher resource consumption",
      "C": "Reduced reliability",
      "D": "Simpler error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Frequent polling increases CPU and I/O usage.",
      "incorrect": {
        "A": "Latency may improve but at a cost.",
        "C": "Reliability is not inherently reduced.",
        "D": "Error handling is unaffected."
      }
    }
  },
  {
    "id": "CH13-0048",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "file locking",
    "difficulty": "Hard",
    "question": "Why is file locking important in file-based integrations?",
    "options": {
      "A": "To speed up file transfers",
      "B": "To prevent multiple consumers from processing the same file",
      "C": "To compress files automatically",
      "D": "To simplify naming conventions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Locking ensures only one process handles a file at a time.",
      "incorrect": {
        "A": "Speed is not the primary goal.",
        "C": "Compression is unrelated.",
        "D": "Naming does not prevent concurrency issues."
      }
    }
  },
  {
    "id": "CH13-0049",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "acknowledgement",
    "difficulty": "Medium",
    "question": "What is the purpose of message acknowledgement in MQ connectors?",
    "options": {
      "A": "Increase message size",
      "B": "Confirm successful processing before removal",
      "C": "Disable retries",
      "D": "Improve payload mapping"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Acknowledgement ensures messages are not lost before processing completes.",
      "incorrect": {
        "A": "Message size is unchanged.",
        "C": "Retries may still apply.",
        "D": "Mapping is unrelated."
      }
    }
  },
  {
    "id": "CH13-0050",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "at least once delivery",
    "difficulty": "Medium",
    "question": "What does at-least-once delivery guarantee in messaging use cases?",
    "options": {
      "A": "Messages are delivered only once",
      "B": "Messages may be delivered more than once but not lost",
      "C": "Messages are delivered in order",
      "D": "Messages bypass retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "At-least-once ensures delivery but may cause duplicates.",
      "incorrect": {
        "A": "Exactly-once is different.",
        "C": "Ordering is not guaranteed.",
        "D": "Retries are part of delivery guarantees."
      }
    }
  },

  {
    "id": "CH13-0051",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "idempotent consumers",
    "difficulty": "Hard",
    "question": "Why must consumers be idempotent in at-least-once messaging patterns?",
    "options": {
      "A": "To reduce latency",
      "B": "To safely handle duplicate message deliveries",
      "C": "To improve authentication",
      "D": "To increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent consumers prevent duplicate side effects.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "Authentication is unrelated.",
        "D": "Throughput may be affected but is not the reason."
      }
    }
  },
  {
    "id": "CH13-0052",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "security",
    "difficulty": "Easy",
    "question": "Why is SFTP preferred over FTP in enterprise integrations?",
    "options": {
      "A": "Higher speed",
      "B": "Encrypted data transfer",
      "C": "Simpler configuration",
      "D": "No authentication required"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SFTP encrypts data in transit, improving security.",
      "incorrect": {
        "A": "Speed is not guaranteed.",
        "C": "Configuration may be more complex.",
        "D": "Authentication is mandatory."
      }
    }
  },
  {
    "id": "CH13-0053",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "key-based auth",
    "difficulty": "Medium",
    "question": "What is the advantage of key-based authentication for SFTP connectors?",
    "options": {
      "A": "Simpler password rotation",
      "B": "Stronger security than passwords",
      "C": "Eliminates encryption",
      "D": "Improves throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Key-based auth reduces risk of credential compromise.",
      "incorrect": {
        "A": "Rotation is different from security.",
        "C": "Encryption remains essential.",
        "D": "Throughput is unaffected."
      }
    }
  },
  {
    "id": "CH13-0054",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Patterns",
    "subtopic": "request-reply",
    "difficulty": "Easy",
    "question": "Which connector use case aligns with the request-reply pattern?",
    "options": {
      "A": "Event broadcasting",
      "B": "Synchronous API invocation",
      "C": "Batch file processing",
      "D": "Message queuing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Request-reply requires immediate response.",
      "incorrect": {
        "A": "Broadcasting is asynchronous.",
        "C": "Batch is not request-reply.",
        "D": "Queues decouple senders and receivers."
      }
    }
  },
  {
    "id": "CH13-0055",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Patterns",
    "subtopic": "event-driven",
    "difficulty": "Medium",
    "question": "Why are event-driven connector use cases more scalable?",
    "options": {
      "A": "They rely on polling",
      "B": "They decouple producers and consumers",
      "C": "They eliminate retries",
      "D": "They require synchronous processing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Decoupling allows independent scaling of components.",
      "incorrect": {
        "A": "Polling increases load.",
        "C": "Retries are still required.",
        "D": "Event-driven is asynchronous."
      }
    }
  },
  {
    "id": "CH13-0056",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Error Handling",
    "subtopic": "poison messages",
    "difficulty": "Hard",
    "question": "What is a poison message in connector-based messaging systems?",
    "options": {
      "A": "A message with large payload",
      "B": "A message that repeatedly fails processing",
      "C": "An encrypted message",
      "D": "A delayed message"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Poison messages cause repeated failures and must be isolated.",
      "incorrect": {
        "A": "Payload size alone is not poison.",
        "C": "Encryption is unrelated.",
        "D": "Delay does not imply poison."
      }
    }
  },
  {
    "id": "CH13-0057",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Error Handling",
    "subtopic": "dead letter queue",
    "difficulty": "Medium",
    "question": "Why should failed messages be routed to a Dead Letter Queue?",
    "options": {
      "A": "To increase throughput",
      "B": "To prevent repeated failures from blocking processing",
      "C": "To disable retries",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DLQs isolate failures and protect system stability.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Retries may still occur before DLQ.",
        "D": "Transformations are unrelated."
      }
    }
  },
  {
    "id": "CH13-0058",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Performance",
    "subtopic": "parallel processing",
    "difficulty": "Medium",
    "question": "When is parallel connector processing most beneficial?",
    "options": {
      "A": "For sequential dependencies",
      "B": "For independent, time-consuming operations",
      "C": "For small payloads only",
      "D": "For authentication flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Independent operations can execute concurrently to reduce total time.",
      "incorrect": {
        "A": "Dependencies require sequencing.",
        "C": "Payload size alone is not the factor.",
        "D": "Authentication should remain controlled."
      }
    }
  },
  {
    "id": "CH13-0059",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "timeouts",
    "difficulty": "Easy",
    "question": "Why should connector timeouts be aligned with business SLAs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure predictable user experience",
      "C": "To disable retries",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeouts aligned with SLAs ensure consistent expectations.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Retries may still be required.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH13-0060",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "connector abstraction",
    "difficulty": "Easy",
    "question": "Why should application logic not be embedded directly inside connector calls?",
    "options": {
      "A": "It improves speed",
      "B": "It reduces reusability and maintainability",
      "C": "It simplifies governance",
      "D": "It improves security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Embedding logic tightly couples connectors to specific use cases.",
      "incorrect": {
        "A": "Speed gains are minimal.",
        "C": "Governance becomes harder.",
        "D": "Security is not guaranteed."
      }
    }
  },

  {
    "id": "CH13-0061",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability insight",
    "difficulty": "Easy",
    "question": "What connector characteristic most supports scalability?",
    "options": {
      "A": "Stateful execution",
      "B": "Stateless and reusable design",
      "C": "Hard-coded credentials",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless reuse allows horizontal scaling.",
      "incorrect": {
        "A": "State limits scaling.",
        "C": "Hard-coding is insecure.",
        "D": "Manual retries do not scale."
      }
    }
  },
  {
    "id": "CH13-0062",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "reliability",
    "difficulty": "Easy",
    "question": "What most improves reliability in connector-based integrations?",
    "options": {
      "A": "Ignoring transient errors",
      "B": "Retries, idempotency, and monitoring",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability depends on structured resilience mechanisms.",
      "incorrect": {
        "A": "Ignoring errors increases risk.",
        "C": "Hard-coding increases fragility.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH13-0063",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security reminder",
    "difficulty": "Easy",
    "question": "Which practice is essential for secure connector usage?",
    "options": {
      "A": "Broad system access",
      "B": "Least privilege and secure credential storage",
      "C": "Hard-coded secrets",
      "D": "Disabled auditing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security failures often originate from poor access control.",
      "incorrect": {
        "A": "Broad access increases risk.",
        "C": "Hard-coding is unsafe.",
        "D": "Auditing is necessary."
      }
    }
  },
  {
    "id": "CH13-0064",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term connector success?",
    "options": {
      "A": "Quick delivery only",
      "B": "Product and lifecycle ownership",
      "C": "Minimal testing",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors must be treated as long-lived assets.",
      "incorrect": {
        "A": "Speed alone is risky.",
        "C": "Testing is essential.",
        "D": "Ad-hoc fixes increase instability."
      }
    }
  },
  {
    "id": "CH13-0065",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture takeaway",
    "difficulty": "Easy",
    "question": "Which architectural approach best complements connector usage?",
    "options": {
      "A": "Point-to-point integration",
      "B": "API-led architecture",
      "C": "Hard-coded workflows",
      "D": "Minimal abstraction"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led architecture maximizes reuse and flexibility.",
      "incorrect": {
        "A": "Point-to-point increases coupling.",
        "C": "Hard-coding reduces adaptability.",
        "D": "Abstraction improves design."
      }
    }
  },
  {
    "id": "CH13-0066",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam insight",
    "difficulty": "Easy",
    "question": "What do exam questions about connectors usually emphasize?",
    "options": {
      "A": "Connector UI navigation",
      "B": "Choosing the right connector for the scenario",
      "C": "File system paths",
      "D": "Exact XML syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams focus on decision-making rather than memorization.",
      "incorrect": {
        "A": "UI steps are secondary.",
        "C": "Paths are not tested.",
        "D": "Syntax is not the main focus."
      }
    }
  },
  {
    "id": "CH13-0067",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational excellence",
    "difficulty": "Easy",
    "question": "What best defines operational excellence for connectors?",
    "options": {
      "A": "Manual monitoring",
      "B": "Automated monitoring, alerts, and runbooks",
      "C": "Minimal logging",
      "D": "Ad-hoc incident handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistent and fast recovery.",
      "incorrect": {
        "A": "Manual processes do not scale.",
        "C": "Logging is essential.",
        "D": "Ad-hoc handling increases downtime."
      }
    }
  },
  {
    "id": "CH13-0068",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "resilience principle",
    "difficulty": "Easy",
    "question": "Which principle most improves connector resilience?",
    "options": {
      "A": "Tight coupling",
      "B": "Timeouts, retries, and circuit breakers",
      "C": "Hard-coded behavior",
      "D": "Ignoring transient failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience patterns protect against instability.",
      "incorrect": {
        "A": "Tight coupling increases risk.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Failures must be handled."
      }
    }
  },
  {
    "id": "CH13-0069",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise lesson",
    "difficulty": "Easy",
    "question": "What is the key enterprise lesson for connector usage?",
    "options": {
      "A": "Use connectors directly everywhere",
      "B": "Balance flexibility, security, and governance",
      "C": "Avoid abstraction",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise success requires balanced design choices.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0070",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "closing takeaway",
    "difficulty": "Easy",
    "question": "Which statement best summarizes effective connector use?",
    "options": {
      "A": "Connectors replace APIs",
      "B": "Connectors enable integration when used within good architecture",
      "C": "Connectors eliminate complexity",
      "D": "Connectors remove the need for testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors are powerful tools but must be used correctly.",
      "incorrect": {
        "A": "APIs are still essential.",
        "C": "Complexity still exists.",
        "D": "Testing remains mandatory."
      }
    }
  },
  {
    "id": "CH13-0071",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling connectors",
    "difficulty": "Easy",
    "question": "What practice best supports scaling connector-based solutions?",
    "options": {
      "A": "Stateful logic",
      "B": "Stateless processing and reuse",
      "C": "Hard-coded endpoints",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless reuse enables horizontal scalability.",
      "incorrect": {
        "A": "State limits scaling.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual retries do not scale."
      }
    }
  },
  {
    "id": "CH13-0072",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "connector maturity",
    "difficulty": "Easy",
    "question": "Which sign indicates mature connector usage?",
    "options": {
      "A": "Point-to-point integrations",
      "B": "Standardized, monitored, and governed connectors",
      "C": "Minimal documentation",
      "D": "Ad-hoc configurations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is shown by standardization and governance.",
      "incorrect": {
        "A": "Point-to-point is fragile.",
        "C": "Documentation is necessary.",
        "D": "Ad-hoc approaches increase risk."
      }
    }
  },
  {
    "id": "CH13-0073",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security insight",
    "difficulty": "Easy",
    "question": "What is the biggest security risk with connectors?",
    "options": {
      "A": "Large payloads",
      "B": "Improper credential handling",
      "C": "Slow responses",
      "D": "Complex mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Most breaches originate from credential mismanagement.",
      "incorrect": {
        "A": "Payload size is not a security issue.",
        "C": "Latency is operational.",
        "D": "Mappings affect maintainability."
      }
    }
  },
  {
    "id": "CH13-0074",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design principle",
    "difficulty": "Easy",
    "question": "Which design principle should always guide connector use?",
    "options": {
      "A": "Direct system access",
      "B": "Loose coupling and abstraction",
      "C": "Minimal testing",
      "D": "Ignoring failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and change tolerance.",
      "incorrect": {
        "A": "Direct access increases risk.",
        "C": "Testing is mandatory.",
        "D": "Failures must be handled."
      }
    }
  },
  {
    "id": "CH13-0075",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture insight",
    "difficulty": "Easy",
    "question": "Which architecture best complements heavy connector usage?",
    "options": {
      "A": "Monolithic design",
      "B": "API-led layered architecture",
      "C": "Hard-coded workflows",
      "D": "Single integration layer"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered APIs isolate connectors and improve reuse.",
      "incorrect": {
        "A": "Monoliths reduce flexibility.",
        "C": "Hard-coding reduces maintainability.",
        "D": "Single layers become bottlenecks."
      }
    }
  },
  {
    "id": "CH13-0076",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operations lesson",
    "difficulty": "Easy",
    "question": "What operational practice is essential for connector-heavy systems?",
    "options": {
      "A": "Manual deployments",
      "B": "Monitoring, alerting, and runbooks",
      "C": "Minimal logging",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operational discipline ensures stability at scale.",
      "incorrect": {
        "A": "Manual steps are risky.",
        "C": "Logging is essential.",
        "D": "Ad-hoc fixes increase downtime."
      }
    }
  },
  {
    "id": "CH13-0077",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam tip",
    "difficulty": "Easy",
    "question": "What is the best strategy for answering connector-based exam questions?",
    "options": {
      "A": "Memorize connector properties",
      "B": "Analyze the use case and constraints carefully",
      "C": "Focus on UI steps",
      "D": "Ignore non-functional requirements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario analysis and trade-offs.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "UI details are secondary.",
        "D": "Non-functional requirements are critical."
      }
    }
  },
  {
    "id": "CH13-0078",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "failure handling",
    "difficulty": "Easy",
    "question": "Which approach best handles connector failures?",
    "options": {
      "A": "Ignore failures",
      "B": "Retries, DLQs, and alerts",
      "C": "Hard-coded logic",
      "D": "Manual restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structured failure handling prevents cascading issues.",
      "incorrect": {
        "A": "Ignoring failures increases risk.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual restarts do not scale."
      }
    }
  },
  {
    "id": "CH13-0079",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "long-term view",
    "difficulty": "Easy",
    "question": "Why should connectors be treated as long-term assets?",
    "options": {
      "A": "They never change",
      "B": "They require ongoing maintenance and evolution",
      "C": "They eliminate APIs",
      "D": "They reduce governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors evolve with systems and business needs.",
      "incorrect": {
        "A": "Change is inevitable.",
        "C": "APIs remain necessary.",
        "D": "Governance is essential."
      }
    }
  },
  {
    "id": "CH13-0080",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "ultimate takeaway",
    "difficulty": "Easy",
    "question": "What is the ultimate takeaway for using connectors effectively?",
    "options": {
      "A": "Use connectors everywhere directly",
      "B": "Use connectors thoughtfully within governed architectures",
      "C": "Avoid abstraction layers",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Thoughtful, governed use maximizes connector value.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves design.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0081",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "external id usage",
    "difficulty": "Medium",
    "question": "Why are external IDs critical when using Salesforce Connector for data synchronization?",
    "options": {
      "A": "They increase API limits",
      "B": "They allow reliable upsert operations",
      "C": "They disable validation rules",
      "D": "They improve query latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External IDs enable deterministic matching for create or update operations.",
      "incorrect": {
        "A": "API limits are unchanged.",
        "C": "Validation rules still apply.",
        "D": "Latency is not directly affected."
      }
    }
  },
  {
    "id": "CH13-0082",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "bulk vs standard api",
    "difficulty": "Medium",
    "question": "When should the Salesforce Bulk API be preferred over standard REST operations?",
    "options": {
      "A": "For real-time UI interactions",
      "B": "For large-volume asynchronous data processing",
      "C": "For authentication flows",
      "D": "For metadata updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk API is optimized for high-volume, non-real-time data loads.",
      "incorrect": {
        "A": "UI interactions require low latency.",
        "C": "Authentication is unrelated.",
        "D": "Metadata updates use different APIs."
      }
    }
  },
  {
    "id": "CH13-0083",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "response validation",
    "difficulty": "Medium",
    "question": "Why should HTTP responses be explicitly validated in connector flows?",
    "options": {
      "A": "To simplify DataWeave scripts",
      "B": "To detect unexpected downstream behavior early",
      "C": "To bypass retries",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation ensures integration reacts correctly to unexpected responses.",
      "incorrect": {
        "A": "Scripts are independent of validation.",
        "C": "Retries may still be required.",
        "D": "Payload size is unaffected."
      }
    }
  },
  {
    "id": "CH13-0084",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "circuit breaker",
    "difficulty": "Hard",
    "question": "What problem does a circuit breaker pattern solve for HTTP connector calls?",
    "options": {
      "A": "Authentication token expiry",
      "B": "Repeated calls to an unresponsive service",
      "C": "Payload transformation errors",
      "D": "Schema validation failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers prevent cascading failures caused by repeated unsuccessful calls.",
      "incorrect": {
        "A": "Token expiry requires re-authentication.",
        "C": "Transformations are unrelated.",
        "D": "Schema validation is a separate concern."
      }
    }
  },
  {
    "id": "CH13-0085",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "connection pooling",
    "difficulty": "Medium",
    "question": "Why is connection pooling important for database connectors?",
    "options": {
      "A": "It avoids SQL injection",
      "B": "It reduces overhead of opening new connections",
      "C": "It enforces transaction boundaries",
      "D": "It simplifies schema design"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pooling improves performance by reusing established connections.",
      "incorrect": {
        "A": "SQL injection is prevented by prepared statements.",
        "C": "Transactions are managed separately.",
        "D": "Schema design is unrelated."
      }
    }
  },
  {
    "id": "CH13-0086",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "idempotent writes",
    "difficulty": "Hard",
    "question": "How can idempotency be achieved for database write operations?",
    "options": {
      "A": "Using auto-increment IDs only",
      "B": "Applying unique constraints or natural keys",
      "C": "Increasing fetch size",
      "D": "Disabling transactions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unique constraints ensure repeated writes do not create duplicates.",
      "incorrect": {
        "A": "Auto-increment IDs alone do not prevent duplicates.",
        "C": "Fetch size affects reads only.",
        "D": "Disabling transactions is unsafe."
      }
    }
  },
  {
    "id": "CH13-0087",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "archive strategy",
    "difficulty": "Medium",
    "question": "Why should processed files be archived in file-based integrations?",
    "options": {
      "A": "To increase throughput",
      "B": "To prevent reprocessing and support auditability",
      "C": "To reduce file size",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Archiving avoids duplicate processing and supports traceability.",
      "incorrect": {
        "A": "Throughput is not the primary goal.",
        "C": "File size is unaffected.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH13-0088",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "partial file handling",
    "difficulty": "Hard",
    "question": "What risk exists if a file is read before it is fully written?",
    "options": {
      "A": "Improved latency",
      "B": "Processing incomplete or corrupted data",
      "C": "Reduced memory usage",
      "D": "Simpler retry logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reading incomplete files can lead to corrupted processing results.",
      "incorrect": {
        "A": "Latency improvements are irrelevant.",
        "C": "Memory usage is unrelated.",
        "D": "Retry logic becomes more complex."
      }
    }
  },
  {
    "id": "CH13-0089",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "exactly once myth",
    "difficulty": "Hard",
    "question": "Why is exactly-once delivery difficult to guarantee in distributed messaging systems?",
    "options": {
      "A": "Because authentication is weak",
      "B": "Because network failures can cause duplicate deliveries",
      "C": "Because payloads are large",
      "D": "Because connectors do not support retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Network and system failures can cause retries and duplicates.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Payload size is not the root cause.",
        "D": "Retries are supported."
      }
    }
  },
  {
    "id": "CH13-0090",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "message ordering",
    "difficulty": "Medium",
    "question": "When can message ordering be relied upon in MQ-based integrations?",
    "options": {
      "A": "Across multiple queues",
      "B": "Within a single partition or queue",
      "C": "Across different consumers",
      "D": "Only for synchronous messages"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ordering is generally preserved within a single queue or partition.",
      "incorrect": {
        "A": "Ordering across queues is not guaranteed.",
        "C": "Multiple consumers can break order.",
        "D": "Ordering is not limited to sync flows."
      }
    }
  },

  {
    "id": "CH13-0091",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "file naming",
    "difficulty": "Easy",
    "question": "Why are temporary file extensions often used during file uploads?",
    "options": {
      "A": "To reduce transfer speed",
      "B": "To indicate incomplete file transfer",
      "C": "To encrypt files",
      "D": "To compress data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Temporary extensions signal that a file is not yet ready for processing.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "Encryption is separate.",
        "D": "Compression is unrelated."
      }
    }
  },
  {
    "id": "CH13-0092",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "polling interval",
    "difficulty": "Medium",
    "question": "How should polling intervals be chosen for FTP/SFTP connectors?",
    "options": {
      "A": "As frequently as possible",
      "B": "Based on business needs and system capacity",
      "C": "Randomly to avoid conflicts",
      "D": "Only once per day"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Polling must balance timeliness with resource usage.",
      "incorrect": {
        "A": "Over-polling wastes resources.",
        "C": "Random polling is unpredictable.",
        "D": "Once per day may not meet requirements."
      }
    }
  },
  {
    "id": "CH13-0093",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "fan-out reliability",
    "difficulty": "Medium",
    "question": "What is a key reliability concern in fan-out connector use cases?",
    "options": {
      "A": "Payload size",
      "B": "Partial failure of downstream systems",
      "C": "Authentication complexity",
      "D": "Data transformation speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "One downstream failure should not block others.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Authentication is independent.",
        "D": "Transformation speed is not the main risk."
      }
    }
  },
  {
    "id": "CH13-0094",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "fan-in aggregation",
    "difficulty": "Medium",
    "question": "What challenge is common in fan-in aggregation patterns?",
    "options": {
      "A": "Ensuring data completeness before processing",
      "B": "Reducing authentication steps",
      "C": "Avoiding retries",
      "D": "Improving UI latency"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Fan-in requires waiting for all required inputs.",
      "incorrect": {
        "B": "Authentication is not the main challenge.",
        "C": "Retries may still be needed.",
        "D": "UI latency is unrelated."
      }
    }
  },
  {
    "id": "CH13-0095",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "connector credentials",
    "difficulty": "Easy",
    "question": "Why should different environments use different connector credentials?",
    "options": {
      "A": "To increase API limits",
      "B": "To isolate access and reduce blast radius",
      "C": "To simplify deployments",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Environment isolation limits impact of credential compromise.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Deployments may be more complex.",
        "D": "Logging is unrelated."
      }
    }
  },
  {
    "id": "CH13-0096",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "secret rotation",
    "difficulty": "Medium",
    "question": "Why is regular secret rotation recommended for connector credentials?",
    "options": {
      "A": "To improve performance",
      "B": "To limit exposure if credentials are compromised",
      "C": "To simplify authentication flows",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation reduces long-term risk of leaked credentials.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Flows remain unchanged.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH13-0097",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "connector-level metrics",
    "difficulty": "Easy",
    "question": "Which connector-level metric is most useful for early problem detection?",
    "options": {
      "A": "Number of deployed flows",
      "B": "Error rate trends",
      "C": "Payload schema complexity",
      "D": "Connector version number"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rising error rates often signal emerging issues.",
      "incorrect": {
        "A": "Flow count does not indicate health.",
        "C": "Schema complexity is static.",
        "D": "Version alone is not diagnostic."
      }
    }
  },
  {
    "id": "CH13-0098",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "latency baseline",
    "difficulty": "Medium",
    "question": "Why should baseline latency be established for connector calls?",
    "options": {
      "A": "To reduce retries",
      "B": "To identify abnormal performance degradation",
      "C": "To simplify DataWeave logic",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Baselines help detect deviations from normal behavior.",
      "incorrect": {
        "A": "Retries are independent.",
        "C": "Logic is unrelated.",
        "D": "Authentication is required."
      }
    }
  },
  {
    "id": "CH13-0099",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "connector abstraction",
    "difficulty": "Easy",
    "question": "Why should connectors typically be accessed through System APIs?",
    "options": {
      "A": "To increase speed",
      "B": "To decouple consumers from backend details",
      "C": "To eliminate the need for transformations",
      "D": "To bypass error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs shield consumers from changes in backend systems.",
      "incorrect": {
        "A": "Speed gains are not guaranteed.",
        "C": "Transformations are still required.",
        "D": "Error handling remains essential."
      }
    }
  },
  {
    "id": "CH13-0100",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "configuration management",
    "difficulty": "Easy",
    "question": "Why should connector configuration be externalized?",
    "options": {
      "A": "To hard-code values",
      "B": "To support environment-specific deployments",
      "C": "To reduce testing",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Externalized configuration enables safe promotion across environments.",
      "incorrect": {
        "A": "Hard-coding is risky.",
        "C": "Testing remains required.",
        "D": "Governance is still needed."
      }
    }
  },

  {
    "id": "CH13-0101",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "retry design",
    "difficulty": "Medium",
    "question": "What must be considered before enabling retries on connector operations?",
    "options": {
      "A": "Connector popularity",
      "B": "Idempotency of the operation",
      "C": "Payload size",
      "D": "Flow naming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retries without idempotency can cause duplicate side effects.",
      "incorrect": {
        "A": "Popularity is irrelevant.",
        "C": "Payload size is secondary.",
        "D": "Flow naming has no impact."
      }
    }
  },
  {
    "id": "CH13-0102",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Anti-Patterns",
    "subtopic": "connector sprawl",
    "difficulty": "Medium",
    "question": "What risk does uncontrolled connector sprawl introduce?",
    "options": {
      "A": "Improved reuse",
      "B": "Increased maintenance and governance complexity",
      "C": "Better performance",
      "D": "Simpler architecture"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too many unmanaged connectors increase operational overhead.",
      "incorrect": {
        "A": "Reuse typically decreases.",
        "C": "Performance may degrade.",
        "D": "Architecture becomes complex."
      }
    }
  },
  {
    "id": "CH13-0103",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Anti-Patterns",
    "subtopic": "hard-coded endpoints",
    "difficulty": "Easy",
    "question": "Why are hard-coded connector endpoints discouraged?",
    "options": {
      "A": "They improve speed",
      "B": "They reduce flexibility across environments",
      "C": "They simplify debugging",
      "D": "They improve security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hard-coding makes environment promotion difficult and error-prone.",
      "incorrect": {
        "A": "Speed gains are minimal.",
        "C": "Debugging becomes harder.",
        "D": "Security is weakened."
      }
    }
  },
  {
    "id": "CH13-0104",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Use Cases",
    "subtopic": "batch processing",
    "difficulty": "Medium",
    "question": "Why are connectors often combined with schedulers for batch processing?",
    "options": {
      "A": "To reduce authentication complexity",
      "B": "To process large volumes at controlled intervals",
      "C": "To enable synchronous execution",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scheduling controls load and timing for batch jobs.",
      "incorrect": {
        "A": "Authentication is unchanged.",
        "C": "Batch jobs are typically asynchronous.",
        "D": "Transformations are independent."
      }
    }
  },
  {
    "id": "CH13-0105",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Use Cases",
    "subtopic": "real-time integration",
    "difficulty": "Medium",
    "question": "What is a primary constraint of real-time connector integrations?",
    "options": {
      "A": "Unlimited execution time",
      "B": "Strict latency and timeout requirements",
      "C": "Large batch sizes",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Real-time integrations must respond within tight time limits.",
      "incorrect": {
        "A": "Execution time is limited.",
        "C": "Batching increases latency.",
        "D": "Retries must be automated."
      }
    }
  },
  {
    "id": "CH13-0106",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Observability",
    "subtopic": "correlation ids",
    "difficulty": "Easy",
    "question": "Why should correlation IDs be propagated across connector calls?",
    "options": {
      "A": "To increase throughput",
      "B": "To enable end-to-end tracing across systems",
      "C": "To reduce payload size",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs allow tracing a request across multiple systems.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Payload size is unaffected.",
        "D": "Retries may still occur."
      }
    }
  },
  {
    "id": "CH13-0107",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Governance",
    "subtopic": "connector standards",
    "difficulty": "Easy",
    "question": "Why should enterprises define standards for connector usage?",
    "options": {
      "A": "To slow down development",
      "B": "To ensure consistency, security, and reuse",
      "C": "To eliminate flexibility",
      "D": "To reduce testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards prevent fragmentation and security risks.",
      "incorrect": {
        "A": "Standards enable safe speed.",
        "C": "Flexibility is guided, not removed.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH13-0108",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Governance",
    "subtopic": "connector lifecycle",
    "difficulty": "Easy",
    "question": "Which activity is part of connector lifecycle management?",
    "options": {
      "A": "Initial development only",
      "B": "Versioning, monitoring, and retirement",
      "C": "Payload mapping only",
      "D": "Authentication setup only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors must be managed throughout their lifespan.",
      "incorrect": {
        "A": "Lifecycle extends beyond development.",
        "C": "Mapping is only one aspect.",
        "D": "Authentication is only one concern."
      }
    }
  },
  {
    "id": "CH13-0109",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability principle",
    "difficulty": "Easy",
    "question": "What connector characteristic best supports scalability?",
    "options": {
      "A": "Stateful processing",
      "B": "Stateless and reusable design",
      "C": "Hard-coded credentials",
      "D": "Manual configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless reuse enables horizontal scaling.",
      "incorrect": {
        "A": "State limits scalability.",
        "C": "Hard-coding is insecure.",
        "D": "Manual steps do not scale."
      }
    }
  },
  {
    "id": "CH13-0110",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "reliability insight",
    "difficulty": "Easy",
    "question": "What combination most improves connector reliability?",
    "options": {
      "A": "Ignoring transient errors",
      "B": "Retries, idempotency, and monitoring",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability depends on structured resilience mechanisms.",
      "incorrect": {
        "A": "Ignoring errors increases risk.",
        "C": "Hard-coding increases fragility.",
        "D": "Logging is essential."
      }
    }
  },

  {
    "id": "CH13-0111",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security takeaway",
    "difficulty": "Easy",
    "question": "What is the most common security weakness in connector-based integrations?",
    "options": {
      "A": "Large payloads",
      "B": "Poor credential management",
      "C": "Slow responses",
      "D": "Complex mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Most incidents stem from credential mismanagement.",
      "incorrect": {
        "A": "Payload size is not a security issue.",
        "C": "Latency is operational.",
        "D": "Mappings affect maintainability."
      }
    }
  },
  {
    "id": "CH13-0112",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design mindset",
    "difficulty": "Easy",
    "question": "Which mindset best supports long-term connector success?",
    "options": {
      "A": "Project-only thinking",
      "B": "Product and lifecycle ownership",
      "C": "Minimal testing",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors require continuous ownership and improvement.",
      "incorrect": {
        "A": "Projects end but integrations persist.",
        "C": "Testing is mandatory.",
        "D": "Ad-hoc fixes increase instability."
      }
    }
  },
  {
    "id": "CH13-0113",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture fit",
    "difficulty": "Easy",
    "question": "Which architecture best complements extensive connector usage?",
    "options": {
      "A": "Point-to-point integration",
      "B": "API-led layered architecture",
      "C": "Monolithic design",
      "D": "Hard-coded workflows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led architecture maximizes reuse and decoupling.",
      "incorrect": {
        "A": "Point-to-point increases coupling.",
        "C": "Monoliths reduce flexibility.",
        "D": "Hard-coding reduces maintainability."
      }
    }
  },
  {
    "id": "CH13-0114",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational excellence",
    "difficulty": "Easy",
    "question": "What best defines operational excellence for connector-heavy systems?",
    "options": {
      "A": "Manual monitoring",
      "B": "Automated monitoring, alerts, and runbooks",
      "C": "Minimal logging",
      "D": "Ad-hoc incident handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures fast and consistent recovery.",
      "incorrect": {
        "A": "Manual monitoring does not scale.",
        "C": "Logging is essential.",
        "D": "Ad-hoc handling increases downtime."
      }
    }
  },
  {
    "id": "CH13-0115",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam strategy",
    "difficulty": "Easy",
    "question": "What is the best approach to connector-related exam questions?",
    "options": {
      "A": "Memorize connector properties",
      "B": "Analyze the scenario and constraints carefully",
      "C": "Focus on UI steps",
      "D": "Ignore non-functional requirements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario-based decision making.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "UI steps are secondary.",
        "D": "Non-functional requirements are critical."
      }
    }
  },
  {
    "id": "CH13-0116",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "failure handling",
    "difficulty": "Easy",
    "question": "Which approach best handles connector failures?",
    "options": {
      "A": "Ignore failures",
      "B": "Retries, DLQs, and alerts",
      "C": "Hard-coded logic",
      "D": "Manual restarts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structured failure handling prevents cascading issues.",
      "incorrect": {
        "A": "Ignoring failures increases risk.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual restarts do not scale."
      }
    }
  },
  {
    "id": "CH13-0117",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "long-term value",
    "difficulty": "Easy",
    "question": "Why should connectors be treated as long-term assets?",
    "options": {
      "A": "They never change",
      "B": "They require ongoing maintenance and evolution",
      "C": "They eliminate APIs",
      "D": "They reduce governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors evolve with business and system changes.",
      "incorrect": {
        "A": "Change is inevitable.",
        "C": "APIs remain necessary.",
        "D": "Governance is essential."
      }
    }
  },
  {
    "id": "CH13-0118",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design principle",
    "difficulty": "Easy",
    "question": "Which principle should always guide connector usage?",
    "options": {
      "A": "Direct system coupling",
      "B": "Loose coupling and abstraction",
      "C": "Minimal testing",
      "D": "Ignoring failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and adaptability.",
      "incorrect": {
        "A": "Direct coupling increases fragility.",
        "C": "Testing is mandatory.",
        "D": "Failures must be handled."
      }
    }
  },
  {
    "id": "CH13-0119",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise takeaway",
    "difficulty": "Easy",
    "question": "What is the key enterprise takeaway for connector usage?",
    "options": {
      "A": "Use connectors everywhere directly",
      "B": "Balance flexibility, security, and governance",
      "C": "Avoid abstraction",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise success depends on balanced design choices.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0120",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "ultimate takeaway",
    "difficulty": "Easy",
    "question": "What best summarizes effective use of connectors?",
    "options": {
      "A": "Connectors replace APIs",
      "B": "Connectors enable integration within governed architectures",
      "C": "Connectors eliminate complexity",
      "D": "Connectors remove the need for testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors are most effective when used within strong architectural governance.",
      "incorrect": {
        "A": "APIs remain essential.",
        "C": "Complexity still exists.",
        "D": "Testing remains mandatory."
      }
    }
  },
  {
    "id": "CH13-0121",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "api limits",
    "difficulty": "Medium",
    "question": "Why must Salesforce API limits be considered when designing connector-based integrations?",
    "options": {
      "A": "They affect payload size",
      "B": "They can throttle or block integration traffic",
      "C": "They disable validation rules",
      "D": "They change object schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exceeding API limits can cause throttling or failures.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation rules remain active.",
        "D": "Schemas are unchanged."
      }
    }
  },
  {
    "id": "CH13-0122",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "query locator",
    "difficulty": "Hard",
    "question": "What is the purpose of a query locator in Salesforce bulk query operations?",
    "options": {
      "A": "To authenticate requests",
      "B": "To retrieve large result sets incrementally",
      "C": "To enforce ordering",
      "D": "To transform results"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Query locators allow pagination of large result sets.",
      "incorrect": {
        "A": "Authentication is separate.",
        "C": "Ordering is not guaranteed.",
        "D": "Transformations are not handled here."
      }
    }
  },
  {
    "id": "CH13-0123",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "connection reuse",
    "difficulty": "Medium",
    "question": "Why is connection reuse important for HTTP connector performance?",
    "options": {
      "A": "It eliminates authentication",
      "B": "It reduces TCP handshake overhead",
      "C": "It increases payload size",
      "D": "It disables retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusing connections avoids repeated connection setup costs.",
      "incorrect": {
        "A": "Authentication is still required.",
        "C": "Payload size is unaffected.",
        "D": "Retries remain configurable."
      }
    }
  },
  {
    "id": "CH13-0124",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "http status handling",
    "difficulty": "Medium",
    "question": "Why should HTTP status codes be explicitly handled in connector flows?",
    "options": {
      "A": "To simplify DataWeave scripts",
      "B": "To apply different logic based on response outcome",
      "C": "To bypass retries",
      "D": "To reduce latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Different status codes require different processing strategies.",
      "incorrect": {
        "A": "Scripts are independent.",
        "C": "Retries may still apply.",
        "D": "Latency is unaffected."
      }
    }
  },
  {
    "id": "CH13-0125",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "transaction scope",
    "difficulty": "Medium",
    "question": "Why should multiple related database operations be wrapped in a transaction?",
    "options": {
      "A": "To improve query speed",
      "B": "To ensure atomicity and consistency",
      "C": "To simplify mappings",
      "D": "To avoid connection pooling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactions ensure all operations succeed or fail together.",
      "incorrect": {
        "A": "Speed is secondary.",
        "C": "Mappings are unrelated.",
        "D": "Pooling still applies."
      }
    }
  },
  {
    "id": "CH13-0126",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "deadlocks",
    "difficulty": "Hard",
    "question": "What is a common cause of database deadlocks in connector-based integrations?",
    "options": {
      "A": "Small payloads",
      "B": "Long-running transactions holding locks",
      "C": "Prepared statements",
      "D": "Read-only queries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Extended lock holding increases deadlock probability.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Prepared statements are safe.",
        "D": "Read-only queries rarely cause deadlocks."
      }
    }
  },
  {
    "id": "CH13-0127",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "file sequencing",
    "difficulty": "Medium",
    "question": "Why is file sequencing important in some file-based integrations?",
    "options": {
      "A": "To reduce file size",
      "B": "To ensure correct processing order",
      "C": "To simplify authentication",
      "D": "To improve encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Certain business processes depend on ordered file processing.",
      "incorrect": {
        "A": "Size is unrelated.",
        "C": "Authentication is independent.",
        "D": "Encryption is separate."
      }
    }
  },
  {
    "id": "CH13-0128",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "error recovery",
    "difficulty": "Medium",
    "question": "What is a recommended approach when file processing fails midway?",
    "options": {
      "A": "Delete the file immediately",
      "B": "Move the file to an error or quarantine location",
      "C": "Ignore the failure",
      "D": "Disable retries permanently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Quarantining allows investigation without reprocessing.",
      "incorrect": {
        "A": "Deletion causes data loss.",
        "C": "Ignoring failures is unsafe.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH13-0129",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "consumer concurrency",
    "difficulty": "Medium",
    "question": "What is the effect of increasing consumer concurrency in MQ connectors?",
    "options": {
      "A": "Guaranteed message ordering",
      "B": "Higher throughput with potential ordering impact",
      "C": "Lower latency always",
      "D": "Reduced resource usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parallel consumers improve throughput but may affect order.",
      "incorrect": {
        "A": "Ordering may be broken.",
        "C": "Latency depends on workload.",
        "D": "Resources usage increases."
      }
    }
  },
  {
    "id": "CH13-0130",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "redelivery policy",
    "difficulty": "Hard",
    "question": "Why should redelivery policies be carefully tuned in messaging use cases?",
    "options": {
      "A": "To reduce payload size",
      "B": "To avoid infinite retry loops and system overload",
      "C": "To simplify authentication",
      "D": "To improve schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Uncontrolled retries can exhaust system resources.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is independent.",
        "D": "Schema validation is unrelated."
      }
    }
  },

  {
    "id": "CH13-0131",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "file permissions",
    "difficulty": "Easy",
    "question": "Why should file permissions be validated in FTP/SFTP integrations?",
    "options": {
      "A": "To increase throughput",
      "B": "To ensure the connector can read and write files securely",
      "C": "To simplify polling",
      "D": "To avoid encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Incorrect permissions cause runtime failures.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Polling is unrelated.",
        "D": "Encryption is still required."
      }
    }
  },
  {
    "id": "CH13-0132",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "network latency",
    "difficulty": "Medium",
    "question": "How does high network latency affect FTP/SFTP connector behavior?",
    "options": {
      "A": "It improves reliability",
      "B": "It can increase transfer times and timeout risk",
      "C": "It reduces encryption strength",
      "D": "It simplifies retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Latency increases transfer duration and timeout likelihood.",
      "incorrect": {
        "A": "Reliability may decrease.",
        "C": "Encryption is unaffected.",
        "D": "Retries become more complex."
      }
    }
  },
  {
    "id": "CH13-0133",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "synchronous limitations",
    "difficulty": "Medium",
    "question": "What is a key limitation of synchronous connector-based integrations?",
    "options": {
      "A": "Unlimited execution time",
      "B": "Tight coupling to downstream system availability",
      "C": "Lack of monitoring",
      "D": "Inability to transform payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Synchronous flows depend on immediate downstream responses.",
      "incorrect": {
        "A": "Execution time is limited.",
        "C": "Monitoring is available.",
        "D": "Transformations are supported."
      }
    }
  },
  {
    "id": "CH13-0134",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "async buffering",
    "difficulty": "Medium",
    "question": "Why are queues often used as buffers in connector-based integrations?",
    "options": {
      "A": "To reduce payload size",
      "B": "To absorb traffic spikes and decouple systems",
      "C": "To simplify authentication",
      "D": "To enforce ordering globally"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Queues smooth load and isolate producers from consumers.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is independent.",
        "D": "Global ordering is not guaranteed."
      }
    }
  },
  {
    "id": "CH13-0135",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "connector isolation",
    "difficulty": "Medium",
    "question": "Why should connector access be isolated per application or API?",
    "options": {
      "A": "To increase API limits",
      "B": "To reduce blast radius in case of compromise",
      "C": "To simplify logging",
      "D": "To avoid transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation limits the impact of security breaches.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Logging is separate.",
        "D": "Transformations are unrelated."
      }
    }
  },
  {
    "id": "CH13-0136",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "token expiration",
    "difficulty": "Medium",
    "question": "What should connector flows do when authentication tokens expire?",
    "options": {
      "A": "Fail permanently",
      "B": "Refresh or re-authenticate securely",
      "C": "Ignore expiration",
      "D": "Disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure token refresh ensures continuity without manual intervention.",
      "incorrect": {
        "A": "Permanent failure is undesirable.",
        "C": "Ignoring expiration causes failures.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH13-0137",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "throughput metrics",
    "difficulty": "Easy",
    "question": "Why is monitoring connector throughput important?",
    "options": {
      "A": "To reduce payload size",
      "B": "To detect bottlenecks and capacity issues",
      "C": "To simplify mappings",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Throughput trends reveal scaling and performance issues.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Mappings are unaffected.",
        "D": "Retries are independent."
      }
    }
  },
  {
    "id": "CH13-0138",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "alert thresholds",
    "difficulty": "Medium",
    "question": "Why should alert thresholds be carefully tuned for connector errors?",
    "options": {
      "A": "To increase alert noise",
      "B": "To avoid alert fatigue while catching real issues",
      "C": "To reduce latency",
      "D": "To simplify deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proper thresholds balance responsiveness and noise.",
      "incorrect": {
        "A": "Noise reduces effectiveness.",
        "C": "Latency is unrelated.",
        "D": "Deployments are unaffected."
      }
    }
  },
  {
    "id": "CH13-0139",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "configuration reuse",
    "difficulty": "Easy",
    "question": "Why should connector configurations be reused across flows?",
    "options": {
      "A": "To increase coupling",
      "B": "To ensure consistency and reduce errors",
      "C": "To avoid governance",
      "D": "To disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse reduces duplication and configuration drift.",
      "incorrect": {
        "A": "Coupling is not increased.",
        "C": "Governance still applies.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH13-0140",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "environment parity",
    "difficulty": "Easy",
    "question": "Why should connector behavior remain consistent across environments?",
    "options": {
      "A": "To simplify UI configuration",
      "B": "To reduce deployment and testing risks",
      "C": "To increase API limits",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency prevents environment-specific failures.",
      "incorrect": {
        "A": "UI configuration is secondary.",
        "C": "Limits are unchanged.",
        "D": "Documentation is still required."
      }
    }
  },

  {
    "id": "CH13-0141",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "runbooks",
    "difficulty": "Easy",
    "question": "Why should runbooks exist for connector failures?",
    "options": {
      "A": "To increase deployment speed",
      "B": "To ensure consistent incident response",
      "C": "To avoid retries",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runbooks standardize response during incidents.",
      "incorrect": {
        "A": "Deployment speed is unrelated.",
        "C": "Retries are still used.",
        "D": "Transformations are unaffected."
      }
    }
  },
  {
    "id": "CH13-0142",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "capacity planning",
    "difficulty": "Medium",
    "question": "Why is capacity planning important for connector-heavy integrations?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent saturation under peak load",
      "C": "To simplify security",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Planning ensures systems handle expected growth.",
      "incorrect": {
        "A": "Payload size is independent.",
        "C": "Security is separate.",
        "D": "Retries remain necessary."
      }
    }
  },
  {
    "id": "CH13-0143",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design balance",
    "difficulty": "Easy",
    "question": "What balance is most important in connector-based architectures?",
    "options": {
      "A": "Speed over reliability",
      "B": "Flexibility, security, and maintainability",
      "C": "Minimal monitoring",
      "D": "Direct system access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Successful designs balance multiple non-functional concerns.",
      "incorrect": {
        "A": "Reliability is critical.",
        "C": "Monitoring is essential.",
        "D": "Direct access increases risk."
      }
    }
  },
  {
    "id": "CH13-0144",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability takeaway",
    "difficulty": "Easy",
    "question": "What most directly enables horizontal scaling in connector-based systems?",
    "options": {
      "A": "Stateful flows",
      "B": "Stateless processing and externalized state",
      "C": "Hard-coded endpoints",
      "D": "Manual configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless designs allow instances to scale independently.",
      "incorrect": {
        "A": "State limits scaling.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual steps do not scale."
      }
    }
  },
  {
    "id": "CH13-0145",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "reliability insight",
    "difficulty": "Easy",
    "question": "Which combination most improves connector reliability?",
    "options": {
      "A": "Ignoring transient failures",
      "B": "Timeouts, retries, and idempotency",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Structured resilience mechanisms prevent cascading failures.",
      "incorrect": {
        "A": "Ignoring failures increases risk.",
        "C": "Hard-coding reduces adaptability.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH13-0146",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security reminder",
    "difficulty": "Easy",
    "question": "What security practice is most critical for connector-based integrations?",
    "options": {
      "A": "Broad system access",
      "B": "Least privilege and secure credential handling",
      "C": "Disabled auditing",
      "D": "Hard-coded secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege reduces exposure and risk.",
      "incorrect": {
        "A": "Broad access increases risk.",
        "C": "Auditing is required.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0147",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "governance insight",
    "difficulty": "Easy",
    "question": "Why is governance essential in connector-heavy environments?",
    "options": {
      "A": "To slow development",
      "B": "To ensure consistency, security, and reuse",
      "C": "To eliminate flexibility",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance prevents fragmentation and risk.",
      "incorrect": {
        "A": "Governance enables safe speed.",
        "C": "Flexibility is guided, not removed.",
        "D": "Testing remains mandatory."
      }
    }
  },
  {
    "id": "CH13-0148",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam focus",
    "difficulty": "Easy",
    "question": "What do connector-related exam questions primarily evaluate?",
    "options": {
      "A": "Exact XML syntax",
      "B": "Scenario-based decision making",
      "C": "UI navigation steps",
      "D": "File system paths"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams focus on selecting appropriate patterns and designs.",
      "incorrect": {
        "A": "Syntax memorization is secondary.",
        "C": "UI steps are not the focus.",
        "D": "Paths are not tested."
      }
    }
  },
  {
    "id": "CH13-0149",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "integration maturity",
    "difficulty": "Easy",
    "question": "Which characteristic best indicates mature connector usage?",
    "options": {
      "A": "Point-to-point integrations",
      "B": "Standardized, monitored, and governed connectors",
      "C": "Minimal documentation",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is shown through discipline and consistency.",
      "incorrect": {
        "A": "Point-to-point is fragile.",
        "C": "Documentation is essential.",
        "D": "Ad-hoc fixes increase instability."
      }
    }
  },
  {
    "id": "CH13-0150",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "ultimate takeaway",
    "difficulty": "Easy",
    "question": "What best summarizes effective connector usage in enterprises?",
    "options": {
      "A": "Use connectors directly everywhere",
      "B": "Use connectors thoughtfully within governed architectures",
      "C": "Avoid abstraction layers",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Thoughtful, governed use maximizes value and reduces risk.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0151",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "concurrent api usage",
    "difficulty": "Hard",
    "question": "What is a key risk when multiple Mule applications share the same Salesforce integration user?",
    "options": {
      "A": "Payload schema conflicts",
      "B": "API limit exhaustion across applications",
      "C": "Automatic token refresh failure",
      "D": "Loss of object permissions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "All applications consume from the same API limit pool, risking throttling.",
      "incorrect": {
        "A": "Schemas are independent of users.",
        "C": "Token refresh is not affected by concurrency.",
        "D": "Permissions do not change dynamically."
      }
    }
  },
  {
    "id": "CH13-0152",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "payload streaming",
    "difficulty": "Medium",
    "question": "Why is payload streaming recommended for large HTTP responses?",
    "options": {
      "A": "It disables retries",
      "B": "It prevents loading the entire payload into memory",
      "C": "It simplifies schema validation",
      "D": "It reduces authentication overhead"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming processes data incrementally, reducing memory pressure.",
      "incorrect": {
        "A": "Retries remain configurable.",
        "C": "Schema validation is unaffected.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH13-0153",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "batch commits",
    "difficulty": "Medium",
    "question": "Why should batch database inserts commit in controlled intervals?",
    "options": {
      "A": "To increase API limits",
      "B": "To reduce rollback impact and resource contention",
      "C": "To avoid using transactions",
      "D": "To simplify SQL syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller commit intervals reduce lock duration and rollback cost.",
      "incorrect": {
        "A": "API limits are unrelated.",
        "C": "Transactions are still required.",
        "D": "Syntax is unaffected."
      }
    }
  },
  {
    "id": "CH13-0154",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "reprocessing strategy",
    "difficulty": "Medium",
    "question": "What is the safest way to support controlled reprocessing of failed files?",
    "options": {
      "A": "Automatically re-read the input directory",
      "B": "Store failed files in a quarantine location with metadata",
      "C": "Delete files after failure",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Quarantine allows controlled, auditable reprocessing.",
      "incorrect": {
        "A": "This risks duplicate processing.",
        "C": "Deletion causes data loss.",
        "D": "Error handling is mandatory."
      }
    }
  },
  {
    "id": "CH13-0155",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "back pressure",
    "difficulty": "Hard",
    "question": "How does back pressure protect connector-based messaging systems?",
    "options": {
      "A": "By increasing queue depth",
      "B": "By slowing producers when consumers are overwhelmed",
      "C": "By disabling acknowledgements",
      "D": "By increasing message size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Back pressure prevents system overload by regulating message flow.",
      "incorrect": {
        "A": "Queue depth growth increases risk.",
        "C": "Acknowledgements remain essential.",
        "D": "Message size worsens pressure."
      }
    }
  },
  {
    "id": "CH13-0156",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "shared credentials risk",
    "difficulty": "Medium",
    "question": "Why are shared connector credentials across teams discouraged?",
    "options": {
      "A": "They reduce throughput",
      "B": "They eliminate accountability and increase blast radius",
      "C": "They complicate transformations",
      "D": "They prevent token refresh"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared credentials make auditing and isolation difficult.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Transformations are unrelated.",
        "D": "Token refresh still works."
      }
    }
  },
  {
    "id": "CH13-0157",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "error trends",
    "difficulty": "Easy",
    "question": "Why are gradual increases in connector error rates dangerous?",
    "options": {
      "A": "They improve observability",
      "B": "They often indicate hidden systemic degradation",
      "C": "They reduce latency",
      "D": "They simplify retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Slow error growth often precedes major outages.",
      "incorrect": {
        "A": "They signal problems, not improvements.",
        "C": "Latency may worsen.",
        "D": "Retries may amplify failures."
      }
    }
  },
  {
    "id": "CH13-0158",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Architecture",
    "subtopic": "system api role",
    "difficulty": "Easy",
    "question": "Why should connectors typically reside behind System APIs?",
    "options": {
      "A": "To increase response size",
      "B": "To isolate backend changes from consumers",
      "C": "To remove security enforcement",
      "D": "To eliminate transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs abstract backend volatility and protect consumers.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Security remains enforced.",
        "D": "Transformations are still required."
      }
    }
  },
  {
    "id": "CH13-0159",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "connector versioning",
    "difficulty": "Medium",
    "question": "Why should connector upgrades be version-controlled and tested separately?",
    "options": {
      "A": "To increase deployment speed",
      "B": "To avoid unexpected breaking behavior",
      "C": "To bypass governance",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connector updates can introduce behavioral or dependency changes.",
      "incorrect": {
        "A": "Speed without safety is risky.",
        "C": "Governance is still required.",
        "D": "Authentication is unchanged."
      }
    }
  },
  {
    "id": "CH13-0160",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise takeaway",
    "difficulty": "Easy",
    "question": "What ultimately determines successful connector usage at scale?",
    "options": {
      "A": "Number of connectors used",
      "B": "Architecture, governance, and operational discipline",
      "C": "Minimal error handling",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scale depends on design discipline, not connector count.",
      "incorrect": {
        "A": "Quantity increases complexity.",
        "C": "Error handling is essential.",
        "D": "Hard-coding reduces resilience."
      }
    }
  },
  {
    "id": "CH13-0161",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "bulk job lifecycle",
    "difficulty": "Hard",
    "question": "Why must Salesforce Bulk API jobs be explicitly closed after data upload?",
    "options": {
      "A": "To refresh authentication tokens",
      "B": "To signal Salesforce to start processing the batch",
      "C": "To reduce API limit usage",
      "D": "To enable result streaming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Closing the job signals Salesforce that all data is uploaded and processing can begin.",
      "incorrect": {
        "A": "Token refresh is unrelated.",
        "C": "API usage is unaffected.",
        "D": "Streaming is not enabled by job closure."
      }
    }
  },
  {
    "id": "CH13-0162",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "partial failures",
    "difficulty": "Medium",
    "question": "How should partial record failures be handled in Salesforce bulk operations?",
    "options": {
      "A": "Fail the entire integration",
      "B": "Capture per-record success and error results",
      "C": "Retry the entire batch blindly",
      "D": "Ignore failed records"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk operations return record-level results that must be evaluated individually.",
      "incorrect": {
        "A": "Partial success is common and expected.",
        "C": "Blind retries can cause duplicates.",
        "D": "Ignoring failures causes data loss."
      }
    }
  },
  {
    "id": "CH13-0163",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "content negotiation",
    "difficulty": "Medium",
    "question": "What is the purpose of content negotiation when using the HTTP connector?",
    "options": {
      "A": "To control retry behavior",
      "B": "To agree on request and response media types",
      "C": "To enforce authentication",
      "D": "To reduce network latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Headers such as Accept and Content-Type define media format expectations.",
      "incorrect": {
        "A": "Retries are configured separately.",
        "C": "Authentication is independent.",
        "D": "Latency is not controlled by negotiation."
      }
    }
  },
  {
    "id": "CH13-0164",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "idempotency keys",
    "difficulty": "Hard",
    "question": "Why are idempotency keys useful in HTTP-based write operations?",
    "options": {
      "A": "They improve payload validation",
      "B": "They prevent duplicate side effects during retries",
      "C": "They reduce authentication overhead",
      "D": "They enforce schema consistency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotency keys allow safe retries without duplicating operations.",
      "incorrect": {
        "A": "Validation is separate.",
        "C": "Authentication is unchanged.",
        "D": "Schemas are unrelated."
      }
    }
  },
  {
    "id": "CH13-0165",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "write contention",
    "difficulty": "Hard",
    "question": "What increases write contention in database connector integrations?",
    "options": {
      "A": "Short-lived transactions",
      "B": "High concurrency on the same rows",
      "C": "Read-only queries",
      "D": "Indexed lookups"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Concurrent writes to the same records compete for locks.",
      "incorrect": {
        "A": "Short transactions reduce contention.",
        "C": "Reads typically do not lock writes.",
        "D": "Indexes improve access patterns."
      }
    }
  },
  {
    "id": "CH13-0166",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "read consistency",
    "difficulty": "Medium",
    "question": "Why is read consistency important in database-based integrations?",
    "options": {
      "A": "To improve transformation speed",
      "B": "To ensure consumers receive predictable data states",
      "C": "To reduce memory usage",
      "D": "To avoid connection pooling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent reads prevent consumers from seeing partial updates.",
      "incorrect": {
        "A": "Transformations are independent.",
        "C": "Memory usage is unrelated.",
        "D": "Pooling is unaffected."
      }
    }
  },
  {
    "id": "CH13-0167",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "large file handling",
    "difficulty": "Medium",
    "question": "What is the preferred strategy for processing very large files?",
    "options": {
      "A": "Load entire file into memory",
      "B": "Stream and process incrementally",
      "C": "Disable validation",
      "D": "Increase heap size only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming avoids memory exhaustion and improves stability.",
      "incorrect": {
        "A": "Full loading risks out-of-memory errors.",
        "C": "Validation remains necessary.",
        "D": "Heap increases alone are insufficient."
      }
    }
  },
  {
    "id": "CH13-0168",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "duplicate detection",
    "difficulty": "Medium",
    "question": "How can duplicate file processing be prevented reliably?",
    "options": {
      "A": "Increase polling frequency",
      "B": "Track processed file metadata persistently",
      "C": "Rely on file timestamps only",
      "D": "Disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Persistent tracking ensures idempotent file processing.",
      "incorrect": {
        "A": "Frequent polling increases risk.",
        "C": "Timestamps are unreliable alone.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH13-0169",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "consumer lag",
    "difficulty": "Medium",
    "question": "What does increasing consumer lag indicate in a messaging system?",
    "options": {
      "A": "Improved throughput",
      "B": "Consumers are slower than producers",
      "C": "Messages are duplicated",
      "D": "Authentication failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lag grows when consumption cannot keep up with production.",
      "incorrect": {
        "A": "Throughput mismatch causes lag.",
        "C": "Lag does not imply duplication.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH13-0170",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "message replay",
    "difficulty": "Hard",
    "question": "When should message replay be used cautiously?",
    "options": {
      "A": "When messages are idempotent",
      "B": "When downstream operations are non-idempotent",
      "C": "When queues are empty",
      "D": "When using at-most-once delivery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Replaying non-idempotent messages can cause duplicate side effects.",
      "incorrect": {
        "A": "Idempotency makes replay safe.",
        "C": "Empty queues are irrelevant.",
        "D": "Replay is unrelated to delivery guarantee."
      }
    }
  },

  {
    "id": "CH13-0171",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "atomic writes",
    "difficulty": "Medium",
    "question": "Why are atomic file write patterns important in SFTP integrations?",
    "options": {
      "A": "To increase throughput",
      "B": "To prevent consumers from reading incomplete files",
      "C": "To simplify encryption",
      "D": "To reduce file size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Atomic writes ensure files are visible only after full creation.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Encryption is separate.",
        "D": "File size is unaffected."
      }
    }
  },
  {
    "id": "CH13-0172",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "network interruptions",
    "difficulty": "Medium",
    "question": "What is the safest response to a mid-transfer network interruption?",
    "options": {
      "A": "Assume success",
      "B": "Retry with validation or checksum verification",
      "C": "Delete the file silently",
      "D": "Disable further transfers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Verification ensures file integrity before processing.",
      "incorrect": {
        "A": "Assumption risks corruption.",
        "C": "Silent deletion loses data.",
        "D": "Transfers should resume safely."
      }
    }
  },
  {
    "id": "CH13-0173",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "sync vs async",
    "difficulty": "Medium",
    "question": "What primarily drives the decision between synchronous and asynchronous connector usage?",
    "options": {
      "A": "Connector type",
      "B": "Business latency requirements",
      "C": "Payload size",
      "D": "Number of transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "User-facing latency requirements dictate sync vs async design.",
      "incorrect": {
        "A": "Connectors support both patterns.",
        "C": "Payload size is secondary.",
        "D": "Transformations are independent."
      }
    }
  },
  {
    "id": "CH13-0174",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "eventual consistency",
    "difficulty": "Medium",
    "question": "Why is eventual consistency acceptable in many connector-based architectures?",
    "options": {
      "A": "It improves security",
      "B": "It increases scalability and resilience",
      "C": "It eliminates retries",
      "D": "It guarantees ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Eventual consistency decouples systems and improves scalability.",
      "incorrect": {
        "A": "Security is unaffected.",
        "C": "Retries may still occur.",
        "D": "Ordering is not guaranteed."
      }
    }
  },
  {
    "id": "CH13-0175",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "connector blast radius",
    "difficulty": "Medium",
    "question": "What design choice most reduces the blast radius of a compromised connector?",
    "options": {
      "A": "Shared credentials",
      "B": "Least privilege and isolated credentials",
      "C": "Hard-coded logic",
      "D": "Disabled monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation and least privilege limit damage.",
      "incorrect": {
        "A": "Shared credentials increase risk.",
        "C": "Hard-coding worsens security.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0176",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "audit trails",
    "difficulty": "Easy",
    "question": "Why are audit trails important for connector operations?",
    "options": {
      "A": "To reduce payload size",
      "B": "To support forensic analysis and compliance",
      "C": "To simplify transformations",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audit trails enable traceability and compliance verification.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Transformations are unaffected.",
        "D": "Retries remain necessary."
      }
    }
  },
  {
    "id": "CH13-0177",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "latency spikes",
    "difficulty": "Medium",
    "question": "What often causes sudden latency spikes in connector calls?",
    "options": {
      "A": "Improved caching",
      "B": "Downstream system saturation",
      "C": "Smaller payloads",
      "D": "Reduced concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Overloaded downstream systems respond more slowly.",
      "incorrect": {
        "A": "Caching reduces latency.",
        "C": "Smaller payloads are faster.",
        "D": "Reduced concurrency lowers contention."
      }
    }
  },
  {
    "id": "CH13-0178",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "slo alignment",
    "difficulty": "Easy",
    "question": "Why should connector performance align with defined SLOs?",
    "options": {
      "A": "To increase deployment speed",
      "B": "To meet business reliability expectations",
      "C": "To reduce transformations",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLOs define acceptable performance and reliability levels.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Transformations are unrelated.",
        "D": "Governance remains essential."
      }
    }
  },

  {
    "id": "CH13-0179",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "connector reuse",
    "difficulty": "Easy",
    "question": "What is a key benefit of reusing connector configurations?",
    "options": {
      "A": "Increased coupling",
      "B": "Reduced configuration drift",
      "C": "Disabled monitoring",
      "D": "Hard-coded behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse ensures consistency across integrations.",
      "incorrect": {
        "A": "Coupling is not increased.",
        "C": "Monitoring remains active.",
        "D": "Hard-coding is discouraged."
      }
    }
  },
  {
    "id": "CH13-0180",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "environment isolation",
    "difficulty": "Easy",
    "question": "Why should connectors be isolated per environment?",
    "options": {
      "A": "To increase API limits",
      "B": "To prevent cross-environment impact",
      "C": "To simplify transformations",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation prevents test or dev issues from affecting production.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Transformations are independent.",
        "D": "Logging is still required."
      }
    }
  },
  {
    "id": "CH13-0181",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "change management",
    "difficulty": "Medium",
    "question": "Why is controlled change management critical for connector updates?",
    "options": {
      "A": "To increase release frequency",
      "B": "To avoid breaking dependent integrations",
      "C": "To simplify authentication",
      "D": "To reduce monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connector changes can impact multiple consumers.",
      "incorrect": {
        "A": "Speed without safety is risky.",
        "C": "Authentication is unchanged.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH13-0182",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "rollback strategy",
    "difficulty": "Medium",
    "question": "Why should connector upgrades always have a rollback plan?",
    "options": {
      "A": "To increase confidence during deployment",
      "B": "To quickly recover from unexpected issues",
      "C": "To bypass governance",
      "D": "To reduce testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback enables fast recovery if issues occur.",
      "incorrect": {
        "A": "Confidence alone is insufficient.",
        "C": "Governance is still required.",
        "D": "Testing remains mandatory."
      }
    }
  },
  {
    "id": "CH13-0183",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design priority",
    "difficulty": "Easy",
    "question": "What should be the top design priority in connector-heavy architectures?",
    "options": {
      "A": "Speed only",
      "B": "Reliability and maintainability",
      "C": "Minimal governance",
      "D": "Direct system access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-term stability matters more than short-term speed.",
      "incorrect": {
        "A": "Speed without reliability is risky.",
        "C": "Governance is essential.",
        "D": "Direct access increases coupling."
      }
    }
  },
  {
    "id": "CH13-0184",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling insight",
    "difficulty": "Easy",
    "question": "What most enables scaling connector-based systems safely?",
    "options": {
      "A": "Stateful design",
      "B": "Stateless processing and strong governance",
      "C": "Hard-coded logic",
      "D": "Manual interventions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless design combined with governance enables safe scaling.",
      "incorrect": {
        "A": "State limits scalability.",
        "C": "Hard-coding increases risk.",
        "D": "Manual steps do not scale."
      }
    }
  },
  {
    "id": "CH13-0185",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise lesson",
    "difficulty": "Easy",
    "question": "What is the core enterprise lesson for connector usage?",
    "options": {
      "A": "Use as many connectors as possible",
      "B": "Architecture and governance matter more than tooling",
      "C": "Avoid abstraction",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tools succeed only within good architectural discipline.",
      "incorrect": {
        "A": "More connectors increase complexity.",
        "C": "Abstraction is essential.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0186",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam readiness",
    "difficulty": "Easy",
    "question": "What best prepares candidates for connector-based exam questions?",
    "options": {
      "A": "Memorizing connector properties",
      "B": "Practicing scenario-based reasoning",
      "C": "Focusing on UI steps",
      "D": "Ignoring non-functional requirements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario analysis over memorization.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "UI steps are secondary.",
        "D": "Non-functional requirements are critical."
      }
    }
  },
  {
    "id": "CH13-0187",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "resilience takeaway",
    "difficulty": "Easy",
    "question": "Which combination best improves integration resilience?",
    "options": {
      "A": "Ignoring failures",
      "B": "Timeouts, retries, and idempotency",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience patterns prevent cascading failures.",
      "incorrect": {
        "A": "Ignoring failures increases risk.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH13-0188",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security focus",
    "difficulty": "Easy",
    "question": "What security concern should always be reviewed for connectors?",
    "options": {
      "A": "Payload size",
      "B": "Credential scope and permissions",
      "C": "Transformation complexity",
      "D": "Flow naming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Over-permissioned credentials are a common risk.",
      "incorrect": {
        "A": "Payload size is operational.",
        "C": "Complexity affects maintainability.",
        "D": "Naming is cosmetic."
      }
    }
  },
  {
    "id": "CH13-0189",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "monitoring value",
    "difficulty": "Easy",
    "question": "Why is proactive monitoring essential for connectors?",
    "options": {
      "A": "To increase throughput",
      "B": "To detect issues before they impact consumers",
      "C": "To reduce transformation logic",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early detection prevents outages and SLA breaches.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Logic is unrelated.",
        "D": "Retries are still required."
      }
    }
  },
  {
    "id": "CH13-0190",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "ultimate principle",
    "difficulty": "Easy",
    "question": "What is the ultimate principle behind effective connector usage?",
    "options": {
      "A": "Direct system access",
      "B": "Loose coupling with strong governance",
      "C": "Minimal testing",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling and governance enable scalable, resilient integrations.",
      "incorrect": {
        "A": "Direct access increases fragility.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },

  {
    "id": "CH13-0191",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise readiness",
    "difficulty": "Easy",
    "question": "What best indicates enterprise readiness of connector-based solutions?",
    "options": {
      "A": "Ad-hoc implementations",
      "B": "Standardization, monitoring, and governance",
      "C": "Minimal documentation",
      "D": "Manual recovery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise readiness requires discipline and visibility.",
      "incorrect": {
        "A": "Ad-hoc designs do not scale.",
        "C": "Documentation is essential.",
        "D": "Manual recovery is risky."
      }
    }
  },
  {
    "id": "CH13-0192",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability reminder",
    "difficulty": "Easy",
    "question": "What practice most supports long-term scalability?",
    "options": {
      "A": "Stateful processing",
      "B": "Stateless connectors and externalized state",
      "C": "Hard-coded endpoints",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless designs scale horizontally.",
      "incorrect": {
        "A": "State limits scaling.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual retries do not scale."
      }
    }
  },
  {
    "id": "CH13-0193",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational maturity",
    "difficulty": "Easy",
    "question": "Which sign reflects operational maturity in connector usage?",
    "options": {
      "A": "Reactive firefighting",
      "B": "Defined SLIs, SLOs, and alerts",
      "C": "Minimal logging",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operational maturity requires measurable objectives.",
      "incorrect": {
        "A": "Firefighting indicates immaturity.",
        "C": "Logging is required.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0194",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture reminder",
    "difficulty": "Easy",
    "question": "Why is API-led architecture recommended with connector usage?",
    "options": {
      "A": "To remove security",
      "B": "To decouple consumers from backend systems",
      "C": "To eliminate transformations",
      "D": "To increase latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led layers isolate change and promote reuse.",
      "incorrect": {
        "A": "Security remains essential.",
        "C": "Transformations are still needed.",
        "D": "Latency is not increased by design."
      }
    }
  },
  {
    "id": "CH13-0195",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design discipline",
    "difficulty": "Easy",
    "question": "What design discipline most prevents integration sprawl?",
    "options": {
      "A": "Ad-hoc development",
      "B": "Standardization and reuse",
      "C": "Minimal governance",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standardization reduces duplication and chaos.",
      "incorrect": {
        "A": "Ad-hoc development causes sprawl.",
        "C": "Governance is required.",
        "D": "Hard-coding increases debt."
      }
    }
  },
  {
    "id": "CH13-0196",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "failure mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports resilient connector design?",
    "options": {
      "A": "Assume success",
      "B": "Design for failure",
      "C": "Ignore edge cases",
      "D": "Avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Failures are inevitable in distributed systems.",
      "incorrect": {
        "A": "Assumptions cause outages.",
        "C": "Edge cases matter.",
        "D": "Retries are often necessary."
      }
    }
  },
  {
    "id": "CH13-0197",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security maturity",
    "difficulty": "Easy",
    "question": "What best reflects mature connector security?",
    "options": {
      "A": "Shared credentials",
      "B": "Least privilege, rotation, and auditing",
      "C": "Disabled logging",
      "D": "Hard-coded secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mature security requires layered controls.",
      "incorrect": {
        "A": "Shared credentials increase risk.",
        "C": "Logging is essential.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0198",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational takeaway",
    "difficulty": "Easy",
    "question": "What operational takeaway applies most to connector-heavy systems?",
    "options": {
      "A": "Manual oversight",
      "B": "Automation and observability",
      "C": "Minimal documentation",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures reliability at scale.",
      "incorrect": {
        "A": "Manual processes do not scale.",
        "C": "Documentation is necessary.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0199",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam mindset",
    "difficulty": "Easy",
    "question": "What mindset best helps during certification exams on connectors?",
    "options": {
      "A": "Memorize defaults",
      "B": "Think like an architect and operator",
      "C": "Focus on UI clicks",
      "D": "Ignore edge cases"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test architectural judgment and operational awareness.",
      "incorrect": {
        "A": "Defaults are insufficient.",
        "C": "UI details are secondary.",
        "D": "Edge cases matter."
      }
    }
  },
  {
    "id": "CH13-0200",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "chapter closure",
    "difficulty": "Easy",
    "question": "What ultimately defines success in connector-based integrations?",
    "options": {
      "A": "Number of connectors used",
      "B": "Sound architecture, governance, and operations",
      "C": "Minimal testing",
      "D": "Direct system access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Success depends on discipline, not tooling quantity.",
      "incorrect": {
        "A": "Quantity increases complexity.",
        "C": "Testing is mandatory.",
        "D": "Direct access increases fragility."
      }
    }
  },
  {
    "id": "CH13-0201",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "compound fields",
    "difficulty": "Medium",
    "question": "What must be considered when mapping Salesforce compound fields using the connector?",
    "options": {
      "A": "They cannot be queried",
      "B": "They are composed of multiple atomic fields",
      "C": "They bypass validation rules",
      "D": "They require Bulk API only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compound fields like Address consist of multiple underlying fields.",
      "incorrect": {
        "A": "They can be queried.",
        "C": "Validation rules still apply.",
        "D": "They work with standard APIs as well."
      }
    }
  },
  {
    "id": "CH13-0202",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "null handling",
    "difficulty": "Medium",
    "question": "Why must null handling be explicit when updating Salesforce records?",
    "options": {
      "A": "Null values increase API usage",
      "B": "Nulls may unintentionally overwrite existing values",
      "C": "Nulls are rejected by Salesforce",
      "D": "Nulls disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sending null can clear existing values if not handled carefully.",
      "incorrect": {
        "A": "API usage is unaffected.",
        "C": "Nulls are allowed.",
        "D": "Triggers still execute."
      }
    }
  },
  {
    "id": "CH13-0203",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "timeout strategy",
    "difficulty": "Medium",
    "question": "Why should HTTP timeouts be configured conservatively?",
    "options": {
      "A": "To avoid authentication failures",
      "B": "To prevent thread exhaustion during slow responses",
      "C": "To increase payload size",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long timeouts can block threads and degrade system health.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Payload size is unaffected.",
        "D": "Retries remain configurable."
      }
    }
  },
  {
    "id": "CH13-0204",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "redirect handling",
    "difficulty": "Medium",
    "question": "What risk exists when automatically following HTTP redirects?",
    "options": {
      "A": "Reduced performance",
      "B": "Unexpected calls to untrusted endpoints",
      "C": "Schema validation errors",
      "D": "Payload truncation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blind redirects may lead to security or compliance risks.",
      "incorrect": {
        "A": "Performance impact is secondary.",
        "C": "Schemas are unaffected.",
        "D": "Payload integrity remains intact."
      }
    }
  },
  {
    "id": "CH13-0205",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "isolation levels",
    "difficulty": "Hard",
    "question": "Why must database isolation levels be chosen carefully in integrations?",
    "options": {
      "A": "They affect SQL syntax",
      "B": "They balance consistency and concurrency",
      "C": "They disable transactions",
      "D": "They improve network latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation levels control visibility of concurrent changes.",
      "incorrect": {
        "A": "Syntax is unaffected.",
        "C": "Transactions remain enabled.",
        "D": "Latency is unrelated."
      }
    }
  },
  {
    "id": "CH13-0206",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "schema drift",
    "difficulty": "Medium",
    "question": "What risk does schema drift introduce in database connector integrations?",
    "options": {
      "A": "Improved performance",
      "B": "Runtime failures and incorrect mappings",
      "C": "Reduced storage usage",
      "D": "Automatic backward compatibility"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schema changes can break existing integrations.",
      "incorrect": {
        "A": "Performance may degrade.",
        "C": "Storage usage is unaffected.",
        "D": "Backward compatibility is not guaranteed."
      }
    }
  },
  {
    "id": "CH13-0207",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "naming collisions",
    "difficulty": "Medium",
    "question": "How can file name collisions be avoided in shared directories?",
    "options": {
      "A": "Reduce polling frequency",
      "B": "Use unique identifiers in file names",
      "C": "Disable retries",
      "D": "Increase heap size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unique naming prevents overwrites and confusion.",
      "incorrect": {
        "A": "Polling frequency does not prevent collisions.",
        "C": "Retries are unrelated.",
        "D": "Heap size is irrelevant."
      }
    }
  },
  {
    "id": "CH13-0208",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "checksum validation",
    "difficulty": "Medium",
    "question": "Why is checksum validation useful after file transfer?",
    "options": {
      "A": "To reduce file size",
      "B": "To verify file integrity",
      "C": "To simplify encryption",
      "D": "To improve throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Checksums detect corruption during transfer.",
      "incorrect": {
        "A": "File size is unchanged.",
        "C": "Encryption is separate.",
        "D": "Throughput is unaffected."
      }
    }
  },
  {
    "id": "CH13-0209",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "dead letter queues",
    "difficulty": "Medium",
    "question": "What is the primary purpose of a dead letter queue?",
    "options": {
      "A": "Improve message throughput",
      "B": "Store messages that cannot be processed successfully",
      "C": "Guarantee ordering",
      "D": "Reduce message size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DLQs isolate poison messages for investigation.",
      "incorrect": {
        "A": "Throughput is not the goal.",
        "C": "Ordering is not guaranteed.",
        "D": "Message size is unchanged."
      }
    }
  },
  {
    "id": "CH13-0210",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "acknowledgement modes",
    "difficulty": "Hard",
    "question": "Why is manual acknowledgement sometimes preferred in MQ consumers?",
    "options": {
      "A": "To increase latency",
      "B": "To ensure messages are acknowledged only after successful processing",
      "C": "To disable retries",
      "D": "To simplify concurrency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Manual ack prevents message loss during processing failures.",
      "incorrect": {
        "A": "Latency is a tradeoff.",
        "C": "Retries may still be used.",
        "D": "Concurrency is unaffected."
      }
    }
  },

  {
    "id": "CH13-0211",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "directory scanning",
    "difficulty": "Medium",
    "question": "Why should directory scanning be optimized in FTP/SFTP integrations?",
    "options": {
      "A": "To improve encryption",
      "B": "To reduce unnecessary network overhead",
      "C": "To increase payload size",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive scanning increases load and latency.",
      "incorrect": {
        "A": "Encryption is unrelated.",
        "C": "Payload size is unchanged.",
        "D": "Retries are unaffected."
      }
    }
  },
  {
    "id": "CH13-0212",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "key rotation",
    "difficulty": "Medium",
    "question": "Why should SSH keys be rotated periodically in SFTP connectors?",
    "options": {
      "A": "To increase throughput",
      "B": "To reduce long-term credential exposure",
      "C": "To simplify file parsing",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation limits risk from compromised keys.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Parsing is unrelated.",
        "D": "Retries remain necessary."
      }
    }
  },
  {
    "id": "CH13-0213",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "bulk vs realtime",
    "difficulty": "Medium",
    "question": "What factor most strongly favors bulk connector processing over real-time?",
    "options": {
      "A": "Strict latency requirements",
      "B": "High data volume with relaxed timing",
      "C": "User interaction",
      "D": "Immediate consistency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk processing suits large volumes without real-time constraints.",
      "incorrect": {
        "A": "Strict latency favors real-time.",
        "C": "User interaction requires immediacy.",
        "D": "Immediate consistency is not guaranteed."
      }
    }
  },
  {
    "id": "CH13-0214",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "load leveling",
    "difficulty": "Medium",
    "question": "How does load leveling improve connector-based integrations?",
    "options": {
      "A": "By increasing payload size",
      "B": "By smoothing traffic spikes",
      "C": "By disabling retries",
      "D": "By reducing security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Load leveling prevents system overload during peaks.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Retries are still required.",
        "D": "Security is unaffected."
      }
    }
  },
  {
    "id": "CH13-0215",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "credential scope",
    "difficulty": "Medium",
    "question": "Why should connector credentials have narrowly scoped permissions?",
    "options": {
      "A": "To increase performance",
      "B": "To minimize impact if compromised",
      "C": "To simplify transformations",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege limits potential damage.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Transformations are unrelated.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH13-0216",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "secrets storage",
    "difficulty": "Easy",
    "question": "Where should connector secrets ideally be stored?",
    "options": {
      "A": "In source code",
      "B": "In a secure secrets manager",
      "C": "In documentation",
      "D": "In plain text configuration files"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secrets managers provide encryption and access control.",
      "incorrect": {
        "A": "Source code exposure is risky.",
        "C": "Docs are insecure.",
        "D": "Plain text is unsafe."
      }
    }
  },
  {
    "id": "CH13-0217",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "error categorization",
    "difficulty": "Medium",
    "question": "Why should connector errors be categorized?",
    "options": {
      "A": "To increase error volume",
      "B": "To enable targeted remediation strategies",
      "C": "To simplify logging",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Different errors require different handling approaches.",
      "incorrect": {
        "A": "Volume is not the goal.",
        "C": "Logging is complementary.",
        "D": "Retries depend on error type."
      }
    }
  },
  {
    "id": "CH13-0218",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "trend analysis",
    "difficulty": "Easy",
    "question": "What insight does long-term connector trend analysis provide?",
    "options": {
      "A": "Immediate fixes",
      "B": "Capacity planning and early warning signals",
      "C": "Schema validation",
      "D": "Authentication tuning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Trends reveal gradual degradation and growth needs.",
      "incorrect": {
        "A": "Trends are not instant fixes.",
        "C": "Validation is separate.",
        "D": "Authentication is unrelated."
      }
    }
  },

  {
    "id": "CH13-0219",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "documentation",
    "difficulty": "Easy",
    "question": "Why is clear documentation critical for connector usage?",
    "options": {
      "A": "To reduce API limits",
      "B": "To support maintainability and onboarding",
      "C": "To simplify transformations",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation enables faster understanding and safer changes.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Transformations are independent.",
        "D": "Retries remain necessary."
      }
    }
  },
  {
    "id": "CH13-0220",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "standardization",
    "difficulty": "Easy",
    "question": "What benefit does standardizing connector usage provide?",
    "options": {
      "A": "Increased coupling",
      "B": "Predictability and reduced operational risk",
      "C": "Disabled governance",
      "D": "Hard-coded behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards reduce variability and surprises.",
      "incorrect": {
        "A": "Coupling is not increased.",
        "C": "Governance is still required.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0221",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "incident response",
    "difficulty": "Easy",
    "question": "Why should connector incidents have predefined response procedures?",
    "options": {
      "A": "To increase deployment speed",
      "B": "To ensure consistent and fast recovery",
      "C": "To avoid monitoring",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Prepared responses reduce downtime and errors.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Monitoring is essential.",
        "D": "Transformations are unaffected."
      }
    }
  },
  {
    "id": "CH13-0222",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "capacity alerts",
    "difficulty": "Medium",
    "question": "Why should capacity-related alerts exist for connector systems?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent saturation before outages occur",
      "C": "To disable retries",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early alerts allow proactive scaling or throttling.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Retries remain important.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH13-0223",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "design clarity",
    "difficulty": "Easy",
    "question": "What ensures clarity in complex connector-based architectures?",
    "options": {
      "A": "Ad-hoc decisions",
      "B": "Clear layering and responsibility boundaries",
      "C": "Minimal documentation",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear boundaries reduce confusion and errors.",
      "incorrect": {
        "A": "Ad-hoc designs create chaos.",
        "C": "Documentation is essential.",
        "D": "Hard-coding increases debt."
      }
    }
  },
  {
    "id": "CH13-0224",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scalability principle",
    "difficulty": "Easy",
    "question": "Which principle most directly supports connector scalability?",
    "options": {
      "A": "Stateful flows",
      "B": "Stateless processing",
      "C": "Hard-coded endpoints",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless designs enable horizontal scaling.",
      "incorrect": {
        "A": "State limits scaling.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Manual retries do not scale."
      }
    }
  },
  {
    "id": "CH13-0225",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "reliability reminder",
    "difficulty": "Easy",
    "question": "What practice most improves connector reliability?",
    "options": {
      "A": "Ignoring transient failures",
      "B": "Timeouts, retries, and circuit breakers",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience patterns prevent cascading failures.",
      "incorrect": {
        "A": "Ignoring failures increases risk.",
        "C": "Hard-coding increases fragility.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH13-0226",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security focus",
    "difficulty": "Easy",
    "question": "Which factor most often causes connector security incidents?",
    "options": {
      "A": "Large payloads",
      "B": "Over-privileged credentials",
      "C": "Slow responses",
      "D": "Complex transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive permissions increase attack impact.",
      "incorrect": {
        "A": "Payload size is operational.",
        "C": "Latency is unrelated.",
        "D": "Complexity affects maintainability."
      }
    }
  },
  {
    "id": "CH13-0227",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational insight",
    "difficulty": "Easy",
    "question": "What operational insight applies most to connector-heavy environments?",
    "options": {
      "A": "Manual control scales well",
      "B": "Automation and observability are essential",
      "C": "Minimal monitoring is sufficient",
      "D": "Hard-coded logic simplifies operations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures reliability at scale.",
      "incorrect": {
        "A": "Manual control does not scale.",
        "C": "Monitoring must be proactive.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0228",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture takeaway",
    "difficulty": "Easy",
    "question": "Why does API-led architecture complement connector usage?",
    "options": {
      "A": "It removes security enforcement",
      "B": "It decouples consumers from backend volatility",
      "C": "It eliminates transformations",
      "D": "It increases latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layering isolates change and improves reuse.",
      "incorrect": {
        "A": "Security remains essential.",
        "C": "Transformations are still required.",
        "D": "Latency is not inherently increased."
      }
    }
  },
  {
    "id": "CH13-0229",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam readiness",
    "difficulty": "Easy",
    "question": "What best helps avoid traps in connector-based exam questions?",
    "options": {
      "A": "Memorizing defaults",
      "B": "Evaluating non-functional requirements carefully",
      "C": "Ignoring edge cases",
      "D": "Focusing on UI steps"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize tradeoffs and constraints.",
      "incorrect": {
        "A": "Defaults are insufficient.",
        "C": "Edge cases matter.",
        "D": "UI is secondary."
      }
    }
  },
  {
    "id": "CH13-0230",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "chapter principle",
    "difficulty": "Easy",
    "question": "What principle best summarizes connector usage?",
    "options": {
      "A": "Use connectors directly everywhere",
      "B": "Use connectors within governed, decoupled architectures",
      "C": "Avoid abstraction layers",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance and decoupling enable long-term success.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is mandatory."
      }
    }
  },

  {
    "id": "CH13-0231",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise maturity",
    "difficulty": "Easy",
    "question": "What indicates mature enterprise connector adoption?",
    "options": {
      "A": "Point-to-point usage",
      "B": "Standardization, monitoring, and lifecycle management",
      "C": "Minimal documentation",
      "D": "Manual intervention"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity requires consistency and visibility.",
      "incorrect": {
        "A": "Point-to-point is fragile.",
        "C": "Documentation is essential.",
        "D": "Manual steps do not scale."
      }
    }
  },
  {
    "id": "CH13-0232",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling mindset",
    "difficulty": "Easy",
    "question": "Which mindset best supports scaling connector systems?",
    "options": {
      "A": "Assume success",
      "B": "Design for failure and growth",
      "C": "Ignore monitoring",
      "D": "Hard-code assumptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Designing for failure prevents outages as scale grows.",
      "incorrect": {
        "A": "Assumptions cause outages.",
        "C": "Monitoring is essential.",
        "D": "Hard-coding limits adaptability."
      }
    }
  },
  {
    "id": "CH13-0233",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational resilience",
    "difficulty": "Easy",
    "question": "What most directly improves operational resilience?",
    "options": {
      "A": "Manual recovery",
      "B": "Automation with alerts and runbooks",
      "C": "Minimal testing",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistent and fast recovery.",
      "incorrect": {
        "A": "Manual recovery is slow.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0234",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security posture",
    "difficulty": "Easy",
    "question": "What best defines strong connector security posture?",
    "options": {
      "A": "Shared credentials",
      "B": "Least privilege, rotation, and monitoring",
      "C": "Disabled logging",
      "D": "Hard-coded secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered security controls reduce risk.",
      "incorrect": {
        "A": "Shared credentials increase risk.",
        "C": "Logging is essential.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0235",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architectural clarity",
    "difficulty": "Easy",
    "question": "What ensures architectural clarity in connector-heavy systems?",
    "options": {
      "A": "Ad-hoc development",
      "B": "Clear ownership and layered responsibilities",
      "C": "Minimal documentation",
      "D": "Hard-coded flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership reduces confusion and errors.",
      "incorrect": {
        "A": "Ad-hoc development causes chaos.",
        "C": "Documentation is essential.",
        "D": "Hard-coding increases debt."
      }
    }
  },
  {
    "id": "CH13-0236",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam advice",
    "difficulty": "Easy",
    "question": "What is the best advice for answering connector-related exam questions?",
    "options": {
      "A": "Pick the fastest solution",
      "B": "Balance reliability, security, and scalability",
      "C": "Ignore non-functional requirements",
      "D": "Focus on syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test balanced architectural judgment.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Non-functional requirements matter.",
        "D": "Syntax is secondary."
      }
    }
  },
  {
    "id": "CH13-0237",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "final lesson",
    "difficulty": "Easy",
    "question": "What is the most important lesson from connector use cases?",
    "options": {
      "A": "Connectors replace APIs",
      "B": "Connectors succeed within strong architecture and governance",
      "C": "Connectors eliminate complexity",
      "D": "Connectors remove the need for testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Architecture and governance determine success.",
      "incorrect": {
        "A": "APIs remain essential.",
        "C": "Complexity still exists.",
        "D": "Testing is mandatory."
      }
    }
  },
  {
    "id": "CH13-0238",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise takeaway",
    "difficulty": "Easy",
    "question": "What enterprise takeaway applies universally to connector usage?",
    "options": {
      "A": "More connectors equals better design",
      "B": "Governance and discipline outweigh tooling",
      "C": "Avoid abstraction",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Discipline ensures long-term stability.",
      "incorrect": {
        "A": "More tools increase complexity.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is required."
      }
    }
  },
  {
    "id": "CH13-0239",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational principle",
    "difficulty": "Easy",
    "question": "What operational principle best applies to connector-heavy platforms?",
    "options": {
      "A": "Manual oversight",
      "B": "Automate everything possible",
      "C": "Minimal monitoring",
      "D": "Hard-coded recovery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation is essential at scale.",
      "incorrect": {
        "A": "Manual oversight does not scale.",
        "C": "Monitoring must be proactive.",
        "D": "Hard-coded recovery is fragile."
      }
    }
  },
  {
    "id": "CH13-0240",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "chapter summary",
    "difficulty": "Easy",
    "question": "What best summarizes Chapter 13 connector usage guidance?",
    "options": {
      "A": "Direct usage without abstraction",
      "B": "Connector usage governed by architecture, security, and operations",
      "C": "Minimal testing and monitoring",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective connector use requires holistic discipline.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Testing and monitoring are mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0241",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "field level security",
    "difficulty": "Medium",
    "question": "What happens if a Mule integration attempts to update a Salesforce field without field-level permission?",
    "options": {
      "A": "The field is silently ignored",
      "B": "The operation fails with a permission error",
      "C": "The value is stored temporarily",
      "D": "The update succeeds but is hidden"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Salesforce enforces field-level security during API operations.",
      "incorrect": {
        "A": "Salesforce does not silently ignore unauthorized updates.",
        "C": "Temporary storage does not occur.",
        "D": "Unauthorized updates never succeed."
      }
    }
  },
  {
    "id": "CH13-0242",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "trigger side effects",
    "difficulty": "Hard",
    "question": "Why must Salesforce triggers be considered when designing connector-based updates?",
    "options": {
      "A": "They increase payload size",
      "B": "They may introduce additional processing and side effects",
      "C": "They disable API access",
      "D": "They bypass validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Triggers can execute logic that affects performance and data behavior.",
      "incorrect": {
        "A": "Payload size is unchanged.",
        "C": "Triggers do not disable APIs.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH13-0243",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "request headers",
    "difficulty": "Easy",
    "question": "Why should required HTTP headers be explicitly set in connector requests?",
    "options": {
      "A": "To reduce latency",
      "B": "To ensure predictable request behavior",
      "C": "To avoid transformations",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit headers avoid dependency on defaults and ambiguity.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Transformations remain required.",
        "D": "Retries are independent."
      }
    }
  },
  {
    "id": "CH13-0244",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "rate limiting",
    "difficulty": "Medium",
    "question": "Why should HTTP connector calls respect downstream rate limits?",
    "options": {
      "A": "To increase throughput",
      "B": "To avoid throttling or temporary bans",
      "C": "To simplify payload mapping",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exceeding rate limits can lead to service denial.",
      "incorrect": {
        "A": "Ignoring limits reduces throughput.",
        "C": "Mapping is unrelated.",
        "D": "Retries may worsen throttling."
      }
    }
  },
  {
    "id": "CH13-0245",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "index usage",
    "difficulty": "Medium",
    "question": "How does proper index usage affect database connector performance?",
    "options": {
      "A": "It increases payload size",
      "B": "It significantly reduces query execution time",
      "C": "It disables transactions",
      "D": "It increases write contention"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Indexes optimize data retrieval paths.",
      "incorrect": {
        "A": "Payload size is unchanged.",
        "C": "Transactions remain enabled.",
        "D": "Indexes often reduce contention."
      }
    }
  },
  {
    "id": "CH13-0246",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "long queries",
    "difficulty": "Hard",
    "question": "Why are long-running queries dangerous in integration scenarios?",
    "options": {
      "A": "They improve consistency",
      "B": "They hold locks and consume resources",
      "C": "They reduce network traffic",
      "D": "They simplify retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Extended queries block resources and impact concurrency.",
      "incorrect": {
        "A": "Consistency is not improved.",
        "C": "Traffic is not reduced.",
        "D": "Retries become more complex."
      }
    }
  },
  {
    "id": "CH13-0247",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "directory cleanup",
    "difficulty": "Easy",
    "question": "Why should processed files be periodically cleaned from input directories?",
    "options": {
      "A": "To increase throughput",
      "B": "To reduce clutter and scanning overhead",
      "C": "To simplify encryption",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Large directories slow scanning and increase operational risk.",
      "incorrect": {
        "A": "Throughput is indirectly affected.",
        "C": "Encryption is unrelated.",
        "D": "Retries are unaffected."
      }
    }
  },
  {
    "id": "CH13-0248",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "file locks",
    "difficulty": "Medium",
    "question": "What problem do file locks help prevent in file-based integrations?",
    "options": {
      "A": "Duplicate authentication",
      "B": "Concurrent access to the same file",
      "C": "Schema mismatch",
      "D": "Payload corruption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Locks ensure only one process handles a file at a time.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Schemas are independent.",
        "D": "Corruption is prevented indirectly."
      }
    }
  },
  {
    "id": "CH13-0249",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "poison messages",
    "difficulty": "Medium",
    "question": "What is a poison message in a messaging system?",
    "options": {
      "A": "A message with large payload",
      "B": "A message that repeatedly fails processing",
      "C": "A message without headers",
      "D": "A delayed message"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Poison messages continuously fail and block processing.",
      "incorrect": {
        "A": "Payload size alone is not the issue.",
        "C": "Headers are optional.",
        "D": "Delays are unrelated."
      }
    }
  },
  {
    "id": "CH13-0250",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "message ttl",
    "difficulty": "Medium",
    "question": "What is the purpose of message TTL in MQ systems?",
    "options": {
      "A": "To increase delivery guarantees",
      "B": "To discard messages after a defined time",
      "C": "To enforce ordering",
      "D": "To increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "TTL prevents stale messages from being processed.",
      "incorrect": {
        "A": "Guarantees are unaffected.",
        "C": "Ordering is independent.",
        "D": "Throughput is unchanged."
      }
    }
  },

  {
    "id": "CH13-0251",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "idle connections",
    "difficulty": "Medium",
    "question": "Why should idle FTP/SFTP connections be closed or recycled?",
    "options": {
      "A": "To reduce file size",
      "B": "To avoid server-side connection limits",
      "C": "To simplify file parsing",
      "D": "To increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idle connections may be dropped or exhaust limits.",
      "incorrect": {
        "A": "File size is irrelevant.",
        "C": "Parsing is unrelated.",
        "D": "Throughput may decrease."
      }
    }
  },
  {
    "id": "CH13-0252",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "FTP/SFTP Connector",
    "subtopic": "directory permissions",
    "difficulty": "Easy",
    "question": "What issue occurs if the connector lacks write permission on an archive directory?",
    "options": {
      "A": "Files are encrypted",
      "B": "Post-processing file moves fail",
      "C": "Polling stops completely",
      "D": "Authentication fails"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Archival or move operations require write permission.",
      "incorrect": {
        "A": "Encryption is unrelated.",
        "C": "Polling continues.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH13-0253",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "fan-out pattern",
    "difficulty": "Medium",
    "question": "What risk exists in fan-out connector patterns?",
    "options": {
      "A": "Reduced scalability",
      "B": "Partial downstream failure handling",
      "C": "Lack of transformation support",
      "D": "Schema validation issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Some targets may fail while others succeed.",
      "incorrect": {
        "A": "Fan-out improves scalability.",
        "C": "Transformations are supported.",
        "D": "Schemas are independent."
      }
    }
  },
  {
    "id": "CH13-0254",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "aggregation timeout",
    "difficulty": "Hard",
    "question": "Why must aggregation patterns define timeouts?",
    "options": {
      "A": "To increase latency",
      "B": "To avoid indefinite waiting for missing responses",
      "C": "To disable retries",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without timeouts, flows may stall indefinitely.",
      "incorrect": {
        "A": "Latency should be controlled.",
        "C": "Retries remain necessary.",
        "D": "Transformations are unrelated."
      }
    }
  },
  {
    "id": "CH13-0255",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "network segmentation",
    "difficulty": "Medium",
    "question": "How does network segmentation improve connector security?",
    "options": {
      "A": "By increasing payload size",
      "B": "By limiting exposure between systems",
      "C": "By disabling encryption",
      "D": "By simplifying retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Segmentation reduces attack surface.",
      "incorrect": {
        "A": "Payload size is unaffected.",
        "C": "Encryption remains required.",
        "D": "Retries are unrelated."
      }
    }
  },
  {
    "id": "CH13-0256",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "outbound firewall rules",
    "difficulty": "Medium",
    "question": "Why should outbound firewall rules be restrictive for connectors?",
    "options": {
      "A": "To increase latency",
      "B": "To prevent unauthorized external communication",
      "C": "To simplify routing",
      "D": "To reduce monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restrictive rules limit data exfiltration risk.",
      "incorrect": {
        "A": "Latency is a side effect.",
        "C": "Routing is unaffected.",
        "D": "Monitoring remains required."
      }
    }
  },
  {
    "id": "CH13-0257",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "baseline comparison",
    "difficulty": "Easy",
    "question": "Why should connector metrics be compared against baselines?",
    "options": {
      "A": "To increase throughput",
      "B": "To detect abnormal behavior early",
      "C": "To simplify logging",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Baselines help identify deviations from normal operation.",
      "incorrect": {
        "A": "Throughput changes are secondary.",
        "C": "Logging is unaffected.",
        "D": "Retries remain necessary."
      }
    }
  },
  {
    "id": "CH13-0258",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "dependency visibility",
    "difficulty": "Easy",
    "question": "Why is visibility into downstream dependencies important?",
    "options": {
      "A": "To increase payload size",
      "B": "To identify root causes of failures",
      "C": "To avoid transformations",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dependency insight accelerates troubleshooting.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Transformations remain required.",
        "D": "Retries are still used."
      }
    }
  },

  {
    "id": "CH13-0259",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "configuration drift",
    "difficulty": "Easy",
    "question": "What is configuration drift in connector deployments?",
    "options": {
      "A": "Improved performance",
      "B": "Unintended differences between environments",
      "C": "Schema validation errors",
      "D": "Authentication failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Drift causes unpredictable behavior across environments.",
      "incorrect": {
        "A": "Performance is not improved.",
        "C": "Schemas may still match.",
        "D": "Authentication may still succeed."
      }
    }
  },
  {
    "id": "CH13-0260",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "centralized config",
    "difficulty": "Easy",
    "question": "Why should connector configurations be centrally managed?",
    "options": {
      "A": "To increase coupling",
      "B": "To ensure consistency and easier governance",
      "C": "To disable monitoring",
      "D": "To hard-code credentials"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Central management reduces errors and improves control.",
      "incorrect": {
        "A": "Coupling is not increased.",
        "C": "Monitoring remains required.",
        "D": "Hard-coding is insecure."
      }
    }
  },

  {
    "id": "CH13-0261",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "runbook testing",
    "difficulty": "Easy",
    "question": "Why should connector runbooks be tested periodically?",
    "options": {
      "A": "To increase deployment speed",
      "B": "To ensure procedures work during real incidents",
      "C": "To reduce transformations",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Untested runbooks may fail during outages.",
      "incorrect": {
        "A": "Speed is secondary.",
        "C": "Transformations are unrelated.",
        "D": "Retries are still needed."
      }
    }
  },
  {
    "id": "CH13-0262",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Operational Excellence",
    "subtopic": "capacity buffers",
    "difficulty": "Medium",
    "question": "Why should capacity buffers exist in connector platforms?",
    "options": {
      "A": "To reduce cost",
      "B": "To handle unexpected traffic spikes",
      "C": "To simplify authentication",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Buffers prevent saturation during surges.",
      "incorrect": {
        "A": "Buffers may increase cost.",
        "C": "Authentication is unaffected.",
        "D": "Monitoring remains critical."
      }
    }
  },
  {
    "id": "CH13-0263",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "integration hygiene",
    "difficulty": "Easy",
    "question": "What practice best represents good integration hygiene?",
    "options": {
      "A": "Hard-coded logic",
      "B": "Regular review and cleanup of integrations",
      "C": "Minimal documentation",
      "D": "Ad-hoc fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Regular reviews reduce technical debt.",
      "incorrect": {
        "A": "Hard-coding increases debt.",
        "C": "Documentation is essential.",
        "D": "Ad-hoc fixes are risky."
      }
    }
  },
  {
    "id": "CH13-0264",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling takeaway",
    "difficulty": "Easy",
    "question": "What most reliably supports scaling connector ecosystems?",
    "options": {
      "A": "Manual oversight",
      "B": "Automation, standards, and monitoring",
      "C": "Minimal governance",
      "D": "Hard-coded assumptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scale requires discipline and automation.",
      "incorrect": {
        "A": "Manual processes do not scale.",
        "C": "Governance is required.",
        "D": "Hard-coding limits growth."
      }
    }
  },
  {
    "id": "CH13-0265",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security takeaway",
    "difficulty": "Easy",
    "question": "What security takeaway applies to all connector designs?",
    "options": {
      "A": "Trust internal systems implicitly",
      "B": "Apply least privilege everywhere",
      "C": "Disable logging",
      "D": "Hard-code secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege minimizes risk across integrations.",
      "incorrect": {
        "A": "Implicit trust is dangerous.",
        "C": "Logging is essential.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0266",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational lesson",
    "difficulty": "Easy",
    "question": "What operational lesson is most critical for connector-heavy systems?",
    "options": {
      "A": "Manual intervention",
      "B": "Proactive monitoring and automation",
      "C": "Minimal testing",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proactive operations prevent outages.",
      "incorrect": {
        "A": "Manual intervention does not scale.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0267",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam readiness",
    "difficulty": "Easy",
    "question": "What should guide choices in connector-based exam scenarios?",
    "options": {
      "A": "Fastest implementation",
      "B": "Balanced tradeoffs across reliability, security, and scale",
      "C": "Minimal configuration",
      "D": "Ignoring non-functional needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test architectural judgment.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Configuration matters.",
        "D": "Non-functional needs are critical."
      }
    }
  },
  {
    "id": "CH13-0268",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "ultimate principle",
    "difficulty": "Easy",
    "question": "What ultimate principle governs effective connector usage?",
    "options": {
      "A": "Direct system access",
      "B": "Loose coupling with strong governance",
      "C": "Minimal monitoring",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling and governance ensure longevity.",
      "incorrect": {
        "A": "Direct access increases fragility.",
        "C": "Monitoring is essential.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "CH13-0269",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise view",
    "difficulty": "Easy",
    "question": "From an enterprise perspective, connectors should be treated as what?",
    "options": {
      "A": "Temporary shortcuts",
      "B": "Long-lived managed assets",
      "C": "Disposable utilities",
      "D": "Unmonitored scripts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors require lifecycle management.",
      "incorrect": {
        "A": "Shortcuts increase risk.",
        "C": "Disposability causes outages.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0270",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "chapter closure",
    "difficulty": "Easy",
    "question": "What best closes Chapter 13 on connectors and use cases?",
    "options": {
      "A": "Use connectors everywhere directly",
      "B": "Success depends on disciplined architecture and operations",
      "C": "Avoid abstraction layers",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Architecture and discipline determine success.",
      "incorrect": {
        "A": "Direct usage increases coupling.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0271",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "api versioning",
    "difficulty": "Medium",
    "question": "Why should Salesforce API versions be explicitly controlled in connector configurations?",
    "options": {
      "A": "To increase throughput",
      "B": "To avoid unexpected behavior after platform upgrades",
      "C": "To simplify transformations",
      "D": "To disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Uncontrolled API version changes may alter behavior or responses.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Transformations are independent.",
        "D": "Triggers are still executed."
      }
    }
  },
  {
    "id": "CH13-0272",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Salesforce Connector",
    "subtopic": "upsert behavior",
    "difficulty": "Medium",
    "question": "What determines whether an upsert operation inserts or updates a Salesforce record?",
    "options": {
      "A": "Record creation date",
      "B": "Presence of a matching external ID",
      "C": "User profile",
      "D": "Object sharing rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Upsert relies on matching external IDs or record IDs.",
      "incorrect": {
        "A": "Dates are irrelevant.",
        "C": "Profiles do not decide upsert logic.",
        "D": "Sharing rules do not affect upsert choice."
      }
    }
  },
  {
    "id": "CH13-0273",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "idempotent methods",
    "difficulty": "Easy",
    "question": "Which HTTP method is inherently idempotent by definition?",
    "options": {
      "A": "POST",
      "B": "GET",
      "C": "PATCH",
      "D": "CONNECT"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "GET requests do not change server state when repeated.",
      "incorrect": {
        "A": "POST is not idempotent.",
        "C": "PATCH may change state repeatedly.",
        "D": "CONNECT is for tunneling."
      }
    }
  },
  {
    "id": "CH13-0274",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "HTTP Connector",
    "subtopic": "retry storms",
    "difficulty": "Hard",
    "question": "What risk does aggressive retry configuration introduce?",
    "options": {
      "A": "Improved reliability",
      "B": "Retry storms overwhelming downstream systems",
      "C": "Reduced latency",
      "D": "Improved idempotency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive retries can amplify failures instead of resolving them.",
      "incorrect": {
        "A": "Reliability may decrease.",
        "C": "Latency usually increases.",
        "D": "Retries do not create idempotency."
      }
    }
  },
  {
    "id": "CH13-0275",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "connection pooling",
    "difficulty": "Medium",
    "question": "What is the primary benefit of database connection pooling?",
    "options": {
      "A": "Reduced query complexity",
      "B": "Lower overhead from repeated connection creation",
      "C": "Automatic schema migration",
      "D": "Improved data consistency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pooling reuses connections and reduces setup cost.",
      "incorrect": {
        "A": "Query logic is unchanged.",
        "C": "Schema changes are manual.",
        "D": "Consistency is unrelated."
      }
    }
  },
  {
    "id": "CH13-0276",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Database Connector",
    "subtopic": "batch commits",
    "difficulty": "Medium",
    "question": "Why are batch commits preferred for high-volume database inserts?",
    "options": {
      "A": "They increase locking",
      "B": "They reduce transaction overhead",
      "C": "They eliminate rollbacks",
      "D": "They enforce ordering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batching reduces commit cost and improves throughput.",
      "incorrect": {
        "A": "Locking is not increased.",
        "C": "Rollbacks are still possible.",
        "D": "Ordering is not guaranteed."
      }
    }
  },
  {
    "id": "CH13-0277",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "partial files",
    "difficulty": "Medium",
    "question": "Why should partially written files be excluded from processing?",
    "options": {
      "A": "They reduce throughput",
      "B": "They may contain incomplete or corrupt data",
      "C": "They break encryption",
      "D": "They disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Incomplete files can lead to incorrect processing.",
      "incorrect": {
        "A": "Throughput impact is secondary.",
        "C": "Encryption is unrelated.",
        "D": "Retries remain unaffected."
      }
    }
  },
  {
    "id": "CH13-0278",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "File Connector",
    "subtopic": "temporary extensions",
    "difficulty": "Easy",
    "question": "Why do producers often use temporary file extensions during uploads?",
    "options": {
      "A": "To reduce file size",
      "B": "To signal completion only after full write",
      "C": "To simplify parsing",
      "D": "To increase security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Temporary extensions prevent premature consumption.",
      "incorrect": {
        "A": "File size is unchanged.",
        "C": "Parsing logic is separate.",
        "D": "Security is not improved."
      }
    }
  },
  {
    "id": "CH13-0279",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "consumer scaling",
    "difficulty": "Medium",
    "question": "What is the safest way to scale MQ consumers?",
    "options": {
      "A": "Increase message size",
      "B": "Add consumers while ensuring idempotent processing",
      "C": "Disable acknowledgements",
      "D": "Use shared mutable state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotency ensures safe parallel consumption.",
      "incorrect": {
        "A": "Message size does not help scaling.",
        "C": "Acknowledgements are required.",
        "D": "Shared state reduces safety."
      }
    }
  },
  {
    "id": "CH13-0280",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "MQ Connector",
    "subtopic": "ordering guarantees",
    "difficulty": "Medium",
    "question": "Why should message ordering not be assumed in distributed MQ systems?",
    "options": {
      "A": "Ordering is always guaranteed",
      "B": "Parallel consumers may process messages out of order",
      "C": "Payload size affects order",
      "D": "Acknowledgements enforce order"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Concurrency breaks strict ordering guarantees.",
      "incorrect": {
        "A": "Ordering is not guaranteed.",
        "C": "Payload size is irrelevant.",
        "D": "Acknowledgements do not enforce order."
      }
    }
  },

  {
    "id": "CH13-0281",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "backpressure",
    "difficulty": "Hard",
    "question": "What is the purpose of backpressure in connector-based systems?",
    "options": {
      "A": "Increase throughput indefinitely",
      "B": "Protect downstream systems from overload",
      "C": "Disable retries",
      "D": "Increase payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backpressure slows producers to match consumer capacity.",
      "incorrect": {
        "A": "Unlimited throughput is unsafe.",
        "C": "Retries are unrelated.",
        "D": "Payload size is unchanged."
      }
    }
  },
  {
    "id": "CH13-0282",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Use Case Design",
    "subtopic": "circuit breaker",
    "difficulty": "Hard",
    "question": "Why are circuit breakers critical in connector-heavy architectures?",
    "options": {
      "A": "They improve schema validation",
      "B": "They prevent cascading failures",
      "C": "They increase throughput",
      "D": "They eliminate retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers isolate failing dependencies.",
      "incorrect": {
        "A": "Validation is unrelated.",
        "C": "Throughput may decrease temporarily.",
        "D": "Retries may still occur."
      }
    }
  },
  {
    "id": "CH13-0283",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "token leakage",
    "difficulty": "Medium",
    "question": "What practice best prevents access token leakage in connectors?",
    "options": {
      "A": "Logging full headers",
      "B": "Masking and secure storage of tokens",
      "C": "Hard-coding tokens",
      "D": "Disabling monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Masking and secure storage prevent accidental exposure.",
      "incorrect": {
        "A": "Logging headers leaks secrets.",
        "C": "Hard-coding is insecure.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0284",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Security",
    "subtopic": "zero trust",
    "difficulty": "Medium",
    "question": "How does zero-trust thinking apply to connector design?",
    "options": {
      "A": "Trust internal systems fully",
      "B": "Authenticate and authorize every interaction",
      "C": "Disable encryption",
      "D": "Avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Zero trust assumes no implicit trust.",
      "incorrect": {
        "A": "Implicit trust is risky.",
        "C": "Encryption is mandatory.",
        "D": "Monitoring remains critical."
      }
    }
  },
  {
    "id": "CH13-0285",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "saturation signals",
    "difficulty": "Medium",
    "question": "Which metric best indicates connector saturation?",
    "options": {
      "A": "Payload size",
      "B": "Queue depth or thread utilization",
      "C": "Field count",
      "D": "Schema version"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Growing queues or thread exhaustion signal overload.",
      "incorrect": {
        "A": "Payload size alone is insufficient.",
        "C": "Field count is unrelated.",
        "D": "Schema version is irrelevant."
      }
    }
  },
  {
    "id": "CH13-0286",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Monitoring",
    "subtopic": "alert fatigue",
    "difficulty": "Medium",
    "question": "What causes alert fatigue in connector monitoring?",
    "options": {
      "A": "Too few alerts",
      "B": "Poorly tuned thresholds and excessive noise",
      "C": "Lack of dashboards",
      "D": "Small payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Noisy alerts reduce operator responsiveness.",
      "incorrect": {
        "A": "Too few alerts is not fatigue.",
        "C": "Dashboards are complementary.",
        "D": "Payload size is irrelevant."
      }
    }
  },

  {
    "id": "CH13-0287",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "version control",
    "difficulty": "Easy",
    "question": "Why should connector configurations be version-controlled?",
    "options": {
      "A": "To reduce runtime cost",
      "B": "To track changes and enable rollback",
      "C": "To disable monitoring",
      "D": "To hard-code values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Version control ensures traceability and recovery.",
      "incorrect": {
        "A": "Runtime cost is unaffected.",
        "C": "Monitoring remains required.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0288",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Best Practices",
    "subtopic": "environment parity",
    "difficulty": "Easy",
    "question": "Why is environment parity important for connector deployments?",
    "options": {
      "A": "To increase coupling",
      "B": "To reduce surprises during production rollout",
      "C": "To disable retries",
      "D": "To simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parity ensures behavior consistency across environments.",
      "incorrect": {
        "A": "Coupling is not increased.",
        "C": "Retries remain necessary.",
        "D": "Transformations are independent."
      }
    }
  },
  {
    "id": "CH13-0289",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architecture maturity",
    "difficulty": "Easy",
    "question": "What best signals mature connector architecture?",
    "options": {
      "A": "Point-to-point integrations",
      "B": "Governed, reusable, and observable integrations",
      "C": "Minimal documentation",
      "D": "Manual recovery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity requires governance and observability.",
      "incorrect": {
        "A": "Point-to-point does not scale.",
        "C": "Documentation is essential.",
        "D": "Manual recovery is risky."
      }
    }
  },
  {
    "id": "CH13-0290",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling lesson",
    "difficulty": "Easy",
    "question": "What lesson applies when scaling connector ecosystems?",
    "options": {
      "A": "Speed over safety",
      "B": "Design for growth and failure",
      "C": "Ignore monitoring",
      "D": "Hard-code assumptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scalable systems anticipate change and failure.",
      "incorrect": {
        "A": "Safety is critical.",
        "C": "Monitoring is mandatory.",
        "D": "Hard-coding limits growth."
      }
    }
  },
  {
    "id": "CH13-0291",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational excellence",
    "difficulty": "Easy",
    "question": "What defines operational excellence in connector platforms?",
    "options": {
      "A": "Manual oversight",
      "B": "Automation, monitoring, and disciplined processes",
      "C": "Minimal testing",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excellence requires automation and visibility.",
      "incorrect": {
        "A": "Manual oversight does not scale.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0292",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "security mindset",
    "difficulty": "Easy",
    "question": "What security mindset should guide connector development?",
    "options": {
      "A": "Implicit trust",
      "B": "Least privilege and defense in depth",
      "C": "Disable logging",
      "D": "Hard-code secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered security minimizes risk.",
      "incorrect": {
        "A": "Implicit trust is dangerous.",
        "C": "Logging is essential.",
        "D": "Hard-coding is unsafe."
      }
    }
  },
  {
    "id": "CH13-0293",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "exam strategy",
    "difficulty": "Easy",
    "question": "What strategy best answers connector-related exam questions?",
    "options": {
      "A": "Choose the fastest option",
      "B": "Balance reliability, security, and scalability",
      "C": "Ignore non-functional requirements",
      "D": "Focus only on syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test architectural judgment.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Non-functional needs matter.",
        "D": "Syntax is secondary."
      }
    }
  },
  {
    "id": "CH13-0294",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "integration principle",
    "difficulty": "Easy",
    "question": "What principle underpins all successful connector integrations?",
    "options": {
      "A": "Direct access",
      "B": "Loose coupling with governance",
      "C": "Minimal monitoring",
      "D": "Hard-coded flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling ensures resilience and reuse.",
      "incorrect": {
        "A": "Direct access increases fragility.",
        "C": "Monitoring is mandatory.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "CH13-0295",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "enterprise takeaway",
    "difficulty": "Easy",
    "question": "How should enterprises view connector investments?",
    "options": {
      "A": "Temporary hacks",
      "B": "Strategic, long-lived assets",
      "C": "Disposable utilities",
      "D": "Unmonitored scripts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connectors require lifecycle management.",
      "incorrect": {
        "A": "Hacks increase risk.",
        "C": "Disposability causes outages.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH13-0296",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "resilience focus",
    "difficulty": "Easy",
    "question": "What most improves resilience in connector systems?",
    "options": {
      "A": "Ignoring failures",
      "B": "Timeouts, retries, and circuit breakers",
      "C": "Hard-coded logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience patterns prevent cascading failures.",
      "incorrect": {
        "A": "Ignoring failures is risky.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH13-0297",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "operational clarity",
    "difficulty": "Easy",
    "question": "What ensures operational clarity in connector-heavy environments?",
    "options": {
      "A": "Ad-hoc fixes",
      "B": "Clear ownership and documented procedures",
      "C": "Minimal documentation",
      "D": "Hard-coded assumptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership reduces confusion.",
      "incorrect": {
        "A": "Ad-hoc fixes increase risk.",
        "C": "Documentation is essential.",
        "D": "Hard-coding limits adaptability."
      }
    }
  },
  {
    "id": "CH13-0298",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "scaling readiness",
    "difficulty": "Easy",
    "question": "What best indicates readiness to scale connector systems?",
    "options": {
      "A": "Manual intervention",
      "B": "Automation, monitoring, and capacity planning",
      "C": "Minimal testing",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scaling requires discipline and foresight.",
      "incorrect": {
        "A": "Manual steps do not scale.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  },
  {
    "id": "CH13-0299",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "architectural summary",
    "difficulty": "Easy",
    "question": "What architectural summary best fits connector usage?",
    "options": {
      "A": "Direct, unmanaged access",
      "B": "Managed integration points within governed architecture",
      "C": "Minimal abstraction",
      "D": "Disabled monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governed connectors ensure stability and reuse.",
      "incorrect": {
        "A": "Direct access increases fragility.",
        "C": "Abstraction improves resilience.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH13-0300",
    "chapter": 13,
    "chapterTitle": "Connectors and Use Cases",
    "topic": "Final Review",
    "subtopic": "chapter completion",
    "difficulty": "Easy",
    "question": "What ultimately determines success of connector-based solutions?",
    "options": {
      "A": "Number of connectors",
      "B": "Architecture discipline, security, and operations",
      "C": "Minimal testing",
      "D": "Hard-coded integrations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Success depends on discipline, not tooling quantity.",
      "incorrect": {
        "A": "More connectors increase complexity.",
        "C": "Testing is mandatory.",
        "D": "Hard-coding increases risk."
      }
    }
  }
]
