[
  {
    "id": "CH10-0001",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "API Threats",
    "subtopic": "unauthorized access",
    "difficulty": "Easy",
    "question": "What is the primary goal of API authentication?",
    "options": {
      "A": "Encrypt API payloads",
      "B": "Verify the identity of the API consumer",
      "C": "Improve API performance",
      "D": "Transform request data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authentication ensures the caller is who they claim to be before access is granted.",
      "incorrect": {
        "A": "Encryption protects data, not identity.",
        "C": "Performance is unrelated to authentication.",
        "D": "Data transformation is handled separately."
      }
    }
  },
  {
    "id": "CH10-0002",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "client credentials",
    "difficulty": "Easy",
    "question": "Which credential pair is most commonly used for basic API authentication in MuleSoft?",
    "options": {
      "A": "Username and password",
      "B": "Client ID and Client Secret",
      "C": "JWT and private key",
      "D": "Session ID and cookie"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client ID and Client Secret uniquely identify and authenticate API consumers.",
      "incorrect": {
        "A": "Not recommended for APIs.",
        "C": "Used in token-based flows.",
        "D": "Session-based auth is not typical for APIs."
      }
    }
  },
  {
    "id": "CH10-0003",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "client-id enforcement",
    "difficulty": "Medium",
    "question": "What happens when Client ID enforcement policy is applied to an API?",
    "options": {
      "A": "Requests without valid credentials are rejected",
      "B": "Payloads are encrypted automatically",
      "C": "Rate limiting is enforced",
      "D": "Tokens are generated automatically"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The policy blocks requests missing or using invalid client credentials.",
      "incorrect": {
        "B": "Encryption is handled separately.",
        "C": "Rate limiting is a different policy.",
        "D": "Token generation is not part of client-id enforcement."
      }
    }
  },
  {
    "id": "CH10-0004",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "role-based access",
    "difficulty": "Medium",
    "question": "What is the purpose of authorization in API security?",
    "options": {
      "A": "Identify the API consumer",
      "B": "Control what actions an authenticated user can perform",
      "C": "Encrypt traffic",
      "D": "Improve throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authorization determines access rights after authentication succeeds.",
      "incorrect": {
        "A": "That is authentication.",
        "C": "Encryption protects data in transit.",
        "D": "Throughput is unrelated."
      }
    }
  },
  {
    "id": "CH10-0005",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "access tokens",
    "difficulty": "Medium",
    "question": "What is the primary role of an OAuth 2.0 access token?",
    "options": {
      "A": "Store user passwords",
      "B": "Represent delegated authorization",
      "C": "Encrypt request payloads",
      "D": "Replace API contracts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Access tokens represent granted permissions without exposing credentials.",
      "incorrect": {
        "A": "Passwords are never stored in tokens.",
        "C": "Encryption is separate.",
        "D": "Contracts define structure, not authorization."
      }
    }
  },
  {
    "id": "CH10-0006",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "token expiration",
    "difficulty": "Medium",
    "question": "Why should OAuth access tokens have short lifetimes?",
    "options": {
      "A": "To reduce API latency",
      "B": "To limit impact if a token is compromised",
      "C": "To avoid token refresh",
      "D": "To simplify API contracts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short-lived tokens reduce security exposure if stolen.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Refresh tokens still exist.",
        "D": "Contracts are unrelated."
      }
    }
  },
  {
    "id": "CH10-0007",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "rate limiting",
    "difficulty": "Medium",
    "question": "What is the primary purpose of rate limiting policies?",
    "options": {
      "A": "Prevent unauthorized access",
      "B": "Protect APIs from abuse and overuse",
      "C": "Encrypt API responses",
      "D": "Transform response formats"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limiting controls traffic volume to protect backend systems.",
      "incorrect": {
        "A": "Authentication handles access control.",
        "C": "Encryption is a different concern.",
        "D": "Transformation is unrelated."
      }
    }
  },
  {
    "id": "CH10-0008",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "spike control",
    "difficulty": "Medium",
    "question": "How does spike control differ from rate limiting?",
    "options": {
      "A": "Spike control handles sudden bursts of traffic",
      "B": "Spike control encrypts data",
      "C": "Spike control authenticates users",
      "D": "Spike control replaces SLA tiers"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Spike control prevents short-term traffic surges from overwhelming APIs.",
      "incorrect": {
        "B": "Encryption is unrelated.",
        "C": "Authentication is separate.",
        "D": "SLA tiers serve a different purpose."
      }
    }
  },
  {
    "id": "CH10-0009",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "SQL injection",
    "difficulty": "Hard",
    "question": "Which practice best protects APIs from SQL injection attacks?",
    "options": {
      "A": "Using parameterized queries",
      "B": "Increasing worker size",
      "C": "Caching responses",
      "D": "Applying rate limiting only"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Parameterized queries prevent malicious input from altering SQL logic.",
      "incorrect": {
        "B": "Scaling does not fix injection risks.",
        "C": "Caching does not sanitize input.",
        "D": "Rate limiting does not prevent injection."
      }
    }
  },
  {
    "id": "CH10-0010",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "input validation",
    "difficulty": "Medium",
    "question": "Why is strict input validation critical for APIs?",
    "options": {
      "A": "It improves API response time",
      "B": "It prevents malformed or malicious requests",
      "C": "It replaces authentication",
      "D": "It simplifies deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation blocks malicious payloads before processing.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Authentication is still required.",
        "D": "Deployment is unrelated."
      }
    }
  },

  {
    "id": "CH10-0011",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Transport Security",
    "subtopic": "TLS",
    "difficulty": "Easy",
    "question": "What does TLS primarily protect in API communication?",
    "options": {
      "A": "Business logic",
      "B": "Data in transit",
      "C": "Database schemas",
      "D": "API contracts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "TLS encrypts data exchanged between client and server.",
      "incorrect": {
        "A": "Logic remains server-side.",
        "C": "Schemas are unaffected.",
        "D": "Contracts define structure only."
      }
    }
  },

  {
    "id": "CH10-0012",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Certificates",
    "subtopic": "mutual TLS",
    "difficulty": "Hard",
    "question": "What additional security does mutual TLS (mTLS) provide?",
    "options": {
      "A": "Only server authentication",
      "B": "Both client and server authentication",
      "C": "Token generation",
      "D": "Payload transformation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mTLS authenticates both parties using certificates.",
      "incorrect": {
        "A": "Standard TLS authenticates only the server.",
        "C": "Tokens are unrelated.",
        "D": "Transformation is separate."
      }
    }
  },

  {
    "id": "CH10-0013",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Governance",
    "subtopic": "policy enforcement",
    "difficulty": "Medium",
    "question": "Why should security policies be enforced centrally?",
    "options": {
      "A": "To reduce API flexibility",
      "B": "To ensure consistent security across APIs",
      "C": "To improve payload size",
      "D": "To avoid audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Central enforcement ensures uniform protection and compliance.",
      "incorrect": {
        "A": "Flexibility can still be maintained.",
        "C": "Payload size is irrelevant.",
        "D": "Audits are still required."
      }
    }
  },

  {
    "id": "CH10-0014",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Logging",
    "subtopic": "sensitive data",
    "difficulty": "Medium",
    "question": "What is a best practice when logging API requests?",
    "options": {
      "A": "Log full payloads including secrets",
      "B": "Mask or exclude sensitive information",
      "C": "Disable logging",
      "D": "Only log successful calls"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Masking prevents accidental exposure of sensitive data.",
      "incorrect": {
        "A": "This creates security risks.",
        "C": "Logging is essential for troubleshooting.",
        "D": "Failures must also be logged."
      }
    }
  },

  {
    "id": "CH10-0015",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "anomaly detection",
    "difficulty": "Medium",
    "question": "Why is anomaly detection important for API security?",
    "options": {
      "A": "To improve API documentation",
      "B": "To identify unusual or malicious behavior",
      "C": "To reduce response size",
      "D": "To eliminate rate limiting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Anomalies often indicate abuse or attacks.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Response size is irrelevant.",
        "D": "Rate limiting still applies."
      }
    }
  },

  {
    "id": "CH10-0016",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "hardcoded secrets",
    "difficulty": "Medium",
    "question": "Why should secrets never be hardcoded in Mule applications?",
    "options": {
      "A": "They slow down deployments",
      "B": "They can be easily exposed or leaked",
      "C": "They increase payload size",
      "D": "They break API contracts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hardcoded secrets are difficult to rotate and often leak.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Payload size is unrelated.",
        "D": "Contracts remain unchanged."
      }
    }
  },

  {
    "id": "CH10-0017",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secure storage",
    "difficulty": "Medium",
    "question": "Where should sensitive API credentials be stored?",
    "options": {
      "A": "In source code",
      "B": "In environment variables or secure vaults",
      "C": "In API responses",
      "D": "In logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure storage allows controlled access and rotation.",
      "incorrect": {
        "A": "Source code exposure is risky.",
        "C": "Responses must not contain secrets.",
        "D": "Logs are insecure storage."
      }
    }
  },

  {
    "id": "CH10-0018",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "least privilege",
    "difficulty": "Medium",
    "question": "What does the principle of least privilege require?",
    "options": {
      "A": "Granting maximum permissions",
      "B": "Granting only required access",
      "C": "Sharing credentials",
      "D": "Disabling authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege minimizes damage if access is misused.",
      "incorrect": {
        "A": "Excessive access increases risk.",
        "C": "Credential sharing is insecure.",
        "D": "Authorization remains essential."
      }
    }
  },

  {
    "id": "CH10-0019",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Modeling",
    "subtopic": "attack surface",
    "difficulty": "Hard",
    "question": "What does reducing an APIâ€™s attack surface involve?",
    "options": {
      "A": "Exposing fewer endpoints and methods",
      "B": "Increasing payload size",
      "C": "Disabling authentication",
      "D": "Removing logging"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Fewer exposed operations reduce potential attack vectors.",
      "incorrect": {
        "B": "Payload size is unrelated.",
        "C": "Authentication is mandatory.",
        "D": "Logging is critical."
      }
    }
  },

  {
    "id": "CH10-0020",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "defense in depth",
    "difficulty": "Medium",
    "question": "What best describes defense-in-depth for APIs?",
    "options": {
      "A": "Using a single strong security control",
      "B": "Layering multiple complementary security measures",
      "C": "Disabling unused policies",
      "D": "Relying only on network security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Multiple layers reduce the chance of total compromise.",
      "incorrect": {
        "A": "Single controls can fail.",
        "C": "Policies should be reviewed, not blindly disabled.",
        "D": "Network security alone is insufficient."
      }
    }
  },
  {
    "id": "CH10-0021",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "authorization code flow",
    "difficulty": "Medium",
    "question": "Why is the OAuth 2.0 authorization code flow preferred for confidential clients?",
    "options": {
      "A": "It avoids token usage",
      "B": "It keeps access tokens off the browser",
      "C": "It eliminates refresh tokens",
      "D": "It disables TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tokens are exchanged securely on the server side, reducing exposure.",
      "incorrect": {
        "A": "OAuth relies on tokens.",
        "C": "Refresh tokens are commonly used.",
        "D": "TLS is mandatory, not disabled."
      }
    }
  },
  {
    "id": "CH10-0022",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "refresh tokens",
    "difficulty": "Medium",
    "question": "What is the main purpose of a refresh token?",
    "options": {
      "A": "Authenticate the API itself",
      "B": "Obtain new access tokens without re-authentication",
      "C": "Encrypt API payloads",
      "D": "Replace client credentials"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Refresh tokens allow continued access without re-login.",
      "incorrect": {
        "A": "APIs do not authenticate themselves.",
        "C": "Encryption is unrelated.",
        "D": "Client credentials still exist."
      }
    }
  },
  {
    "id": "CH10-0023",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token leakage",
    "difficulty": "Hard",
    "question": "Which practice best reduces the risk of OAuth token leakage?",
    "options": {
      "A": "Embedding tokens in URLs",
      "B": "Using Authorization headers",
      "C": "Logging tokens for debugging",
      "D": "Using long-lived tokens"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authorization headers are not stored in logs or browser history.",
      "incorrect": {
        "A": "URLs are easily exposed.",
        "C": "Logging tokens is unsafe.",
        "D": "Long-lived tokens increase risk."
      }
    }
  },
  {
    "id": "CH10-0024",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "SLA tiers",
    "difficulty": "Medium",
    "question": "What is the primary function of SLA tiers in API Manager?",
    "options": {
      "A": "Encrypt API responses",
      "B": "Apply different usage limits per consumer",
      "C": "Authenticate users",
      "D": "Transform payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLA tiers define consumption limits based on subscription level.",
      "incorrect": {
        "A": "Encryption is separate.",
        "C": "Authentication is independent.",
        "D": "Transformation is unrelated."
      }
    }
  },
  {
    "id": "CH10-0025",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "rate limit vs SLA",
    "difficulty": "Medium",
    "question": "How does rate limiting differ from SLA-based throttling?",
    "options": {
      "A": "Rate limiting is global, SLA is consumer-specific",
      "B": "Rate limiting encrypts traffic",
      "C": "SLA disables policies",
      "D": "They are identical"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "SLA tiers apply limits per consumer, while rate limits can be global.",
      "incorrect": {
        "B": "Encryption is unrelated.",
        "C": "SLA does not disable policies.",
        "D": "They serve different purposes."
      }
    }
  },
  {
    "id": "CH10-0026",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "cross-site scripting",
    "difficulty": "Hard",
    "question": "Why should APIs sanitize output to prevent XSS attacks?",
    "options": {
      "A": "APIs never return user input",
      "B": "Clients may render API data directly",
      "C": "XSS only affects databases",
      "D": "TLS prevents XSS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unsanitized data can be executed in client applications.",
      "incorrect": {
        "A": "APIs often return user-provided data.",
        "C": "XSS is a client-side issue.",
        "D": "TLS does not sanitize content."
      }
    }
  },
  {
    "id": "CH10-0027",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "brute force attacks",
    "difficulty": "Medium",
    "question": "Which mechanism best mitigates brute force attacks on APIs?",
    "options": {
      "A": "Payload validation",
      "B": "Rate limiting and account lockout",
      "C": "Response caching",
      "D": "Schema validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limiting attempts reduces brute force feasibility.",
      "incorrect": {
        "A": "Validation does not stop repeated attempts.",
        "C": "Caching does not prevent attacks.",
        "D": "Schemas do not limit retries."
      }
    }
  },
  {
    "id": "CH10-0028",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Headers",
    "subtopic": "security headers",
    "difficulty": "Medium",
    "question": "Why should APIs control response headers?",
    "options": {
      "A": "To expose internal server details",
      "B": "To prevent information leakage",
      "C": "To improve throughput",
      "D": "To bypass authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Minimizing headers reduces attacker intelligence.",
      "incorrect": {
        "A": "Exposing details is insecure.",
        "C": "Throughput is unaffected.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH10-0029",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Certificates",
    "subtopic": "certificate rotation",
    "difficulty": "Medium",
    "question": "Why is regular certificate rotation important?",
    "options": {
      "A": "To improve API speed",
      "B": "To reduce impact of compromised certificates",
      "C": "To avoid TLS",
      "D": "To simplify payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation limits long-term exposure if keys are compromised.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "TLS remains required.",
        "D": "Payloads are unaffected."
      }
    }
  },
  {
    "id": "CH10-0030",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Logging",
    "subtopic": "audit trails",
    "difficulty": "Medium",
    "question": "What is the primary purpose of audit logs in API security?",
    "options": {
      "A": "Improve response time",
      "B": "Support forensic analysis and compliance",
      "C": "Transform payloads",
      "D": "Reduce traffic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audit logs provide traceability for security events.",
      "incorrect": {
        "A": "Performance is not the goal.",
        "C": "Transformation is unrelated.",
        "D": "Traffic control is separate."
      }
    }
  },

  {
    "id": "CH10-0031",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "failed authentication",
    "difficulty": "Medium",
    "question": "Why should repeated authentication failures be monitored?",
    "options": {
      "A": "They increase payload size",
      "B": "They may indicate credential stuffing or attacks",
      "C": "They improve security posture",
      "D": "They are expected behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated failures often signal malicious activity.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "They indicate problems, not improvements.",
        "D": "They require investigation."
      }
    }
  },
  {
    "id": "CH10-0032",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "rotation",
    "difficulty": "Medium",
    "question": "Why should API secrets be rotated periodically?",
    "options": {
      "A": "To increase deployment complexity",
      "B": "To limit long-term exposure of compromised secrets",
      "C": "To improve response size",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation reduces damage from leaked credentials.",
      "incorrect": {
        "A": "Complexity is not the goal.",
        "C": "Response size is unaffected.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0033",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "data minimization",
    "difficulty": "Medium",
    "question": "What does data minimization mean in API design?",
    "options": {
      "A": "Storing all available data",
      "B": "Exposing only necessary data",
      "C": "Encrypting all responses",
      "D": "Removing authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limiting data reduces exposure and compliance risk.",
      "incorrect": {
        "A": "Excess data increases risk.",
        "C": "Encryption is separate.",
        "D": "Authentication remains essential."
      }
    }
  },
  {
    "id": "CH10-0034",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "idempotency",
    "difficulty": "Medium",
    "question": "Why is idempotency important for secure APIs?",
    "options": {
      "A": "It prevents duplicate side effects",
      "B": "It encrypts payloads",
      "C": "It authenticates users",
      "D": "It hides endpoints"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Idempotency prevents repeated requests from causing harm.",
      "incorrect": {
        "B": "Encryption is separate.",
        "C": "Authentication is unrelated.",
        "D": "Endpoints remain visible."
      }
    }
  },
  {
    "id": "CH10-0035",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "zero trust",
    "difficulty": "Hard",
    "question": "What is the core principle of Zero Trust for APIs?",
    "options": {
      "A": "Trust internal traffic",
      "B": "Never trust, always verify",
      "C": "Disable authentication internally",
      "D": "Rely only on network security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Every request must be authenticated and authorized.",
      "incorrect": {
        "A": "Internal traffic can be compromised.",
        "C": "Authentication is mandatory.",
        "D": "Network security alone is insufficient."
      }
    }
  },

  {
    "id": "CH10-0036",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "security testing",
    "difficulty": "Medium",
    "question": "Why should security testing be part of CI/CD pipelines?",
    "options": {
      "A": "To delay releases",
      "B": "To detect vulnerabilities early",
      "C": "To replace monitoring",
      "D": "To simplify code"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early detection reduces cost and risk.",
      "incorrect": {
        "A": "Automation reduces delays.",
        "C": "Monitoring is complementary.",
        "D": "Code simplicity is unrelated."
      }
    }
  },

  {
    "id": "CH10-0037",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Error Handling",
    "subtopic": "error messages",
    "difficulty": "Medium",
    "question": "Why should API error messages be generic?",
    "options": {
      "A": "To confuse developers",
      "B": "To avoid leaking implementation details",
      "C": "To reduce payload size",
      "D": "To disable debugging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Detailed errors can help attackers.",
      "incorrect": {
        "A": "Developer clarity is still possible.",
        "C": "Size is not the main concern.",
        "D": "Debugging should be done securely."
      }
    }
  },

  {
    "id": "CH10-0038",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Architecture",
    "subtopic": "API gateway",
    "difficulty": "Medium",
    "question": "Why is an API gateway critical for security?",
    "options": {
      "A": "It replaces backend services",
      "B": "It centralizes enforcement of security policies",
      "C": "It improves database performance",
      "D": "It eliminates the need for TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Gateways enforce auth, rate limits, and policies consistently.",
      "incorrect": {
        "A": "Backends still exist.",
        "C": "Databases are separate.",
        "D": "TLS is still required."
      }
    }
  },

  {
    "id": "CH10-0039",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "security reviews",
    "difficulty": "Easy",
    "question": "Why are periodic security reviews necessary?",
    "options": {
      "A": "APIs never change",
      "B": "Threats and dependencies evolve over time",
      "C": "They reduce performance",
      "D": "They replace automation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "New threats emerge as systems evolve.",
      "incorrect": {
        "A": "APIs change frequently.",
        "C": "Performance impact is minimal.",
        "D": "Automation complements reviews."
      }
    }
  },

  {
    "id": "CH10-0040",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security mindset",
    "difficulty": "Easy",
    "question": "What best defines a strong API security mindset?",
    "options": {
      "A": "Security as an afterthought",
      "B": "Security built into every design and decision",
      "C": "Relying on firewalls only",
      "D": "Disabling unused features without review"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security must be embedded throughout the API lifecycle.",
      "incorrect": {
        "A": "Afterthoughts create vulnerabilities.",
        "C": "Firewalls alone are insufficient.",
        "D": "Review is always required."
      }
    }
  },
  {
    "id": "CH10-0041",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "implicit flow risks",
    "difficulty": "Hard",
    "question": "Why is the OAuth 2.0 implicit flow considered less secure?",
    "options": {
      "A": "It does not use TLS",
      "B": "Access tokens are exposed in the browser",
      "C": "It requires refresh tokens",
      "D": "It disables scopes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tokens are returned via browser redirects and can be intercepted.",
      "incorrect": {
        "A": "TLS is still used.",
        "C": "Implicit flow does not use refresh tokens.",
        "D": "Scopes are still supported."
      }
    }
  },
  {
    "id": "CH10-0042",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "OAuth 2.0",
    "subtopic": "PKCE",
    "difficulty": "Hard",
    "question": "What security problem does PKCE address in OAuth flows?",
    "options": {
      "A": "Token replay attacks",
      "B": "Authorization code interception",
      "C": "Rate limit exhaustion",
      "D": "Schema injection"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PKCE ensures intercepted authorization codes cannot be reused.",
      "incorrect": {
        "A": "Replay attacks are mitigated differently.",
        "C": "Rate limiting is unrelated.",
        "D": "Schema injection is unrelated."
      }
    }
  },
  {
    "id": "CH10-0043",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "API keys",
    "difficulty": "Medium",
    "question": "Why are API keys alone insufficient for high-security APIs?",
    "options": {
      "A": "They cannot be rotated",
      "B": "They do not strongly identify users",
      "C": "They encrypt payloads",
      "D": "They slow down requests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API keys typically identify applications, not users or context.",
      "incorrect": {
        "A": "They can be rotated.",
        "C": "API keys do not encrypt anything.",
        "D": "Performance impact is negligible."
      }
    }
  },
  {
    "id": "CH10-0044",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "scope validation",
    "difficulty": "Medium",
    "question": "What is the purpose of validating scopes in OAuth-protected APIs?",
    "options": {
      "A": "To authenticate the user",
      "B": "To restrict actions based on granted permissions",
      "C": "To encrypt tokens",
      "D": "To improve throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scopes define what actions a token is allowed to perform.",
      "incorrect": {
        "A": "Authentication already occurred.",
        "C": "Encryption is unrelated.",
        "D": "Throughput is unaffected."
      }
    }
  },
  {
    "id": "CH10-0045",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "IP allowlist",
    "difficulty": "Medium",
    "question": "What is the primary benefit of IP allowlisting?",
    "options": {
      "A": "Encrypting traffic",
      "B": "Restricting access to trusted networks",
      "C": "Improving latency",
      "D": "Replacing authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only requests from approved IP ranges are accepted.",
      "incorrect": {
        "A": "Encryption is separate.",
        "C": "Latency is not guaranteed to improve.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0046",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "denylist limitations",
    "difficulty": "Medium",
    "question": "Why are IP denylists generally less effective than allowlists?",
    "options": {
      "A": "Attackers can change IP addresses",
      "B": "They disable TLS",
      "C": "They reduce throughput",
      "D": "They prevent logging"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Attackers can rotate IPs, bypassing denylists.",
      "incorrect": {
        "B": "TLS is unaffected.",
        "C": "Performance impact is minimal.",
        "D": "Logging is independent."
      }
    }
  },
  {
    "id": "CH10-0047",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "mass assignment",
    "difficulty": "Hard",
    "question": "What is a mass assignment vulnerability in APIs?",
    "options": {
      "A": "Excessive API calls",
      "B": "Clients modifying fields they should not control",
      "C": "Improper TLS configuration",
      "D": "Weak password storage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs bind user input directly to objects without validation.",
      "incorrect": {
        "A": "That is a rate limiting issue.",
        "C": "TLS misconfiguration is different.",
        "D": "Password storage is unrelated."
      }
    }
  },
  {
    "id": "CH10-0048",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "broken object level authorization",
    "difficulty": "Hard",
    "question": "What causes Broken Object Level Authorization (BOLA)?",
    "options": {
      "A": "Missing authentication",
      "B": "Failure to verify object ownership",
      "C": "Large payload sizes",
      "D": "Schema mismatches"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs expose object IDs without verifying access rights.",
      "incorrect": {
        "A": "Authentication may still exist.",
        "C": "Payload size is unrelated.",
        "D": "Schemas do not control authorization."
      }
    }
  },
  {
    "id": "CH10-0049",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "excessive data exposure",
    "difficulty": "Medium",
    "question": "What leads to excessive data exposure in APIs?",
    "options": {
      "A": "Strong input validation",
      "B": "Returning full objects without filtering",
      "C": "Rate limiting",
      "D": "TLS encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Returning unnecessary fields increases risk.",
      "incorrect": {
        "A": "Validation reduces risk.",
        "C": "Rate limiting controls traffic.",
        "D": "TLS protects transport only."
      }
    }
  },
  {
    "id": "CH10-0050",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Headers",
    "subtopic": "CORS",
    "difficulty": "Medium",
    "question": "Why must CORS be carefully configured for APIs?",
    "options": {
      "A": "To allow all origins",
      "B": "To control which domains can access the API",
      "C": "To encrypt responses",
      "D": "To authenticate users"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Improper CORS can expose APIs to malicious web apps.",
      "incorrect": {
        "A": "Allowing all origins is risky.",
        "C": "Encryption is unrelated.",
        "D": "Authentication is separate."
      }
    }
  },

  {
    "id": "CH10-0051",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Transport Security",
    "subtopic": "TLS versions",
    "difficulty": "Medium",
    "question": "Why should older TLS versions be disabled?",
    "options": {
      "A": "They reduce performance",
      "B": "They contain known vulnerabilities",
      "C": "They prevent OAuth",
      "D": "They increase payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deprecated TLS versions are vulnerable to attacks.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "OAuth is unaffected.",
        "D": "Payload size is irrelevant."
      }
    }
  },
  {
    "id": "CH10-0052",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Certificates",
    "subtopic": "trust stores",
    "difficulty": "Medium",
    "question": "What is the role of a trust store in TLS?",
    "options": {
      "A": "Store API payloads",
      "B": "Hold trusted certificate authorities",
      "C": "Encrypt request bodies",
      "D": "Generate access tokens"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Trust stores determine which certificates are trusted.",
      "incorrect": {
        "A": "Payload storage is unrelated.",
        "C": "Encryption uses keys, not trust stores.",
        "D": "Tokens are unrelated."
      }
    }
  },
  {
    "id": "CH10-0053",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "traffic anomalies",
    "difficulty": "Medium",
    "question": "What may a sudden spike in API traffic indicate?",
    "options": {
      "A": "Schema evolution",
      "B": "Potential abuse or attack",
      "C": "Successful deployment",
      "D": "Improved performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unexpected spikes often signal misuse or attacks.",
      "incorrect": {
        "A": "Schemas do not affect traffic volume.",
        "C": "Deployments alone do not explain spikes.",
        "D": "Performance improvements do not cause spikes."
      }
    }
  },
  {
    "id": "CH10-0054",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "environment separation",
    "difficulty": "Medium",
    "question": "Why should secrets differ across environments?",
    "options": {
      "A": "To simplify debugging",
      "B": "To prevent cross-environment compromise",
      "C": "To reduce monitoring",
      "D": "To improve latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation limits blast radius of leaked credentials.",
      "incorrect": {
        "A": "Debugging is unrelated.",
        "C": "Monitoring remains required.",
        "D": "Latency is unaffected."
      }
    }
  },
  {
    "id": "CH10-0055",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "PII protection",
    "difficulty": "Medium",
    "question": "What is a best practice for handling PII in APIs?",
    "options": {
      "A": "Expose full PII to all consumers",
      "B": "Mask or tokenize sensitive fields",
      "C": "Disable logging entirely",
      "D": "Store PII in headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Masking or tokenization reduces exposure risk.",
      "incorrect": {
        "A": "This violates privacy principles.",
        "C": "Logging should be controlled, not removed.",
        "D": "Headers are not secure storage."
      }
    }
  },
  {
    "id": "CH10-0056",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "pagination security",
    "difficulty": "Medium",
    "question": "Why should pagination parameters be validated?",
    "options": {
      "A": "To reduce response size only",
      "B": "To prevent data scraping or abuse",
      "C": "To encrypt data",
      "D": "To disable caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unrestricted pagination can expose large datasets.",
      "incorrect": {
        "A": "Size is not the only concern.",
        "C": "Encryption is unrelated.",
        "D": "Caching is independent."
      }
    }
  },
  {
    "id": "CH10-0057",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "secure defaults",
    "difficulty": "Easy",
    "question": "Why should APIs use secure defaults?",
    "options": {
      "A": "To reduce flexibility",
      "B": "To minimize misconfiguration risks",
      "C": "To slow development",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure defaults reduce accidental exposure.",
      "incorrect": {
        "A": "Flexibility can still exist.",
        "C": "Development speed is unaffected.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0058",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Testing",
    "subtopic": "negative testing",
    "difficulty": "Medium",
    "question": "What is the goal of negative security testing?",
    "options": {
      "A": "Confirm valid requests succeed",
      "B": "Ensure invalid or malicious requests fail safely",
      "C": "Improve throughput",
      "D": "Reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Negative tests validate defensive behavior.",
      "incorrect": {
        "A": "That is positive testing.",
        "C": "Throughput is unrelated.",
        "D": "Logging is still required."
      }
    }
  },
  {
    "id": "CH10-0059",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Architecture",
    "subtopic": "backend isolation",
    "difficulty": "Medium",
    "question": "Why should backend systems not be directly exposed?",
    "options": {
      "A": "To reduce latency",
      "B": "To limit attack surface and enforce controls",
      "C": "To simplify payloads",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation ensures security policies are consistently applied.",
      "incorrect": {
        "A": "Latency is not guaranteed to improve.",
        "C": "Payloads are unrelated.",
        "D": "Authentication remains necessary."
      }
    }
  },
  {
    "id": "CH10-0060",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security lifecycle",
    "difficulty": "Easy",
    "question": "When should API security be addressed?",
    "options": {
      "A": "Only after production issues",
      "B": "Throughout the entire API lifecycle",
      "C": "Only during testing",
      "D": "Only during deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security must be continuous from design to operation.",
      "incorrect": {
        "A": "Reactive security is risky.",
        "C": "Testing alone is insufficient.",
        "D": "Deployment is only one phase."
      }
    }
  },
  {
    "id": "CH10-0061",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "credential stuffing",
    "difficulty": "Hard",
    "question": "What characteristic most strongly indicates a credential stuffing attack on an API?",
    "options": {
      "A": "High volume of requests with different credentials",
      "B": "Single client making slow requests",
      "C": "Large payload sizes",
      "D": "Schema validation failures"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Credential stuffing uses many credential combinations at high speed.",
      "incorrect": {
        "B": "Slow requests are not typical of stuffing.",
        "C": "Payload size is unrelated.",
        "D": "Schema errors are not an indicator."
      }
    }
  },
  {
    "id": "CH10-0062",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "multi-factor authentication",
    "difficulty": "Medium",
    "question": "Why is MFA rarely enforced directly at API level?",
    "options": {
      "A": "APIs cannot validate MFA",
      "B": "MFA is typically handled by identity providers",
      "C": "MFA reduces API performance",
      "D": "MFA replaces authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs rely on tokens issued by identity providers enforcing MFA.",
      "incorrect": {
        "A": "APIs can validate tokens.",
        "C": "Performance impact is not the reason.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH10-0063",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "attribute-based access control",
    "difficulty": "Hard",
    "question": "What differentiates ABAC from role-based access control?",
    "options": {
      "A": "ABAC uses static roles only",
      "B": "ABAC evaluates multiple attributes at runtime",
      "C": "ABAC disables scopes",
      "D": "ABAC removes authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ABAC considers user, resource, and context attributes dynamically.",
      "incorrect": {
        "A": "That describes RBAC.",
        "C": "Scopes are still applicable.",
        "D": "Authentication is mandatory."
      }
    }
  },
  {
    "id": "CH10-0064",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "JWT claims",
    "difficulty": "Medium",
    "question": "Why should JWT claims be validated on every request?",
    "options": {
      "A": "To regenerate tokens",
      "B": "To ensure token integrity and authorization",
      "C": "To encrypt payloads",
      "D": "To increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Claims validation confirms issuer, expiry, and permissions.",
      "incorrect": {
        "A": "Tokens are not regenerated per request.",
        "C": "JWT validation does not encrypt payloads.",
        "D": "Throughput is unrelated."
      }
    }
  },
  {
    "id": "CH10-0065",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "audience claim",
    "difficulty": "Medium",
    "question": "What does the 'aud' claim in a JWT represent?",
    "options": {
      "A": "Token issuer",
      "B": "Intended recipient of the token",
      "C": "Token expiration time",
      "D": "Encryption algorithm"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audience ensures the token is used only by intended APIs.",
      "incorrect": {
        "A": "Issuer is defined by 'iss'.",
        "C": "Expiration is defined by 'exp'.",
        "D": "Algorithm is defined in the header."
      }
    }
  },
  {
    "id": "CH10-0066",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "throttling behavior",
    "difficulty": "Medium",
    "question": "What happens when an API consumer exceeds a throttling limit?",
    "options": {
      "A": "API shuts down permanently",
      "B": "Requests are temporarily rejected",
      "C": "Authentication is disabled",
      "D": "Payloads are truncated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Throttling temporarily blocks excess requests.",
      "incorrect": {
        "A": "The API remains available.",
        "C": "Authentication is unaffected.",
        "D": "Payloads are not modified."
      }
    }
  },
  {
    "id": "CH10-0067",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy order",
    "difficulty": "Hard",
    "question": "Why does the order of applied API policies matter?",
    "options": {
      "A": "It changes API contracts",
      "B": "Earlier policies can block requests before later ones execute",
      "C": "It affects payload transformation only",
      "D": "It disables logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policy execution order impacts request flow and enforcement.",
      "incorrect": {
        "A": "Contracts are independent.",
        "C": "Transformations are not the only effect.",
        "D": "Logging is separate."
      }
    }
  },
  {
    "id": "CH10-0068",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "API scraping",
    "difficulty": "Medium",
    "question": "Which combination best mitigates large-scale API scraping?",
    "options": {
      "A": "Caching and compression",
      "B": "Rate limiting and pagination limits",
      "C": "TLS and certificates",
      "D": "Payload transformation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limiting request rate and page size reduces scraping feasibility.",
      "incorrect": {
        "A": "Caching does not prevent scraping.",
        "C": "TLS does not limit access.",
        "D": "Transformation is unrelated."
      }
    }
  },
  {
    "id": "CH10-0069",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "denial of service",
    "difficulty": "Medium",
    "question": "Which control most directly mitigates API-based denial-of-service attacks?",
    "options": {
      "A": "Strong authentication",
      "B": "Rate limiting and spike control",
      "C": "Schema validation",
      "D": "Payload encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traffic controls prevent backend exhaustion.",
      "incorrect": {
        "A": "Auth alone does not stop volume attacks.",
        "C": "Schemas do not control traffic volume.",
        "D": "Encryption does not limit requests."
      }
    }
  },
  {
    "id": "CH10-0070",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Headers",
    "subtopic": "authorization header",
    "difficulty": "Easy",
    "question": "Why should access tokens be sent in the Authorization header?",
    "options": {
      "A": "Headers are encrypted by default",
      "B": "Headers reduce accidental exposure compared to URLs",
      "C": "Headers improve response speed",
      "D": "Headers bypass CORS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Headers are not stored in logs or browser history like URLs.",
      "incorrect": {
        "A": "Encryption depends on TLS.",
        "C": "Speed is unaffected.",
        "D": "CORS still applies."
      }
    }
  },

  {
    "id": "CH10-0071",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "geo anomalies",
    "difficulty": "Medium",
    "question": "Why should APIs monitor sudden changes in request geography?",
    "options": {
      "A": "To improve caching",
      "B": "To detect potential account compromise",
      "C": "To reduce latency",
      "D": "To disable TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unexpected geographic access may indicate stolen credentials.",
      "incorrect": {
        "A": "Caching is unrelated.",
        "C": "Latency is not the main concern.",
        "D": "TLS is unaffected."
      }
    }
  },
  {
    "id": "CH10-0072",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "baseline behavior",
    "difficulty": "Medium",
    "question": "Why establish baseline API behavior metrics?",
    "options": {
      "A": "To reduce payload size",
      "B": "To identify deviations indicating attacks",
      "C": "To simplify deployment",
      "D": "To disable logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Baselines make anomalies easier to detect.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Deployment is unaffected.",
        "D": "Logging remains essential."
      }
    }
  },
  {
    "id": "CH10-0073",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "least exposure",
    "difficulty": "Medium",
    "question": "What practice best limits exposure of API secrets?",
    "options": {
      "A": "Sharing secrets across services",
      "B": "Scoping secrets to minimal required usage",
      "C": "Hardcoding secrets",
      "D": "Storing secrets in logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Narrow scope limits blast radius of leaks.",
      "incorrect": {
        "A": "Sharing increases risk.",
        "C": "Hardcoding is insecure.",
        "D": "Logs are not secure storage."
      }
    }
  },
  {
    "id": "CH10-0074",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret revocation",
    "difficulty": "Medium",
    "question": "When should API secrets be revoked immediately?",
    "options": {
      "A": "During deployment",
      "B": "After suspected compromise",
      "C": "At application startup",
      "D": "During monitoring setup"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Revocation limits further misuse after compromise.",
      "incorrect": {
        "A": "Deployment alone does not require revocation.",
        "C": "Startup is not relevant.",
        "D": "Monitoring does not trigger revocation."
      }
    }
  },
  {
    "id": "CH10-0075",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "audit readiness",
    "difficulty": "Medium",
    "question": "What supports audit readiness for secure APIs?",
    "options": {
      "A": "Minimal documentation",
      "B": "Clear logs and traceable access controls",
      "C": "Manual deployments",
      "D": "Disabling policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audits require evidence of controlled access and actions.",
      "incorrect": {
        "A": "Documentation is essential.",
        "C": "Manual steps reduce traceability.",
        "D": "Policies are required."
      }
    }
  },
  {
    "id": "CH10-0076",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "error rate limits",
    "difficulty": "Medium",
    "question": "Why should APIs limit repeated error responses?",
    "options": {
      "A": "To hide functionality",
      "B": "To reduce information leakage and abuse",
      "C": "To improve throughput",
      "D": "To bypass authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated errors can aid attackers probing APIs.",
      "incorrect": {
        "A": "Hiding functionality is not the goal.",
        "C": "Throughput is unrelated.",
        "D": "Authentication remains enforced."
      }
    }
  },
  {
    "id": "CH10-0077",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "security ownership",
    "difficulty": "Easy",
    "question": "Who is responsible for API security in an organization?",
    "options": {
      "A": "Security team only",
      "B": "Shared responsibility across teams",
      "C": "Operations team only",
      "D": "Developers only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security is a shared responsibility across roles.",
      "incorrect": {
        "A": "Security teams cannot own everything.",
        "C": "Operations alone is insufficient.",
        "D": "Developers are not the only stakeholders."
      }
    }
  },
  {
    "id": "CH10-0078",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Testing",
    "subtopic": "penetration testing",
    "difficulty": "Medium",
    "question": "What is the primary goal of API penetration testing?",
    "options": {
      "A": "Validate documentation accuracy",
      "B": "Identify exploitable security weaknesses",
      "C": "Improve performance",
      "D": "Replace monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pen tests simulate attacker behavior.",
      "incorrect": {
        "A": "Documentation is secondary.",
        "C": "Performance is not the goal.",
        "D": "Monitoring remains required."
      }
    }
  },
  {
    "id": "CH10-0079",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Architecture",
    "subtopic": "network segmentation",
    "difficulty": "Medium",
    "question": "Why is network segmentation important for API security?",
    "options": {
      "A": "To reduce payload size",
      "B": "To limit lateral movement after compromise",
      "C": "To improve response formatting",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Segmentation restricts attacker movement within networks.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Formatting is separate.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH10-0080",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security posture",
    "difficulty": "Easy",
    "question": "What best represents a strong API security posture?",
    "options": {
      "A": "Single security control",
      "B": "Layered controls with continuous monitoring",
      "C": "Manual reviews only",
      "D": "Disabling unused endpoints without testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defense-in-depth and visibility ensure resilience.",
      "incorrect": {
        "A": "Single controls can fail.",
        "C": "Manual reviews do not scale.",
        "D": "Testing is always required."
      }
    }
  },
  {
    "id": "CH10-0081",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "token revocation",
    "difficulty": "Medium",
    "question": "Why is token revocation important in API security?",
    "options": {
      "A": "To reduce API latency",
      "B": "To immediately invalidate compromised or unused tokens",
      "C": "To refresh tokens automatically",
      "D": "To improve payload validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Revocation ensures stolen or misused tokens can no longer access APIs.",
      "incorrect": {
        "A": "Latency is unrelated.",
        "C": "Refresh and revocation serve different purposes.",
        "D": "Validation does not invalidate tokens."
      }
    }
  },
  {
    "id": "CH10-0082",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token audience mismatch",
    "difficulty": "Hard",
    "question": "What is the security risk of accepting a token with an incorrect audience claim?",
    "options": {
      "A": "Increased response size",
      "B": "Token reuse across unintended APIs",
      "C": "Failure of TLS handshake",
      "D": "Schema validation errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tokens may be replayed against APIs they were not intended for.",
      "incorrect": {
        "A": "Response size is unrelated.",
        "C": "TLS is independent of JWT claims.",
        "D": "Schema validation is unrelated."
      }
    }
  },
  {
    "id": "CH10-0083",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "fine-grained authorization",
    "difficulty": "Medium",
    "question": "Why is fine-grained authorization preferred over coarse-grained access?",
    "options": {
      "A": "It simplifies authentication",
      "B": "It limits actions to precisely what is required",
      "C": "It removes the need for policies",
      "D": "It improves API throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fine-grained controls reduce excessive permissions.",
      "incorrect": {
        "A": "Authentication is separate.",
        "C": "Policies are still required.",
        "D": "Throughput is unaffected."
      }
    }
  },
  {
    "id": "CH10-0084",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy bypass risks",
    "difficulty": "Hard",
    "question": "What configuration mistake can lead to policy bypass in APIs?",
    "options": {
      "A": "Applying policies at the gateway only",
      "B": "Exposing backend services directly",
      "C": "Using TLS encryption",
      "D": "Enabling rate limiting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Direct backend access bypasses gateway-enforced security.",
      "incorrect": {
        "A": "Gateway enforcement is recommended.",
        "C": "TLS does not bypass policies.",
        "D": "Rate limiting enhances protection."
      }
    }
  },
  {
    "id": "CH10-0085",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "object injection",
    "difficulty": "Hard",
    "question": "What causes object injection vulnerabilities in APIs?",
    "options": {
      "A": "Strict schema validation",
      "B": "Blindly deserializing client-controlled objects",
      "C": "Rate limiting",
      "D": "TLS misconfiguration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unsafe deserialization allows attackers to manipulate object structures.",
      "incorrect": {
        "A": "Strict validation prevents this.",
        "C": "Rate limiting is unrelated.",
        "D": "TLS does not affect deserialization."
      }
    }
  },
  {
    "id": "CH10-0086",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "parameter tampering",
    "difficulty": "Medium",
    "question": "What is the best defense against parameter tampering?",
    "options": {
      "A": "Client-side validation only",
      "B": "Server-side validation and authorization checks",
      "C": "Response caching",
      "D": "Compression"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Server-side validation cannot be bypassed by attackers.",
      "incorrect": {
        "A": "Client-side checks can be bypassed.",
        "C": "Caching does not validate parameters.",
        "D": "Compression is unrelated."
      }
    }
  },
  {
    "id": "CH10-0087",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Transport Security",
    "subtopic": "HSTS",
    "difficulty": "Medium",
    "question": "What is the role of HSTS in API security?",
    "options": {
      "A": "Encrypt payloads",
      "B": "Force clients to use HTTPS only",
      "C": "Authenticate API consumers",
      "D": "Throttle requests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HSTS prevents downgrade attacks by enforcing HTTPS.",
      "incorrect": {
        "A": "Encryption is handled by TLS.",
        "C": "Authentication is separate.",
        "D": "Throttling is unrelated."
      }
    }
  },
  {
    "id": "CH10-0088",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "behavioral analysis",
    "difficulty": "Medium",
    "question": "Why is behavioral analysis useful for API security monitoring?",
    "options": {
      "A": "It replaces authentication",
      "B": "It detects deviations from normal usage patterns",
      "C": "It reduces logging volume",
      "D": "It encrypts traffic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Behavioral changes often signal misuse or compromise.",
      "incorrect": {
        "A": "Authentication is still required.",
        "C": "Logging remains essential.",
        "D": "Encryption is unrelated."
      }
    }
  },
  {
    "id": "CH10-0089",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret sprawl",
    "difficulty": "Medium",
    "question": "What risk does secret sprawl introduce?",
    "options": {
      "A": "Improved redundancy",
      "B": "Increased likelihood of credential leaks",
      "C": "Faster deployments",
      "D": "Simpler audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "More secrets in more places increase exposure risk.",
      "incorrect": {
        "A": "Redundancy is not the goal.",
        "C": "Deployment speed is unrelated.",
        "D": "Audits become harder."
      }
    }
  },
  {
    "id": "CH10-0090",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "data residency",
    "difficulty": "Medium",
    "question": "Why must APIs consider data residency requirements?",
    "options": {
      "A": "To improve latency",
      "B": "To comply with regional data protection laws",
      "C": "To simplify API design",
      "D": "To avoid encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Many regulations restrict where data can be stored or processed.",
      "incorrect": {
        "A": "Latency is secondary.",
        "C": "Design simplicity is unrelated.",
        "D": "Encryption is still required."
      }
    }
  },

  {
    "id": "CH10-0091",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "version exposure",
    "difficulty": "Medium",
    "question": "Why should APIs avoid exposing internal version details?",
    "options": {
      "A": "It increases payload size",
      "B": "It provides attackers with reconnaissance information",
      "C": "It breaks backward compatibility",
      "D": "It disables caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Version details can help attackers target known vulnerabilities.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Compatibility is unrelated.",
        "D": "Caching is unaffected."
      }
    }
  },
  {
    "id": "CH10-0092",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "id-based enumeration",
    "difficulty": "Hard",
    "question": "What risk arises from predictable numeric resource IDs?",
    "options": {
      "A": "Higher latency",
      "B": "Object enumeration attacks",
      "C": "Token expiration",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Attackers can guess IDs to access unauthorized resources.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Token expiration is unrelated.",
        "D": "Schemas do not control IDs."
      }
    }
  },
  {
    "id": "CH10-0093",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "security documentation",
    "difficulty": "Easy",
    "question": "Why should API security requirements be documented clearly?",
    "options": {
      "A": "To slow development",
      "B": "To ensure consistent and correct implementation",
      "C": "To replace testing",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear documentation reduces misconfiguration and misuse.",
      "incorrect": {
        "A": "Documentation improves efficiency.",
        "C": "Testing is still required.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0094",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Best Practices",
    "subtopic": "secure onboarding",
    "difficulty": "Easy",
    "question": "What is a secure practice when onboarding new API consumers?",
    "options": {
      "A": "Sharing credentials via email",
      "B": "Issuing scoped credentials with defined limits",
      "C": "Granting full access initially",
      "D": "Disabling logging temporarily"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scoped access limits potential misuse.",
      "incorrect": {
        "A": "Email is insecure for secrets.",
        "C": "Full access increases risk.",
        "D": "Logging must remain enabled."
      }
    }
  },
  {
    "id": "CH10-0095",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Testing",
    "subtopic": "fuzz testing",
    "difficulty": "Medium",
    "question": "What is the primary goal of fuzz testing APIs?",
    "options": {
      "A": "Validate correct responses",
      "B": "Identify crashes or unexpected behavior with malformed input",
      "C": "Improve performance",
      "D": "Reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fuzzing exposes robustness and input handling flaws.",
      "incorrect": {
        "A": "That is functional testing.",
        "C": "Performance is not the goal.",
        "D": "Payload size is irrelevant."
      }
    }
  },
  {
    "id": "CH10-0096",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Architecture",
    "subtopic": "defense boundaries",
    "difficulty": "Medium",
    "question": "Why should APIs enforce security at multiple architectural layers?",
    "options": {
      "A": "To reduce flexibility",
      "B": "To avoid single points of failure",
      "C": "To disable authentication",
      "D": "To reduce monitoring needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered enforcement ensures failures do not lead to compromise.",
      "incorrect": {
        "A": "Flexibility can be preserved.",
        "C": "Authentication remains mandatory.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0097",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "incident response",
    "difficulty": "Medium",
    "question": "What is the first priority during an API security incident?",
    "options": {
      "A": "Public communication",
      "B": "Containment of the threat",
      "C": "Root cause analysis",
      "D": "Postmortem documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stopping further damage is the immediate goal.",
      "incorrect": {
        "A": "Communication comes later.",
        "C": "Analysis follows containment.",
        "D": "Documentation is post-incident."
      }
    }
  },
  {
    "id": "CH10-0098",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "key rotation automation",
    "difficulty": "Medium",
    "question": "Why should key rotation be automated?",
    "options": {
      "A": "To reduce logging",
      "B": "To prevent human error and missed rotations",
      "C": "To increase payload size",
      "D": "To disable authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistency and reduces risk.",
      "incorrect": {
        "A": "Logging is unrelated.",
        "C": "Payload size is irrelevant.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH10-0099",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security awareness",
    "difficulty": "Easy",
    "question": "Why is developer security awareness critical for APIs?",
    "options": {
      "A": "Developers control only documentation",
      "B": "Most API vulnerabilities originate during development",
      "C": "Security teams handle all risks",
      "D": "Awareness reduces performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure coding practices prevent vulnerabilities early.",
      "incorrect": {
        "A": "Developers write core logic.",
        "C": "Security is shared responsibility.",
        "D": "Performance is unaffected."
      }
    }
  },
  {
    "id": "CH10-0100",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security maturity",
    "difficulty": "Easy",
    "question": "What best indicates a mature API security program?",
    "options": {
      "A": "Security applied only at the gateway",
      "B": "Continuous improvement with monitoring, testing, and governance",
      "C": "Manual reviews only",
      "D": "Disabling unused endpoints without validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity requires ongoing, layered, and measurable security practices.",
      "incorrect": {
        "A": "Single-layer security is insufficient.",
        "C": "Manual-only processes do not scale.",
        "D": "Validation is always required."
      }
    }
  },
  {
    "id": "CH10-0101",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "token binding",
    "difficulty": "Hard",
    "question": "What security benefit does token binding provide?",
    "options": {
      "A": "Faster token generation",
      "B": "Prevents token reuse from different clients",
      "C": "Longer token lifetimes",
      "D": "Payload encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Token binding ties tokens to a specific client context, preventing replay elsewhere.",
      "incorrect": {
        "A": "Generation speed is unrelated.",
        "C": "Lifetime is not increased.",
        "D": "Encryption is handled by TLS."
      }
    }
  },
  {
    "id": "CH10-0102",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "shared credentials",
    "difficulty": "Medium",
    "question": "Why should APIs avoid shared client credentials?",
    "options": {
      "A": "They reduce throughput",
      "B": "They eliminate accountability and traceability",
      "C": "They increase payload size",
      "D": "They break TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared credentials make it impossible to identify the source of misuse.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Payload size is irrelevant.",
        "D": "TLS remains intact."
      }
    }
  },
  {
    "id": "CH10-0103",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "context-aware authorization",
    "difficulty": "Hard",
    "question": "What is a key advantage of context-aware authorization?",
    "options": {
      "A": "Simpler API contracts",
      "B": "Decisions based on runtime conditions",
      "C": "Removal of authentication",
      "D": "Improved response formatting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Context such as location, time, or device strengthens access decisions.",
      "incorrect": {
        "A": "Contracts remain unchanged.",
        "C": "Authentication is still required.",
        "D": "Formatting is unrelated."
      }
    }
  },
  {
    "id": "CH10-0104",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "signature validation",
    "difficulty": "Medium",
    "question": "Why must JWT signatures always be validated?",
    "options": {
      "A": "To improve latency",
      "B": "To ensure the token was not tampered with",
      "C": "To encrypt the token",
      "D": "To refresh expiration time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Signature validation ensures integrity and trustworthiness of the token.",
      "incorrect": {
        "A": "Latency is not the purpose.",
        "C": "JWTs are signed, not encrypted by default.",
        "D": "Expiration cannot be refreshed this way."
      }
    }
  },
  {
    "id": "CH10-0105",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "issuer validation",
    "difficulty": "Medium",
    "question": "Why should APIs validate the issuer (iss) claim in JWTs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure tokens come from a trusted authority",
      "C": "To enable caching",
      "D": "To bypass rate limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Issuer validation prevents acceptance of forged tokens.",
      "incorrect": {
        "A": "Payload size is unaffected.",
        "C": "Caching is unrelated.",
        "D": "Rate limits still apply."
      }
    }
  },
  {
    "id": "CH10-0106",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy inheritance",
    "difficulty": "Medium",
    "question": "What risk arises from improper policy inheritance?",
    "options": {
      "A": "Excessive logging",
      "B": "Unintended access due to missing enforcement",
      "C": "Payload transformation errors",
      "D": "Reduced API availability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Incorrect inheritance may leave APIs unprotected.",
      "incorrect": {
        "A": "Logging volume is not the main risk.",
        "C": "Transformations are unrelated.",
        "D": "Availability is not directly affected."
      }
    }
  },
  {
    "id": "CH10-0107",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "custom policies",
    "difficulty": "Hard",
    "question": "When should custom security policies be created?",
    "options": {
      "A": "When standard policies already meet requirements",
      "B": "When business-specific enforcement is required",
      "C": "To replace authentication entirely",
      "D": "To simplify API design"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom policies address unique organizational security needs.",
      "incorrect": {
        "A": "Standard policies should be reused when possible.",
        "C": "Authentication remains mandatory.",
        "D": "Design simplicity is not the purpose."
      }
    }
  },
  {
    "id": "CH10-0108",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "command injection",
    "difficulty": "Hard",
    "question": "What is the primary cause of command injection vulnerabilities in APIs?",
    "options": {
      "A": "Strong input validation",
      "B": "Passing unsanitized input to system commands",
      "C": "Rate limiting",
      "D": "TLS misconfiguration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unsanitized input allows attackers to execute arbitrary commands.",
      "incorrect": {
        "A": "Strong validation prevents injection.",
        "C": "Rate limiting does not prevent injection.",
        "D": "TLS is unrelated."
      }
    }
  },
  {
    "id": "CH10-0109",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "business logic abuse",
    "difficulty": "Hard",
    "question": "Why are business logic vulnerabilities difficult to detect?",
    "options": {
      "A": "They violate schema rules",
      "B": "They exploit valid but unintended workflows",
      "C": "They rely on weak TLS",
      "D": "They cause syntax errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Requests appear legitimate but abuse application logic.",
      "incorrect": {
        "A": "Schemas may still be valid.",
        "C": "TLS is unrelated.",
        "D": "Syntax errors are not involved."
      }
    }
  },
  {
    "id": "CH10-0110",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "automation abuse",
    "difficulty": "Medium",
    "question": "What control best limits automated abuse of APIs?",
    "options": {
      "A": "CAPTCHA at every endpoint",
      "B": "Rate limiting combined with behavioral analysis",
      "C": "Payload compression",
      "D": "Schema evolution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation detection combined with limits reduces abuse.",
      "incorrect": {
        "A": "CAPTCHAs are not API-friendly.",
        "C": "Compression is unrelated.",
        "D": "Schemas do not limit automation."
      }
    }
  },

  {
    "id": "CH10-0111",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Transport Security",
    "subtopic": "cipher suites",
    "difficulty": "Medium",
    "question": "Why should weak cipher suites be disabled?",
    "options": {
      "A": "They reduce response size",
      "B": "They are vulnerable to cryptographic attacks",
      "C": "They break OAuth",
      "D": "They increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Weak ciphers can be exploited to decrypt traffic.",
      "incorrect": {
        "A": "Response size is unaffected.",
        "C": "OAuth is unrelated.",
        "D": "Throughput is not improved."
      }
    }
  },
  {
    "id": "CH10-0112",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "privilege escalation detection",
    "difficulty": "Hard",
    "question": "What behavior may indicate privilege escalation in APIs?",
    "options": {
      "A": "Requests from new IPs",
      "B": "Access to endpoints outside assigned scopes",
      "C": "Large response payloads",
      "D": "Slow response times"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Out-of-scope access suggests elevated privileges.",
      "incorrect": {
        "A": "IP changes alone are insufficient.",
        "C": "Payload size is unrelated.",
        "D": "Latency does not indicate escalation."
      }
    }
  },
  {
    "id": "CH10-0113",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "dynamic secrets",
    "difficulty": "Medium",
    "question": "What advantage do dynamic secrets provide?",
    "options": {
      "A": "Permanent access",
      "B": "Short-lived, automatically rotated credentials",
      "C": "Simpler API contracts",
      "D": "Reduced monitoring needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic secrets reduce long-term exposure.",
      "incorrect": {
        "A": "Permanent access increases risk.",
        "C": "Contracts are unaffected.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH10-0114",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "regulatory audits",
    "difficulty": "Medium",
    "question": "What evidence is most important during API security audits?",
    "options": {
      "A": "High throughput metrics",
      "B": "Access logs and policy enforcement records",
      "C": "Payload transformation rules",
      "D": "API response samples only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Auditors require proof of controlled access and enforcement.",
      "incorrect": {
        "A": "Throughput is not a security metric.",
        "C": "Transformations are secondary.",
        "D": "Samples alone are insufficient."
      }
    }
  },
  {
    "id": "CH10-0115",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure defaults",
    "difficulty": "Easy",
    "question": "Why should APIs default to the most restrictive security settings?",
    "options": {
      "A": "To reduce usability",
      "B": "To prevent accidental exposure",
      "C": "To slow development",
      "D": "To eliminate monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restrictive defaults reduce misconfiguration risks.",
      "incorrect": {
        "A": "Usability can be balanced.",
        "C": "Development speed is not the goal.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0116",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "fail secure",
    "difficulty": "Medium",
    "question": "What does fail-secure behavior mean for APIs?",
    "options": {
      "A": "Continuing operation without checks",
      "B": "Denying access when security mechanisms fail",
      "C": "Disabling logging",
      "D": "Returning partial data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fail-secure prevents unintended access during failures.",
      "incorrect": {
        "A": "Unchecked access is insecure.",
        "C": "Logging should remain active.",
        "D": "Partial data can leak information."
      }
    }
  },
  {
    "id": "CH10-0117",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "security alerts",
    "difficulty": "Medium",
    "question": "Why should security alerts be actionable?",
    "options": {
      "A": "To increase alert volume",
      "B": "To enable rapid response and remediation",
      "C": "To replace monitoring dashboards",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Actionable alerts reduce response time to incidents.",
      "incorrect": {
        "A": "Noise reduces effectiveness.",
        "C": "Dashboards are complementary.",
        "D": "Logging remains required."
      }
    }
  },
  {
    "id": "CH10-0118",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "post-incident review",
    "difficulty": "Medium",
    "question": "What is the primary goal of a post-incident security review?",
    "options": {
      "A": "Assign blame",
      "B": "Improve controls and prevent recurrence",
      "C": "Disable APIs",
      "D": "Reduce monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reviews strengthen defenses and processes.",
      "incorrect": {
        "A": "Blame does not improve security.",
        "C": "APIs should be improved, not disabled.",
        "D": "Monitoring is still needed."
      }
    }
  },
  {
    "id": "CH10-0119",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security training",
    "difficulty": "Easy",
    "question": "Why is continuous security training important for API teams?",
    "options": {
      "A": "Threats remain static",
      "B": "New vulnerabilities and attack patterns emerge",
      "C": "Training replaces testing",
      "D": "Training reduces code quality"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Evolving threats require updated knowledge.",
      "incorrect": {
        "A": "Threats constantly evolve.",
        "C": "Testing is still required.",
        "D": "Training improves quality."
      }
    }
  },
  {
    "id": "CH10-0120",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security by design",
    "difficulty": "Easy",
    "question": "What best describes security-by-design for APIs?",
    "options": {
      "A": "Adding security after deployment",
      "B": "Integrating security into architecture and development from the start",
      "C": "Relying only on firewalls",
      "D": "Disabling unused endpoints without review"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early integration reduces vulnerabilities and cost.",
      "incorrect": {
        "A": "Late security increases risk.",
        "C": "Firewalls alone are insufficient.",
        "D": "Review is always required."
      }
    }
  },
  {
    "id": "CH10-0121",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "machine-to-machine auth",
    "difficulty": "Medium",
    "question": "Which authentication approach is most suitable for machine-to-machine API communication?",
    "options": {
      "A": "Username and password",
      "B": "OAuth 2.0 client credentials grant",
      "C": "Browser-based implicit flow",
      "D": "Session cookies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client credentials grant is designed for non-human, system-to-system access.",
      "incorrect": {
        "A": "Passwords are not suitable for automated systems.",
        "C": "Implicit flow is browser-oriented.",
        "D": "Sessions are not appropriate for APIs."
      }
    }
  },
  {
    "id": "CH10-0122",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "credential scope",
    "difficulty": "Medium",
    "question": "Why should client credentials be scoped to specific APIs?",
    "options": {
      "A": "To improve latency",
      "B": "To reduce impact if credentials are compromised",
      "C": "To simplify logging",
      "D": "To remove the need for authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scoping limits how far compromised credentials can be misused.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Logging is unrelated.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH10-0123",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "resource-level authorization",
    "difficulty": "Hard",
    "question": "What must an API validate to prevent unauthorized access to specific resources?",
    "options": {
      "A": "Only token expiration",
      "B": "Ownership or permission for the requested resource",
      "C": "Request headers only",
      "D": "Payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authorization must verify the caller is allowed to access that specific resource.",
      "incorrect": {
        "A": "Expiration alone is insufficient.",
        "C": "Headers do not prove ownership.",
        "D": "Payload size is irrelevant."
      }
    }
  },
  {
    "id": "CH10-0124",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "horizontal privilege escalation",
    "difficulty": "Hard",
    "question": "What characterizes horizontal privilege escalation in APIs?",
    "options": {
      "A": "Accessing admin-only endpoints",
      "B": "Accessing another user's data with the same role",
      "C": "Executing system commands",
      "D": "Bypassing TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Attackers access peer-level data they do not own.",
      "incorrect": {
        "A": "That is vertical escalation.",
        "C": "That is command injection.",
        "D": "TLS is unrelated."
      }
    }
  },
  {
    "id": "CH10-0125",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token replay",
    "difficulty": "Medium",
    "question": "What condition enables token replay attacks?",
    "options": {
      "A": "Strong TLS enforcement",
      "B": "Long-lived tokens without binding",
      "C": "Short token expiration",
      "D": "Strict scope validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable tokens can be replayed if intercepted.",
      "incorrect": {
        "A": "TLS reduces interception risk.",
        "C": "Short expiration reduces replay window.",
        "D": "Scopes do not prevent replay."
      }
    }
  },
  {
    "id": "CH10-0126",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "clock skew",
    "difficulty": "Medium",
    "question": "Why should APIs allow small clock skew when validating tokens?",
    "options": {
      "A": "To extend token lifetime",
      "B": "To handle minor time differences between systems",
      "C": "To bypass expiration checks",
      "D": "To improve throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Distributed systems may have slight time differences.",
      "incorrect": {
        "A": "Lifetime should not be extended.",
        "C": "Expiration must still be enforced.",
        "D": "Throughput is unrelated."
      }
    }
  },
  {
    "id": "CH10-0127",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy enforcement point",
    "difficulty": "Medium",
    "question": "Where should API security policies ideally be enforced?",
    "options": {
      "A": "Only in backend services",
      "B": "At a centralized enforcement layer",
      "C": "Inside client applications",
      "D": "In database triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Centralized enforcement ensures consistency and control.",
      "incorrect": {
        "A": "Backend-only enforcement is risky.",
        "C": "Clients cannot be trusted.",
        "D": "Databases should not enforce API security."
      }
    }
  },
  {
    "id": "CH10-0128",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy drift",
    "difficulty": "Medium",
    "question": "What is policy drift in API security?",
    "options": {
      "A": "Policies applied too frequently",
      "B": "Inconsistent enforcement across environments",
      "C": "High API latency",
      "D": "Frequent token expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Different environments enforcing different rules create gaps.",
      "incorrect": {
        "A": "Frequency is not the issue.",
        "C": "Latency is unrelated.",
        "D": "Token expiration is separate."
      }
    }
  },
  {
    "id": "CH10-0129",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "payload size attacks",
    "difficulty": "Medium",
    "question": "Why should APIs enforce maximum payload size limits?",
    "options": {
      "A": "To improve response formatting",
      "B": "To prevent resource exhaustion attacks",
      "C": "To replace rate limiting",
      "D": "To disable encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Large payloads can overwhelm memory or processing resources.",
      "incorrect": {
        "A": "Formatting is unrelated.",
        "C": "Rate limiting serves a different purpose.",
        "D": "Encryption must remain enabled."
      }
    }
  },
  {
    "id": "CH10-0130",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "regex denial of service",
    "difficulty": "Hard",
    "question": "What causes Regular Expression Denial of Service (ReDoS)?",
    "options": {
      "A": "Weak TLS configuration",
      "B": "Inefficient regex patterns on user input",
      "C": "Missing authentication",
      "D": "Large response payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Certain regex patterns can cause excessive backtracking.",
      "incorrect": {
        "A": "TLS is unrelated.",
        "C": "Authentication does not affect regex processing.",
        "D": "Response size is unrelated."
      }
    }
  },

  {
    "id": "CH10-0131",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "baseline deviation",
    "difficulty": "Medium",
    "question": "What does a deviation from normal API usage patterns most likely indicate?",
    "options": {
      "A": "Schema evolution",
      "B": "Potential misuse or attack",
      "C": "Improved performance",
      "D": "Successful deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unexpected behavior often signals security issues.",
      "incorrect": {
        "A": "Schema changes do not cause usage spikes.",
        "C": "Performance gains do not change behavior patterns.",
        "D": "Deployments alone are insufficient explanation."
      }
    }
  },
  {
    "id": "CH10-0132",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "failed authorization",
    "difficulty": "Medium",
    "question": "Why should repeated authorization failures trigger alerts?",
    "options": {
      "A": "They increase payload size",
      "B": "They may indicate probing or privilege escalation attempts",
      "C": "They reduce throughput",
      "D": "They are expected behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Attackers often probe authorization boundaries.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Throughput is not the issue.",
        "D": "They require investigation."
      }
    }
  },
  {
    "id": "CH10-0133",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret lifecycle",
    "difficulty": "Medium",
    "question": "What is a critical phase in the lifecycle of API secrets?",
    "options": {
      "A": "Hardcoding",
      "B": "Rotation and revocation",
      "C": "Sharing across teams",
      "D": "Storing in logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Regular rotation and revocation reduce exposure risk.",
      "incorrect": {
        "A": "Hardcoding is insecure.",
        "C": "Sharing increases risk.",
        "D": "Logs are not secure storage."
      }
    }
  },
  {
    "id": "CH10-0134",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "blast radius",
    "difficulty": "Medium",
    "question": "How can organizations reduce the blast radius of leaked API secrets?",
    "options": {
      "A": "Using shared credentials",
      "B": "Limiting scope and permissions",
      "C": "Extending secret lifetime",
      "D": "Disabling logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Minimal permissions limit potential damage.",
      "incorrect": {
        "A": "Sharing increases blast radius.",
        "C": "Long lifetimes increase risk.",
        "D": "Logging should remain enabled."
      }
    }
  },
  {
    "id": "CH10-0135",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "data access logging",
    "difficulty": "Medium",
    "question": "Why is logging access to sensitive data critical?",
    "options": {
      "A": "To increase storage usage",
      "B": "To support audits and incident investigations",
      "C": "To improve performance",
      "D": "To replace authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logs provide traceability and accountability.",
      "incorrect": {
        "A": "Storage usage is not the goal.",
        "C": "Performance is unrelated.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0136",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "least privilege",
    "difficulty": "Easy",
    "question": "What does least privilege mean in API design?",
    "options": {
      "A": "Granting all permissions initially",
      "B": "Granting only the permissions required",
      "C": "Removing authorization checks",
      "D": "Disabling scopes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limiting permissions reduces security risk.",
      "incorrect": {
        "A": "This increases exposure.",
        "C": "Authorization is essential.",
        "D": "Scopes enforce least privilege."
      }
    }
  },
  {
    "id": "CH10-0137",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure error handling",
    "difficulty": "Medium",
    "question": "Why should APIs avoid detailed error messages in production?",
    "options": {
      "A": "They reduce performance",
      "B": "They may expose internal implementation details",
      "C": "They break clients",
      "D": "They disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Detailed errors can help attackers.",
      "incorrect": {
        "A": "Performance impact is negligible.",
        "C": "Clients can handle generic errors.",
        "D": "Monitoring remains active."
      }
    }
  },
  {
    "id": "CH10-0138",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "incident containment",
    "difficulty": "Medium",
    "question": "What is the primary objective during the containment phase of an API security incident?",
    "options": {
      "A": "Root cause analysis",
      "B": "Stopping further damage",
      "C": "Public communication",
      "D": "Documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Containment limits the impact of the incident.",
      "incorrect": {
        "A": "Analysis follows containment.",
        "C": "Communication comes later.",
        "D": "Documentation is post-incident."
      }
    }
  },
  {
    "id": "CH10-0139",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "security automation",
    "difficulty": "Medium",
    "question": "Why is automation critical for API security operations?",
    "options": {
      "A": "It removes the need for humans",
      "B": "It enables consistent and rapid response",
      "C": "It disables manual reviews",
      "D": "It reduces API traffic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation reduces reaction time and human error.",
      "incorrect": {
        "A": "Human oversight is still required.",
        "C": "Reviews remain important.",
        "D": "Traffic volume is unaffected."
      }
    }
  },
  {
    "id": "CH10-0140",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "shared responsibility",
    "difficulty": "Easy",
    "question": "Which statement best reflects API security ownership?",
    "options": {
      "A": "Security is handled only by security teams",
      "B": "Security is a shared responsibility across teams",
      "C": "Developers are not involved",
      "D": "Operations teams own all risks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security requires collaboration across roles.",
      "incorrect": {
        "A": "Security teams cannot work alone.",
        "C": "Developers play a critical role.",
        "D": "Operations alone is insufficient."
      }
    }
  },
  {
    "id": "CH10-0141",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security maturity",
    "difficulty": "Easy",
    "question": "What best indicates improving API security maturity?",
    "options": {
      "A": "One-time security review",
      "B": "Continuous monitoring, testing, and improvement",
      "C": "Disabling unused endpoints only",
      "D": "Manual enforcement of policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security maturity is iterative and continuous.",
      "incorrect": {
        "A": "One-time reviews are insufficient.",
        "C": "This alone is not enough.",
        "D": "Manual-only processes do not scale."
      }
    }
  },
  {
    "id": "CH10-0142",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security posture",
    "difficulty": "Easy",
    "question": "What defines a strong API security posture?",
    "options": {
      "A": "Relying on a single control",
      "B": "Layered controls with visibility and governance",
      "C": "Disabling error messages completely",
      "D": "Hardcoding secrets"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defense-in-depth and visibility ensure resilience.",
      "incorrect": {
        "A": "Single controls can fail.",
        "C": "Errors must still be handled safely.",
        "D": "Hardcoding is insecure."
      }
    }
  },
  {
    "id": "CH10-0143",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security lifecycle",
    "difficulty": "Easy",
    "question": "When should API security controls be reviewed?",
    "options": {
      "A": "Only during incidents",
      "B": "Continuously throughout the API lifecycle",
      "C": "Only before deployment",
      "D": "Only after audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ongoing review ensures controls remain effective.",
      "incorrect": {
        "A": "Reactive-only approaches are risky.",
        "C": "Pre-deployment review is not enough.",
        "D": "Audits are periodic."
      }
    }
  },
  {
    "id": "CH10-0144",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure evolution",
    "difficulty": "Easy",
    "question": "Why must API security evolve as APIs change?",
    "options": {
      "A": "APIs never change",
      "B": "New features introduce new attack surfaces",
      "C": "Security slows innovation",
      "D": "Monitoring replaces security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each change can introduce new risks.",
      "incorrect": {
        "A": "APIs evolve frequently.",
        "C": "Security enables safe innovation.",
        "D": "Monitoring is complementary."
      }
    }
  },
  {
    "id": "CH10-0145",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs",
    "difficulty": "Easy",
    "question": "What is the ultimate goal of API security?",
    "options": {
      "A": "Zero API usage",
      "B": "Protecting data, systems, and consumers",
      "C": "Eliminating all risks",
      "D": "Disabling public access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security balances protection with usability.",
      "incorrect": {
        "A": "APIs are meant to be used.",
        "C": "Zero risk is impossible.",
        "D": "Public APIs can still be secure."
      }
    }
  },
  {
    "id": "CH10-0146",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security trade-offs",
    "difficulty": "Easy",
    "question": "Why do API security decisions often involve trade-offs?",
    "options": {
      "A": "Security and usability must be balanced",
      "B": "Security removes performance concerns",
      "C": "Trade-offs are avoidable",
      "D": "Security disables flexibility entirely"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Effective security balances risk and usability.",
      "incorrect": {
        "B": "Performance must still be managed.",
        "C": "Trade-offs are inevitable.",
        "D": "Flexibility can still exist."
      }
    }
  },
  {
    "id": "CH10-0147",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term API security?",
    "options": {
      "A": "Security as a one-time task",
      "B": "Security as a continuous process",
      "C": "Security owned by tools",
      "D": "Security ignored until incidents"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Continuous attention is required as threats evolve.",
      "incorrect": {
        "A": "One-time efforts are insufficient.",
        "C": "Tools support but do not replace people.",
        "D": "Reactive security is risky."
      }
    }
  },
  {
    "id": "CH10-0148",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs summary",
    "difficulty": "Easy",
    "question": "Which combination best represents secure API design?",
    "options": {
      "A": "Authentication only",
      "B": "Authentication, authorization, monitoring, and governance",
      "C": "Encryption only",
      "D": "Logging only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security requires multiple coordinated controls.",
      "incorrect": {
        "A": "Authentication alone is insufficient.",
        "C": "Encryption alone does not control access.",
        "D": "Logging alone does not prevent attacks."
      }
    }
  },
  {
    "id": "CH10-0149",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure governance",
    "difficulty": "Easy",
    "question": "Why is governance important for API security?",
    "options": {
      "A": "It slows down teams",
      "B": "It ensures consistent security standards",
      "C": "It replaces enforcement",
      "D": "It removes monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance enforces consistency across APIs.",
      "incorrect": {
        "A": "Good governance enables speed safely.",
        "C": "Enforcement is still required.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0150",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure future",
    "difficulty": "Easy",
    "question": "What is the most effective long-term approach to API security?",
    "options": {
      "A": "Static controls",
      "B": "Adaptive security aligned with evolving threats",
      "C": "Manual reviews only",
      "D": "Disabling public APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Threats evolve, so security must adapt continuously.",
      "incorrect": {
        "A": "Static controls become outdated.",
        "C": "Manual-only processes do not scale.",
        "D": "Public APIs can still be secure."
      }
    }
  },
  {
    "id": "CH10-0151",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "token introspection",
    "difficulty": "Medium",
    "question": "What is the primary purpose of token introspection in API security?",
    "options": {
      "A": "Generate new access tokens",
      "B": "Validate token status and metadata at runtime",
      "C": "Encrypt request payloads",
      "D": "Extend token expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Introspection allows APIs to verify token validity and attributes dynamically.",
      "incorrect": {
        "A": "Token generation is handled by authorization servers.",
        "C": "Encryption is unrelated.",
        "D": "Expiration cannot be extended this way."
      }
    }
  },
  {
    "id": "CH10-0152",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "stateless auth",
    "difficulty": "Medium",
    "question": "Why is stateless authentication preferred for scalable APIs?",
    "options": {
      "A": "It removes the need for tokens",
      "B": "It avoids server-side session storage",
      "C": "It disables authorization checks",
      "D": "It reduces TLS overhead"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless auth scales better because servers do not maintain session state.",
      "incorrect": {
        "A": "Tokens are still required.",
        "C": "Authorization remains mandatory.",
        "D": "TLS overhead is unchanged."
      }
    }
  },
  {
    "id": "CH10-0153",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "endpoint-level authorization",
    "difficulty": "Medium",
    "question": "Why must authorization be enforced at the endpoint level?",
    "options": {
      "A": "To reduce API documentation",
      "B": "To prevent unauthorized access to specific operations",
      "C": "To improve payload formatting",
      "D": "To simplify routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Different endpoints may require different permissions.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Formatting is separate.",
        "D": "Routing does not enforce security."
      }
    }
  },
  {
    "id": "CH10-0154",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "vertical privilege escalation",
    "difficulty": "Hard",
    "question": "What defines vertical privilege escalation in an API?",
    "options": {
      "A": "Accessing peer user data",
      "B": "Accessing higher-privilege functionality",
      "C": "Replaying access tokens",
      "D": "Injecting commands"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Vertical escalation involves gaining access beyond assigned role privileges.",
      "incorrect": {
        "A": "That is horizontal escalation.",
        "C": "Token replay is separate.",
        "D": "Command injection is unrelated."
      }
    }
  },
  {
    "id": "CH10-0155",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token storage",
    "difficulty": "Medium",
    "question": "What is the most secure approach for storing access tokens on clients?",
    "options": {
      "A": "Local storage",
      "B": "Secure, platform-provided storage mechanisms",
      "C": "URL parameters",
      "D": "Application logs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure storage reduces risk of token theft.",
      "incorrect": {
        "A": "Local storage is vulnerable.",
        "C": "URLs expose tokens.",
        "D": "Logs are insecure."
      }
    }
  },
  {
    "id": "CH10-0156",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "refresh token abuse",
    "difficulty": "Hard",
    "question": "What risk arises if refresh tokens are long-lived and poorly protected?",
    "options": {
      "A": "Reduced throughput",
      "B": "Persistent unauthorized access",
      "C": "TLS downgrade attacks",
      "D": "Schema validation errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compromised refresh tokens allow continuous access.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "TLS is independent.",
        "D": "Schemas do not affect token abuse."
      }
    }
  },
  {
    "id": "CH10-0157",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy versioning",
    "difficulty": "Medium",
    "question": "Why is policy versioning important in API security?",
    "options": {
      "A": "To reduce payload size",
      "B": "To manage changes without breaking consumers",
      "C": "To disable old APIs automatically",
      "D": "To improve latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Versioning allows controlled evolution of security rules.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Disabling APIs is not automatic.",
        "D": "Latency is not the goal."
      }
    }
  },
  {
    "id": "CH10-0158",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "defense in depth",
    "difficulty": "Medium",
    "question": "What does defense-in-depth mean for API security?",
    "options": {
      "A": "Single strong security policy",
      "B": "Multiple complementary security controls",
      "C": "Disabling unused endpoints only",
      "D": "Relying solely on network firewalls"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered controls reduce risk if one control fails.",
      "incorrect": {
        "A": "Single controls are insufficient.",
        "C": "This alone is not enough.",
        "D": "Firewalls alone do not protect APIs."
      }
    }
  },
  {
    "id": "CH10-0159",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "rate abuse",
    "difficulty": "Medium",
    "question": "What behavior most commonly indicates rate abuse?",
    "options": {
      "A": "High request volume from a single consumer",
      "B": "Large response payloads",
      "C": "Frequent schema changes",
      "D": "Slow API responses"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Excessive requests often indicate abuse or automation.",
      "incorrect": {
        "B": "Payload size is unrelated.",
        "C": "Schemas do not affect rate.",
        "D": "Latency alone is not an indicator."
      }
    }
  },
  {
    "id": "CH10-0160",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "input boundary checks",
    "difficulty": "Medium",
    "question": "Why should APIs validate numeric input boundaries?",
    "options": {
      "A": "To improve formatting",
      "B": "To prevent overflow or logic abuse",
      "C": "To reduce logging",
      "D": "To disable caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Out-of-range values can trigger logic flaws or resource abuse.",
      "incorrect": {
        "A": "Formatting is unrelated.",
        "C": "Logging is still required.",
        "D": "Caching is unaffected."
      }
    }
  },

  {
    "id": "CH10-0161",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "response code trends",
    "difficulty": "Medium",
    "question": "Why should APIs monitor trends in HTTP response codes?",
    "options": {
      "A": "To optimize documentation",
      "B": "To detect failures or attack patterns",
      "C": "To reduce payload size",
      "D": "To bypass authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sudden increases in error codes may signal attacks or issues.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Payload size is not the concern.",
        "D": "Authentication remains enforced."
      }
    }
  },
  {
    "id": "CH10-0162",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "alert fatigue",
    "difficulty": "Medium",
    "question": "What is the risk of excessive security alerts?",
    "options": {
      "A": "Improved response time",
      "B": "Critical alerts being ignored",
      "C": "Reduced API throughput",
      "D": "Disabled logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too many alerts reduce effectiveness of response.",
      "incorrect": {
        "A": "Response time usually worsens.",
        "C": "Throughput is unrelated.",
        "D": "Logging remains active."
      }
    }
  },
  {
    "id": "CH10-0163",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "environment isolation",
    "difficulty": "Medium",
    "question": "Why must API secrets be isolated per environment?",
    "options": {
      "A": "To simplify debugging",
      "B": "To prevent cross-environment compromise",
      "C": "To improve latency",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation limits blast radius of leaked credentials.",
      "incorrect": {
        "A": "Debugging is unrelated.",
        "C": "Latency is unaffected.",
        "D": "Payload size is irrelevant."
      }
    }
  },
  {
    "id": "CH10-0164",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret access control",
    "difficulty": "Medium",
    "question": "Who should have access to API secrets?",
    "options": {
      "A": "All developers",
      "B": "Only systems and roles that require them",
      "C": "All API consumers",
      "D": "Operations teams only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Restricting access reduces exposure risk.",
      "incorrect": {
        "A": "Broad access increases risk.",
        "C": "Consumers must not see secrets.",
        "D": "Access depends on role, not team."
      }
    }
  },
  {
    "id": "CH10-0165",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "retention policies",
    "difficulty": "Medium",
    "question": "Why are log retention policies important for API security?",
    "options": {
      "A": "To increase storage usage",
      "B": "To balance forensic needs and compliance requirements",
      "C": "To reduce API traffic",
      "D": "To disable audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retention ensures logs are available when required by policy or law.",
      "incorrect": {
        "A": "Storage usage is not the goal.",
        "C": "Traffic is unaffected.",
        "D": "Audits remain mandatory."
      }
    }
  },
  {
    "id": "CH10-0166",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "default deny",
    "difficulty": "Medium",
    "question": "What does a default-deny security model enforce?",
    "options": {
      "A": "All access is allowed by default",
      "B": "Access is denied unless explicitly permitted",
      "C": "Authentication is optional",
      "D": "Monitoring is disabled"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Default-deny minimizes accidental exposure.",
      "incorrect": {
        "A": "This increases risk.",
        "C": "Authentication remains required.",
        "D": "Monitoring is still needed."
      }
    }
  },
  {
    "id": "CH10-0167",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure pagination",
    "difficulty": "Medium",
    "question": "Why should APIs cap maximum page sizes?",
    "options": {
      "A": "To reduce formatting effort",
      "B": "To prevent data scraping and resource abuse",
      "C": "To disable caching",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Large pages can expose excessive data and strain resources.",
      "incorrect": {
        "A": "Formatting is not the issue.",
        "C": "Caching is unrelated.",
        "D": "Authentication remains enforced."
      }
    }
  },
  {
    "id": "CH10-0168",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "incident escalation",
    "difficulty": "Medium",
    "question": "When should an API security incident be escalated?",
    "options": {
      "A": "Only after full root cause analysis",
      "B": "When impact exceeds predefined thresholds",
      "C": "Only during business hours",
      "D": "After public disclosure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Escalation ensures timely response to high-impact incidents.",
      "incorrect": {
        "A": "Analysis comes later.",
        "C": "Incidents can occur anytime.",
        "D": "Disclosure follows containment."
      }
    }
  },
  {
    "id": "CH10-0169",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "runbooks",
    "difficulty": "Medium",
    "question": "Why are incident response runbooks important for API security?",
    "options": {
      "A": "They eliminate incidents",
      "B": "They provide consistent response procedures",
      "C": "They replace monitoring",
      "D": "They reduce logging needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runbooks ensure predictable and efficient responses.",
      "incorrect": {
        "A": "Incidents cannot be eliminated entirely.",
        "C": "Monitoring is still required.",
        "D": "Logging remains essential."
      }
    }
  },
  {
    "id": "CH10-0170",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "secure coding",
    "difficulty": "Easy",
    "question": "Why is secure coding essential for API development?",
    "options": {
      "A": "It replaces testing",
      "B": "It prevents vulnerabilities at the source",
      "C": "It eliminates monitoring",
      "D": "It reduces documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Most vulnerabilities originate during development.",
      "incorrect": {
        "A": "Testing is still required.",
        "C": "Monitoring remains necessary.",
        "D": "Documentation is unaffected."
      }
    }
  },

  {
    "id": "CH10-0171",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security reviews",
    "difficulty": "Easy",
    "question": "Why should APIs undergo regular security reviews?",
    "options": {
      "A": "Threats never change",
      "B": "APIs and threats evolve over time",
      "C": "Reviews replace automation",
      "D": "Reviews slow innovation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Continuous review keeps security aligned with changes.",
      "incorrect": {
        "A": "Threats constantly evolve.",
        "C": "Automation complements reviews.",
        "D": "Security enables safe innovation."
      }
    }
  },
  {
    "id": "CH10-0172",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security visibility",
    "difficulty": "Easy",
    "question": "Why is visibility critical in API security?",
    "options": {
      "A": "It reduces API usage",
      "B": "It enables detection and response to threats",
      "C": "It disables authentication",
      "D": "It replaces governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "You cannot protect what you cannot see.",
      "incorrect": {
        "A": "Visibility does not reduce usage.",
        "C": "Authentication remains required.",
        "D": "Governance is still necessary."
      }
    }
  },
  {
    "id": "CH10-0173",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "continuous improvement",
    "difficulty": "Easy",
    "question": "What drives continuous improvement in API security?",
    "options": {
      "A": "Static controls",
      "B": "Feedback from monitoring, incidents, and reviews",
      "C": "One-time audits",
      "D": "Manual enforcement only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Feedback loops strengthen security over time.",
      "incorrect": {
        "A": "Static controls become outdated.",
        "C": "Audits are periodic.",
        "D": "Manual-only processes do not scale."
      }
    }
  },
  {
    "id": "CH10-0174",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "risk management",
    "difficulty": "Easy",
    "question": "What is the role of risk management in API security?",
    "options": {
      "A": "Eliminate all risks",
      "B": "Identify, prioritize, and mitigate risks",
      "C": "Disable APIs",
      "D": "Avoid innovation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Risk management balances protection and business needs.",
      "incorrect": {
        "A": "Zero risk is impossible.",
        "C": "APIs should remain usable.",
        "D": "Innovation must continue safely."
      }
    }
  },
  {
    "id": "CH10-0175",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure scaling",
    "difficulty": "Easy",
    "question": "Why must API security scale with usage growth?",
    "options": {
      "A": "Growth reduces risk",
      "B": "Higher usage increases attack surface",
      "C": "Scaling disables monitoring",
      "D": "Security becomes optional"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "More traffic and users increase exposure.",
      "incorrect": {
        "A": "Growth often increases risk.",
        "C": "Monitoring must scale too.",
        "D": "Security is never optional."
      }
    }
  },
  {
    "id": "CH10-0176",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs",
    "difficulty": "Easy",
    "question": "Which principle most directly improves long-term API security?",
    "options": {
      "A": "One-time hardening",
      "B": "Security built into design and operations",
      "C": "Manual reviews only",
      "D": "Disabling error messages"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrated security is more effective and sustainable.",
      "incorrect": {
        "A": "One-time efforts degrade over time.",
        "C": "Manual-only approaches do not scale.",
        "D": "Errors must still be handled safely."
      }
    }
  },
  {
    "id": "CH10-0177",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure collaboration",
    "difficulty": "Easy",
    "question": "Why is collaboration important for API security?",
    "options": {
      "A": "Security is owned by tools",
      "B": "Security spans development, operations, and governance",
      "C": "Collaboration reduces performance",
      "D": "Collaboration replaces automation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security effectiveness depends on cross-team alignment.",
      "incorrect": {
        "A": "Tools support but do not own security.",
        "C": "Performance is unaffected.",
        "D": "Automation is still required."
      }
    }
  },
  {
    "id": "CH10-0178",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure future",
    "difficulty": "Easy",
    "question": "What best prepares APIs for future security threats?",
    "options": {
      "A": "Static policies",
      "B": "Adaptive controls and continuous learning",
      "C": "Manual enforcement",
      "D": "Disabling public access"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Adaptability is essential as threats evolve.",
      "incorrect": {
        "A": "Static controls become obsolete.",
        "C": "Manual-only approaches do not scale.",
        "D": "Public APIs can still be secure."
      }
    }
  },
  {
    "id": "CH10-0179",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security responsibility",
    "difficulty": "Easy",
    "question": "Who is ultimately responsible for API security?",
    "options": {
      "A": "Security tools",
      "B": "Everyone involved in the API lifecycle",
      "C": "Operations teams only",
      "D": "External auditors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security is a shared responsibility across roles.",
      "incorrect": {
        "A": "Tools only assist.",
        "C": "Operations alone is insufficient.",
        "D": "Auditors do not own security."
      }
    }
  },
  {
    "id": "CH10-0180",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs conclusion",
    "difficulty": "Easy",
    "question": "What best summarizes effective API security?",
    "options": {
      "A": "Maximum restriction with minimal monitoring",
      "B": "Balanced protection, visibility, and continuous improvement",
      "C": "Encryption only",
      "D": "Manual controls only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security balances protection, usability, and evolution.",
      "incorrect": {
        "A": "Lack of visibility weakens security.",
        "C": "Encryption alone is insufficient.",
        "D": "Manual-only approaches do not scale."
      }
    }
  },
  {
    "id": "CH10-0181",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "mutual TLS",
    "difficulty": "Hard",
    "question": "What security benefit does mutual TLS (mTLS) provide for APIs?",
    "options": {
      "A": "Only the client is authenticated",
      "B": "Both client and server authenticate each other",
      "C": "Payload encryption without certificates",
      "D": "Token-less authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mTLS authenticates both parties, preventing unauthorized clients and rogue servers.",
      "incorrect": {
        "A": "Standard TLS authenticates only the server.",
        "C": "Certificates are mandatory.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH10-0182",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "certificate rotation",
    "difficulty": "Medium",
    "question": "Why is regular certificate rotation important for API security?",
    "options": {
      "A": "To improve response time",
      "B": "To limit the impact of compromised certificates",
      "C": "To reduce logging volume",
      "D": "To simplify routing logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short-lived certificates reduce long-term exposure if compromised.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Logging is unrelated.",
        "D": "Routing is independent."
      }
    }
  },
  {
    "id": "CH10-0183",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "scope explosion",
    "difficulty": "Medium",
    "question": "What risk does excessive use of authorization scopes introduce?",
    "options": {
      "A": "Improved access granularity",
      "B": "Increased misconfiguration and maintenance complexity",
      "C": "Stronger authentication",
      "D": "Lower monitoring overhead"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too many scopes are hard to manage and prone to errors.",
      "incorrect": {
        "A": "Granularity alone does not justify complexity.",
        "C": "Authentication strength is unaffected.",
        "D": "Monitoring becomes harder."
      }
    }
  },
  {
    "id": "CH10-0184",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "dynamic access control",
    "difficulty": "Hard",
    "question": "When is dynamic authorization preferable to static role-based access?",
    "options": {
      "A": "When access never changes",
      "B": "When decisions depend on runtime context",
      "C": "When APIs are internal only",
      "D": "When performance is the only concern"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic authorization adapts decisions using context like time or attributes.",
      "incorrect": {
        "A": "Static roles are sufficient there.",
        "C": "Internal APIs still need context-aware security.",
        "D": "Security should not be sacrificed for performance."
      }
    }
  },
  {
    "id": "CH10-0185",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token audience",
    "difficulty": "Medium",
    "question": "Why must APIs validate the audience (aud) claim in access tokens?",
    "options": {
      "A": "To reduce token size",
      "B": "To ensure the token was issued for that specific API",
      "C": "To enable caching",
      "D": "To bypass authorization checks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audience validation prevents token reuse across unintended APIs.",
      "incorrect": {
        "A": "Token size is irrelevant.",
        "C": "Caching is unrelated.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH10-0186",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token leakage",
    "difficulty": "Medium",
    "question": "Which practice most commonly leads to access token leakage?",
    "options": {
      "A": "Using HTTPS everywhere",
      "B": "Including tokens in URLs",
      "C": "Short token lifetimes",
      "D": "Strict scope validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "URLs may be logged or cached, exposing tokens.",
      "incorrect": {
        "A": "HTTPS reduces interception risk.",
        "C": "Short lifetimes reduce risk.",
        "D": "Scopes do not cause leakage."
      }
    }
  },
  {
    "id": "CH10-0187",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy ordering",
    "difficulty": "Medium",
    "question": "Why is the order of applied API policies important?",
    "options": {
      "A": "It affects request routing only",
      "B": "Some policies depend on outputs of earlier policies",
      "C": "It changes API versioning",
      "D": "It impacts TLS negotiation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Certain policies require authentication or context set by previous ones.",
      "incorrect": {
        "A": "Routing is not the only concern.",
        "C": "Versioning is unrelated.",
        "D": "TLS is handled separately."
      }
    }
  },
  {
    "id": "CH10-0188",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy testing",
    "difficulty": "Medium",
    "question": "Why should API security policies be tested regularly?",
    "options": {
      "A": "Policies never change",
      "B": "Misconfigurations can silently weaken security",
      "C": "Testing replaces monitoring",
      "D": "Policies slow down APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Testing ensures policies still enforce intended controls.",
      "incorrect": {
        "A": "Policies evolve with APIs.",
        "C": "Monitoring complements testing.",
        "D": "Performance is not the main concern."
      }
    }
  },
  {
    "id": "CH10-0189",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "mass assignment",
    "difficulty": "Hard",
    "question": "What causes mass assignment vulnerabilities in APIs?",
    "options": {
      "A": "Explicit field whitelisting",
      "B": "Binding client input directly to internal objects",
      "C": "Strong authentication",
      "D": "Short token lifetimes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Attackers can set unintended fields if input is blindly mapped.",
      "incorrect": {
        "A": "Whitelisting prevents this.",
        "C": "Authentication does not prevent it.",
        "D": "Token lifetime is unrelated."
      }
    }
  },
  {
    "id": "CH10-0190",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "batch abuse",
    "difficulty": "Medium",
    "question": "Why can batch API endpoints be attractive attack targets?",
    "options": {
      "A": "They reduce server load",
      "B": "They allow large-scale actions in a single request",
      "C": "They disable authentication",
      "D": "They bypass logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch operations can amplify the impact of abuse.",
      "incorrect": {
        "A": "They often increase load.",
        "C": "Authentication still applies.",
        "D": "Logging remains active."
      }
    }
  },

  {
    "id": "CH10-0191",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "latency anomalies",
    "difficulty": "Medium",
    "question": "Why can sudden latency spikes indicate a security issue?",
    "options": {
      "A": "Latency always indicates attacks",
      "B": "Attacks may exhaust resources or trigger expensive operations",
      "C": "Latency improves security",
      "D": "Latency affects only clients"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resource abuse or malicious payloads can slow processing.",
      "incorrect": {
        "A": "Latency can have many causes.",
        "C": "Latency does not improve security.",
        "D": "Servers are also impacted."
      }
    }
  },
  {
    "id": "CH10-0192",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "geo-anomalies",
    "difficulty": "Medium",
    "question": "What might API traffic from unexpected geographic regions indicate?",
    "options": {
      "A": "Successful scaling",
      "B": "Potential credential compromise",
      "C": "Improved availability",
      "D": "Schema changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Credentials may be used from attacker-controlled locations.",
      "incorrect": {
        "A": "Scaling does not change geography.",
        "C": "Availability is unrelated.",
        "D": "Schemas do not affect traffic origin."
      }
    }
  },
  {
    "id": "CH10-0193",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret auditing",
    "difficulty": "Medium",
    "question": "Why should access to API secrets be audited?",
    "options": {
      "A": "To reduce encryption overhead",
      "B": "To detect unauthorized or unusual access",
      "C": "To simplify deployments",
      "D": "To disable secret rotation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Auditing provides accountability and early detection.",
      "incorrect": {
        "A": "Encryption overhead is unaffected.",
        "C": "Deployments are unrelated.",
        "D": "Rotation remains essential."
      }
    }
  },
  {
    "id": "CH10-0194",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret injection",
    "difficulty": "Medium",
    "question": "What is the safest way to provide secrets to API runtimes?",
    "options": {
      "A": "Hardcoding them in source code",
      "B": "Injecting them at runtime from secure stores",
      "C": "Storing them in configuration files",
      "D": "Passing them as request headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runtime injection avoids source code and config exposure.",
      "incorrect": {
        "A": "Hardcoding is insecure.",
        "C": "Files can be leaked.",
        "D": "Headers are not for secrets."
      }
    }
  },
  {
    "id": "CH10-0195",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "data minimization",
    "difficulty": "Medium",
    "question": "Why is data minimization important for API security?",
    "options": {
      "A": "It increases response size",
      "B": "It reduces exposure of sensitive information",
      "C": "It disables caching",
      "D": "It removes authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Less exposed data means lower impact if compromised.",
      "incorrect": {
        "A": "Response size should be reduced.",
        "C": "Caching is unrelated.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH10-0196",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure defaults",
    "difficulty": "Easy",
    "question": "Why should APIs ship with secure defaults enabled?",
    "options": {
      "A": "To slow development",
      "B": "To prevent accidental insecure deployments",
      "C": "To reduce testing needs",
      "D": "To disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secure defaults reduce misconfiguration risks.",
      "incorrect": {
        "A": "Speed is not the goal.",
        "C": "Testing is still required.",
        "D": "Monitoring remains necessary."
      }
    }
  },
  {
    "id": "CH10-0197",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure caching",
    "difficulty": "Medium",
    "question": "What security risk can improper caching introduce?",
    "options": {
      "A": "Improved performance",
      "B": "Exposure of sensitive data to unauthorized users",
      "C": "Reduced availability",
      "D": "TLS downgrade"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cached sensitive responses may be served to wrong consumers.",
      "incorrect": {
        "A": "Performance is a benefit, not a risk.",
        "C": "Availability is unrelated.",
        "D": "TLS is unaffected."
      }
    }
  },
  {
    "id": "CH10-0198",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "change management",
    "difficulty": "Medium",
    "question": "Why should security controls be reviewed during API changes?",
    "options": {
      "A": "Changes never affect security",
      "B": "New functionality may introduce new risks",
      "C": "Reviews slow deployments",
      "D": "Automation replaces reviews"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Every change can alter the threat surface.",
      "incorrect": {
        "A": "Changes often affect security.",
        "C": "Security enables safe change.",
        "D": "Automation complements reviews."
      }
    }
  },
  {
    "id": "CH10-0199",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "security metrics",
    "difficulty": "Medium",
    "question": "Which metric best reflects API security effectiveness?",
    "options": {
      "A": "Number of endpoints",
      "B": "Time to detect and respond to incidents",
      "C": "Payload size",
      "D": "Request volume"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rapid detection and response limits damage.",
      "incorrect": {
        "A": "Endpoint count is irrelevant.",
        "C": "Payload size is not a security metric.",
        "D": "Volume alone is insufficient."
      }
    }
  },
  {
    "id": "CH10-0200",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security ownership",
    "difficulty": "Easy",
    "question": "Why should API teams take ownership of security?",
    "options": {
      "A": "Security teams are unnecessary",
      "B": "Teams building APIs best understand their risks",
      "C": "Ownership reduces performance",
      "D": "Ownership removes governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Builders are closest to design and implementation risks.",
      "incorrect": {
        "A": "Security teams still play a role.",
        "C": "Performance is unaffected.",
        "D": "Governance remains essential."
      }
    }
  },

  {
    "id": "CH10-0201",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security champions",
    "difficulty": "Easy",
    "question": "What is the role of security champions in API teams?",
    "options": {
      "A": "Replace security teams",
      "B": "Promote security best practices within teams",
      "C": "Disable automation",
      "D": "Approve all deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Champions bridge development and security practices.",
      "incorrect": {
        "A": "They complement security teams.",
        "C": "Automation remains valuable.",
        "D": "Approvals follow governance."
      }
    }
  },
  {
    "id": "CH10-0202",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security resilience",
    "difficulty": "Easy",
    "question": "What does resilience mean in API security?",
    "options": {
      "A": "Preventing all attacks",
      "B": "Withstanding and recovering from attacks",
      "C": "Disabling APIs during incidents",
      "D": "Avoiding public exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilient systems continue operating and recover quickly.",
      "incorrect": {
        "A": "Total prevention is unrealistic.",
        "C": "APIs should recover, not remain offline.",
        "D": "Public APIs can still be resilient."
      }
    }
  },
  {
    "id": "CH10-0203",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security tradeoffs",
    "difficulty": "Easy",
    "question": "Why are trade-offs unavoidable in API security?",
    "options": {
      "A": "Security conflicts with usability and performance",
      "B": "Security eliminates scalability",
      "C": "Trade-offs can be avoided",
      "D": "Security disables automation"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Security must balance protection, usability, and performance.",
      "incorrect": {
        "B": "Security can scale.",
        "C": "Trade-offs are inherent.",
        "D": "Automation supports security."
      }
    }
  },
  {
    "id": "CH10-0204",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure lifecycle",
    "difficulty": "Easy",
    "question": "At what stages should API security be applied?",
    "options": {
      "A": "Design only",
      "B": "Throughout the entire API lifecycle",
      "C": "After incidents",
      "D": "During audits only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security must be continuous from design to retirement.",
      "incorrect": {
        "A": "Design alone is insufficient.",
        "C": "Reactive security is risky.",
        "D": "Audits are periodic."
      }
    }
  },
  {
    "id": "CH10-0205",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs summary",
    "difficulty": "Easy",
    "question": "Which approach best summarizes effective API security?",
    "options": {
      "A": "Single-layer protection",
      "B": "Layered controls with continuous visibility",
      "C": "Encryption only",
      "D": "Manual enforcement only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defense-in-depth and visibility strengthen security.",
      "incorrect": {
        "A": "Single layers can fail.",
        "C": "Encryption alone is insufficient.",
        "D": "Manual-only approaches do not scale."
      }
    }
  },
  {
    "id": "CH10-0206",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security alignment",
    "difficulty": "Easy",
    "question": "Why must API security align with business objectives?",
    "options": {
      "A": "To eliminate governance",
      "B": "To enable secure innovation",
      "C": "To reduce API adoption",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security should support, not block, business goals.",
      "incorrect": {
        "A": "Governance remains necessary.",
        "C": "Security should not reduce adoption.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH10-0207",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security ownership culture",
    "difficulty": "Easy",
    "question": "What culture best supports long-term API security?",
    "options": {
      "A": "Security owned by a single team",
      "B": "Shared ownership across teams",
      "C": "Reactive security only",
      "D": "Tool-driven security only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared ownership ensures consistent security practices.",
      "incorrect": {
        "A": "Single-team ownership is insufficient.",
        "C": "Reactive approaches increase risk.",
        "D": "Tools alone are not enough."
      }
    }
  },
  {
    "id": "CH10-0208",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure future readiness",
    "difficulty": "Easy",
    "question": "What best prepares APIs for future security challenges?",
    "options": {
      "A": "Static configurations",
      "B": "Continuous learning and adaptive controls",
      "C": "Manual enforcement",
      "D": "Disabling public APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Adaptation is essential as threats evolve.",
      "incorrect": {
        "A": "Static controls become outdated.",
        "C": "Manual-only approaches do not scale.",
        "D": "Public APIs can still be secure."
      }
    }
  },
  {
    "id": "CH10-0209",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security success",
    "difficulty": "Easy",
    "question": "What is a key indicator of successful API security?",
    "options": {
      "A": "Zero API usage",
      "B": "Rapid detection and containment of incidents",
      "C": "No logging",
      "D": "Manual controls only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Quick response limits damage and downtime.",
      "incorrect": {
        "A": "APIs are meant to be used.",
        "C": "Logging is essential.",
        "D": "Manual-only controls are insufficient."
      }
    }
  },
  {
    "id": "CH10-0210",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security conclusion",
    "difficulty": "Easy",
    "question": "Which statement best concludes API security principles?",
    "options": {
      "A": "Security is optional for internal APIs",
      "B": "Security is an ongoing, shared responsibility",
      "C": "Security can be added later",
      "D": "Security tools eliminate human involvement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainable security requires continuous, shared effort.",
      "incorrect": {
        "A": "Internal APIs also need security.",
        "C": "Late security increases risk.",
        "D": "Humans remain essential."
      }
    }
  },
  {
    "id": "CH10-0211",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "certificate trust",
    "difficulty": "Medium",
    "question": "Why must API servers validate the certificate trust chain in mTLS?",
    "options": {
      "A": "To reduce TLS handshake time",
      "B": "To ensure the client certificate is issued by a trusted authority",
      "C": "To encrypt request payloads",
      "D": "To replace token-based authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validating the trust chain ensures certificates are issued by trusted CAs.",
      "incorrect": {
        "A": "Validation does not reduce handshake time.",
        "C": "Payload encryption is handled by TLS itself.",
        "D": "mTLS complements, not replaces, tokens."
      }
    }
  },
  {
    "id": "CH10-0212",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "credential revocation",
    "difficulty": "Medium",
    "question": "What is the primary challenge of revoking stateless JWT access tokens?",
    "options": {
      "A": "Token size increases",
      "B": "Tokens remain valid until expiration without additional checks",
      "C": "TLS must be reconfigured",
      "D": "Scopes cannot be validated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless tokens cannot be invalidated unless additional mechanisms are used.",
      "incorrect": {
        "A": "Size is unrelated.",
        "C": "TLS is independent.",
        "D": "Scopes are still validated."
      }
    }
  },
  {
    "id": "CH10-0213",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "object ownership",
    "difficulty": "Hard",
    "question": "Which check best prevents unauthorized access to user-owned resources?",
    "options": {
      "A": "Validating token expiration",
      "B": "Verifying resource ownership against caller identity",
      "C": "Applying rate limiting",
      "D": "Enforcing payload schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ownership checks ensure the caller is entitled to the specific resource.",
      "incorrect": {
        "A": "Expiration alone is insufficient.",
        "C": "Rate limits do not enforce ownership.",
        "D": "Schemas do not control access."
      }
    }
  },
  {
    "id": "CH10-0214",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "attribute-based access",
    "difficulty": "Hard",
    "question": "What distinguishes attribute-based access control (ABAC) from role-based access control?",
    "options": {
      "A": "ABAC ignores user identity",
      "B": "ABAC evaluates attributes at runtime",
      "C": "ABAC eliminates authorization policies",
      "D": "ABAC works only for internal APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ABAC uses dynamic attributes like user, resource, and context.",
      "incorrect": {
        "A": "Identity is still relevant.",
        "C": "Policies are still required.",
        "D": "ABAC applies to any API."
      }
    }
  },
  {
    "id": "CH10-0215",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token chaining",
    "difficulty": "Medium",
    "question": "What risk does improper token chaining introduce?",
    "options": {
      "A": "Reduced performance",
      "B": "Propagation of excessive privileges downstream",
      "C": "TLS downgrade",
      "D": "Schema validation failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Passing overly privileged tokens increases downstream exposure.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "TLS is unrelated.",
        "D": "Schemas do not control privileges."
      }
    }
  },
  {
    "id": "CH10-0216",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "proof of possession",
    "difficulty": "Hard",
    "question": "What security problem does proof-of-possession tokens address?",
    "options": {
      "A": "Token expiration",
      "B": "Token theft and replay",
      "C": "Authorization scope explosion",
      "D": "Certificate trust"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PoP tokens bind usage to possession of a cryptographic key.",
      "incorrect": {
        "A": "Expiration is unrelated.",
        "C": "Scopes are unaffected.",
        "D": "Certificate trust is separate."
      }
    }
  },
  {
    "id": "CH10-0217",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy bypass prevention",
    "difficulty": "Medium",
    "question": "What architectural practice best prevents API policy bypass?",
    "options": {
      "A": "Direct backend exposure",
      "B": "Enforcing all access through the API gateway",
      "C": "Client-side validation",
      "D": "Hardcoded credentials"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Centralized gateway enforcement ensures policies are always applied.",
      "incorrect": {
        "A": "Direct access bypasses policies.",
        "C": "Clients cannot be trusted.",
        "D": "Hardcoding is insecure."
      }
    }
  },
  {
    "id": "CH10-0218",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy rollback",
    "difficulty": "Medium",
    "question": "Why should API security policy changes support rollback?",
    "options": {
      "A": "To improve performance",
      "B": "To recover quickly from misconfigurations",
      "C": "To disable auditing",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback enables rapid recovery from faulty policy updates.",
      "incorrect": {
        "A": "Performance is not the goal.",
        "C": "Auditing remains required.",
        "D": "Testing is still necessary."
      }
    }
  },
  {
    "id": "CH10-0219",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "schema abuse",
    "difficulty": "Medium",
    "question": "How can attackers abuse permissive API schemas?",
    "options": {
      "A": "By reducing request size",
      "B": "By injecting unexpected fields or data types",
      "C": "By improving performance",
      "D": "By bypassing TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Permissive schemas allow unintended data to reach business logic.",
      "incorrect": {
        "A": "Attackers usually increase complexity.",
        "C": "Performance is unrelated.",
        "D": "TLS is unaffected."
      }
    }
  },
  {
    "id": "CH10-0220",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "recursive payloads",
    "difficulty": "Hard",
    "question": "Why are deeply nested or recursive payloads a security concern?",
    "options": {
      "A": "They reduce response size",
      "B": "They can exhaust stack or memory resources",
      "C": "They break authentication",
      "D": "They disable logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting can cause resource exhaustion or denial of service.",
      "incorrect": {
        "A": "They usually increase size.",
        "C": "Authentication is unaffected.",
        "D": "Logging remains enabled."
      }
    }
  },

  {
    "id": "CH10-0221",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "burst detection",
    "difficulty": "Medium",
    "question": "Why is burst traffic detection important for API security?",
    "options": {
      "A": "It improves API documentation",
      "B": "It helps identify sudden abuse or attacks",
      "C": "It disables rate limiting",
      "D": "It replaces authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sudden spikes often indicate automated abuse or attacks.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Rate limiting remains necessary.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0222",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "anomaly baselining",
    "difficulty": "Medium",
    "question": "Why is establishing a baseline of normal API behavior important?",
    "options": {
      "A": "To reduce storage costs",
      "B": "To detect deviations that may indicate attacks",
      "C": "To disable alerts",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Baselines allow abnormal patterns to be detected quickly.",
      "incorrect": {
        "A": "Storage is not the goal.",
        "C": "Alerts become more accurate, not disabled.",
        "D": "Testing is still required."
      }
    }
  },
  {
    "id": "CH10-0223",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret scoping",
    "difficulty": "Medium",
    "question": "Why should secrets be scoped to specific services or APIs?",
    "options": {
      "A": "To simplify sharing",
      "B": "To limit the blast radius of a compromise",
      "C": "To improve performance",
      "D": "To avoid encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scoped secrets reduce damage if leaked.",
      "incorrect": {
        "A": "Sharing increases risk.",
        "C": "Performance is unaffected.",
        "D": "Encryption remains required."
      }
    }
  },
  {
    "id": "CH10-0224",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret expiration",
    "difficulty": "Medium",
    "question": "What is the security advantage of expiring API secrets automatically?",
    "options": {
      "A": "Improved throughput",
      "B": "Reduced window of misuse if compromised",
      "C": "Simpler client configuration",
      "D": "Elimination of monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short lifetimes limit exposure of leaked secrets.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Clients must still handle rotation.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0225",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "access reviews",
    "difficulty": "Medium",
    "question": "Why are periodic access reviews required for API security compliance?",
    "options": {
      "A": "To increase user privileges",
      "B": "To ensure access remains appropriate over time",
      "C": "To disable authentication",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Roles and needs change, requiring revalidation of access.",
      "incorrect": {
        "A": "Privileges should be reduced when possible.",
        "C": "Authentication remains mandatory.",
        "D": "Logging remains required."
      }
    }
  },
  {
    "id": "CH10-0226",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure error codes",
    "difficulty": "Easy",
    "question": "Why should APIs standardize error responses?",
    "options": {
      "A": "To expose internal stack traces",
      "B": "To avoid leaking implementation details",
      "C": "To reduce latency",
      "D": "To disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standard errors prevent attackers from learning internals.",
      "incorrect": {
        "A": "Stack traces are unsafe.",
        "C": "Latency is unrelated.",
        "D": "Monitoring remains necessary."
      }
    }
  },
  {
    "id": "CH10-0227",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure defaults",
    "difficulty": "Easy",
    "question": "What is the benefit of disabling optional features by default?",
    "options": {
      "A": "Improved usability",
      "B": "Reduced attack surface",
      "C": "Higher performance",
      "D": "Simpler monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unused features can introduce vulnerabilities.",
      "incorrect": {
        "A": "Usability can still be preserved.",
        "C": "Performance is secondary.",
        "D": "Monitoring is unaffected."
      }
    }
  },
  {
    "id": "CH10-0228",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "security drills",
    "difficulty": "Medium",
    "question": "Why should API teams conduct regular security drills?",
    "options": {
      "A": "To simulate real incidents and improve response readiness",
      "B": "To reduce API traffic",
      "C": "To disable monitoring temporarily",
      "D": "To avoid audits"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Practice improves coordination and response speed.",
      "incorrect": {
        "B": "Traffic is unrelated.",
        "C": "Monitoring should remain active.",
        "D": "Audits are still required."
      }
    }
  },
  {
    "id": "CH10-0229",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "least privilege ops",
    "difficulty": "Medium",
    "question": "Why should operational access to APIs follow least privilege?",
    "options": {
      "A": "To simplify audits",
      "B": "To reduce accidental or malicious misuse",
      "C": "To improve response time",
      "D": "To eliminate logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limited access reduces potential damage.",
      "incorrect": {
        "A": "Audits benefit but are not the primary reason.",
        "C": "Response time is unaffected.",
        "D": "Logging remains required."
      }
    }
  },
  {
    "id": "CH10-0230",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security awareness",
    "difficulty": "Easy",
    "question": "Why is continuous security awareness training important?",
    "options": {
      "A": "Threats remain static",
      "B": "Human error is a common cause of breaches",
      "C": "Training replaces automation",
      "D": "Training slows delivery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Awareness reduces mistakes that lead to vulnerabilities.",
      "incorrect": {
        "A": "Threats constantly evolve.",
        "C": "Automation complements training.",
        "D": "Training enables safer delivery."
      }
    }
  },

  {
    "id": "CH10-0231",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security alignment",
    "difficulty": "Easy",
    "question": "Why should API security be aligned with enterprise security strategy?",
    "options": {
      "A": "To remove flexibility",
      "B": "To ensure consistent risk management",
      "C": "To avoid monitoring",
      "D": "To centralize development"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alignment ensures consistent controls and governance.",
      "incorrect": {
        "A": "Flexibility can still exist.",
        "C": "Monitoring remains essential.",
        "D": "Development remains decentralized."
      }
    }
  },
  {
    "id": "CH10-0232",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security success",
    "difficulty": "Easy",
    "question": "What best indicates effective API security implementation?",
    "options": {
      "A": "Zero API consumers",
      "B": "Early detection and controlled impact of incidents",
      "C": "Manual controls only",
      "D": "No logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security limits damage and downtime.",
      "incorrect": {
        "A": "APIs are meant to be used.",
        "C": "Manual-only approaches do not scale.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH10-0233",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security longevity",
    "difficulty": "Easy",
    "question": "What ensures API security remains effective over time?",
    "options": {
      "A": "Static rules",
      "B": "Continuous evaluation and improvement",
      "C": "One-time audits",
      "D": "Disabling public APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ongoing improvement keeps pace with evolving threats.",
      "incorrect": {
        "A": "Static rules become outdated.",
        "C": "Audits are periodic.",
        "D": "Public APIs can still be secure."
      }
    }
  },
  {
    "id": "CH10-0234",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security culture",
    "difficulty": "Easy",
    "question": "Which factor most strongly supports a strong API security culture?",
    "options": {
      "A": "Tools alone",
      "B": "Shared responsibility and accountability",
      "C": "Reactive controls",
      "D": "Minimal documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security culture depends on people and shared ownership.",
      "incorrect": {
        "A": "Tools support but do not create culture.",
        "C": "Reactive approaches increase risk.",
        "D": "Documentation remains important."
      }
    }
  },
  {
    "id": "CH10-0235",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security conclusion",
    "difficulty": "Easy",
    "question": "Which statement best concludes modern API security practices?",
    "options": {
      "A": "Security is optional for trusted consumers",
      "B": "Security is continuous, layered, and collaborative",
      "C": "Security ends at deployment",
      "D": "Security can be delegated entirely to tools"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modern security requires continuous and shared effort.",
      "incorrect": {
        "A": "Trust does not eliminate risk.",
        "C": "Security continues after deployment.",
        "D": "Tools assist but do not replace people."
      }
    }
  },
  {
    "id": "CH10-0241",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "api keys vs tokens",
    "difficulty": "Medium",
    "question": "Why are API keys generally considered less secure than OAuth access tokens?",
    "options": {
      "A": "API keys increase latency",
      "B": "API keys usually lack expiration and fine-grained scopes",
      "C": "API keys cannot be rotated",
      "D": "API keys break TLS"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API keys often have long lifetimes and limited contextual control compared to tokens.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "Keys can be rotated, but often are not.",
        "D": "TLS is independent."
      }
    }
  },
  {
    "id": "CH10-0242",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "client authentication",
    "difficulty": "Medium",
    "question": "What is the primary purpose of authenticating API clients?",
    "options": {
      "A": "To validate payload schemas",
      "B": "To identify the calling application",
      "C": "To encrypt traffic",
      "D": "To cache responses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client authentication establishes who is calling the API.",
      "incorrect": {
        "A": "Schemas validate structure, not identity.",
        "C": "Encryption is handled by TLS.",
        "D": "Caching is unrelated."
      }
    }
  },
  {
    "id": "CH10-0243",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "method-level access",
    "difficulty": "Medium",
    "question": "Why should APIs enforce authorization at the HTTP method level?",
    "options": {
      "A": "Different HTTP methods can represent different privileges",
      "B": "Methods affect TLS negotiation",
      "C": "Methods change token expiration",
      "D": "Methods control payload size"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "GET, POST, PUT, and DELETE often map to different permissions.",
      "incorrect": {
        "B": "TLS is unaffected.",
        "C": "Expiration is independent.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH10-0244",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "policy vs code",
    "difficulty": "Medium",
    "question": "Why is externalizing authorization logic into policies beneficial?",
    "options": {
      "A": "It removes the need for authentication",
      "B": "It allows centralized and consistent enforcement",
      "C": "It improves response formatting",
      "D": "It reduces payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policies enable uniform enforcement across multiple APIs.",
      "incorrect": {
        "A": "Authentication is still required.",
        "C": "Formatting is unrelated.",
        "D": "Payload size is unaffected."
      }
    }
  },
  {
    "id": "CH10-0245",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "short-lived tokens",
    "difficulty": "Medium",
    "question": "What is the main advantage of short-lived access tokens?",
    "options": {
      "A": "Reduced need for TLS",
      "B": "Limited impact if a token is compromised",
      "C": "Simpler client logic",
      "D": "Higher throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short lifetimes reduce the window of misuse.",
      "incorrect": {
        "A": "TLS is still required.",
        "C": "Client logic may become more complex.",
        "D": "Throughput is unaffected."
      }
    }
  },
  {
    "id": "CH10-0246",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token validation failure",
    "difficulty": "Medium",
    "question": "What should an API do when token validation fails?",
    "options": {
      "A": "Proceed with limited access",
      "B": "Reject the request with an appropriate error",
      "C": "Refresh the token automatically",
      "D": "Log and continue processing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Invalid tokens must result in request rejection.",
      "incorrect": {
        "A": "Limited access still poses risk.",
        "C": "APIs should not refresh tokens.",
        "D": "Processing must stop."
      }
    }
  },
  {
    "id": "CH10-0247",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "rate limiting strategy",
    "difficulty": "Medium",
    "question": "What is the primary goal of rate limiting policies?",
    "options": {
      "A": "Improve payload validation",
      "B": "Protect APIs from abuse and overload",
      "C": "Encrypt responses",
      "D": "Simplify client onboarding"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limiting prevents excessive or abusive traffic.",
      "incorrect": {
        "A": "Validation is separate.",
        "C": "Encryption is handled by TLS.",
        "D": "Onboarding is unrelated."
      }
    }
  },
  {
    "id": "CH10-0248",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "quota enforcement",
    "difficulty": "Medium",
    "question": "How do quotas differ from rate limits?",
    "options": {
      "A": "Quotas limit requests over a longer period",
      "B": "Quotas replace authentication",
      "C": "Quotas apply only to internal APIs",
      "D": "Quotas increase latency"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Quotas typically enforce usage over days or months.",
      "incorrect": {
        "B": "Authentication remains required.",
        "C": "Quotas can apply anywhere.",
        "D": "Latency is unaffected."
      }
    }
  },
  {
    "id": "CH10-0249",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "brute force detection",
    "difficulty": "Medium",
    "question": "What behavior most strongly indicates a brute-force attack?",
    "options": {
      "A": "High response times",
      "B": "Repeated failed authentication attempts",
      "C": "Large payload sizes",
      "D": "Frequent schema validation errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeated failures indicate credential guessing.",
      "incorrect": {
        "A": "Latency alone is insufficient.",
        "C": "Payload size is unrelated.",
        "D": "Schemas do not indicate brute force."
      }
    }
  },
  {
    "id": "CH10-0250",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "automation attacks",
    "difficulty": "Medium",
    "question": "Why are APIs attractive targets for automated attacks?",
    "options": {
      "A": "They require no authentication",
      "B": "They are predictable and machine-consumable",
      "C": "They disable logging",
      "D": "They enforce strong schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs are designed for automation, which attackers can exploit.",
      "incorrect": {
        "A": "Most APIs require authentication.",
        "C": "Logging is usually enabled.",
        "D": "Schemas do not prevent automation."
      }
    }
  },

  {
    "id": "CH10-0251",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "consumer behavior",
    "difficulty": "Medium",
    "question": "Why should APIs monitor behavior per consumer?",
    "options": {
      "A": "To improve response formatting",
      "B": "To detect abnormal usage patterns",
      "C": "To simplify routing",
      "D": "To disable quotas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Per-consumer baselines help identify misuse or compromise.",
      "incorrect": {
        "A": "Formatting is unrelated.",
        "C": "Routing is unaffected.",
        "D": "Quotas remain necessary."
      }
    }
  },
  {
    "id": "CH10-0252",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "failed request patterns",
    "difficulty": "Medium",
    "question": "What can a spike in failed requests indicate?",
    "options": {
      "A": "Successful deployment",
      "B": "Misuse, attack attempts, or configuration issues",
      "C": "Improved performance",
      "D": "Schema stability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Failures often signal attacks or misconfigurations.",
      "incorrect": {
        "A": "Deployments do not necessarily cause failures.",
        "C": "Performance is unrelated.",
        "D": "Schemas do not explain spikes."
      }
    }
  },
  {
    "id": "CH10-0253",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret distribution",
    "difficulty": "Medium",
    "question": "Why should API secrets never be shared via email or chat?",
    "options": {
      "A": "They increase payload size",
      "B": "These channels are often insecure and logged",
      "C": "They break encryption",
      "D": "They reduce API availability"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Insecure channels can leak secrets unintentionally.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Encryption is separate.",
        "D": "Availability is unaffected."
      }
    }
  },
  {
    "id": "CH10-0254",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret rotation automation",
    "difficulty": "Medium",
    "question": "Why is automated secret rotation preferred over manual rotation?",
    "options": {
      "A": "It removes the need for authentication",
      "B": "It reduces human error and missed rotations",
      "C": "It disables monitoring",
      "D": "It increases secret lifetime"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistency and timely rotation.",
      "incorrect": {
        "A": "Authentication remains required.",
        "C": "Monitoring is still needed.",
        "D": "Lifetimes are often shortened."
      }
    }
  },
  {
    "id": "CH10-0255",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "audit trails",
    "difficulty": "Medium",
    "question": "What is the purpose of maintaining audit trails for API access?",
    "options": {
      "A": "Improve API throughput",
      "B": "Support investigations and compliance requirements",
      "C": "Reduce logging costs",
      "D": "Replace authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audit trails provide traceability and accountability.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Costs are secondary.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0256",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure defaults",
    "difficulty": "Easy",
    "question": "What is the security advantage of denying access by default?",
    "options": {
      "A": "Improved usability",
      "B": "Reduced risk of accidental exposure",
      "C": "Higher performance",
      "D": "Simpler documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Default-deny prevents unintended access.",
      "incorrect": {
        "A": "Usability must be balanced.",
        "C": "Performance is secondary.",
        "D": "Documentation is unaffected."
      }
    }
  },
  {
    "id": "CH10-0257",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "input whitelisting",
    "difficulty": "Medium",
    "question": "Why is input whitelisting safer than blacklisting?",
    "options": {
      "A": "Whitelisting blocks only known attacks",
      "B": "Whitelisting allows only explicitly permitted values",
      "C": "Whitelisting improves performance",
      "D": "Whitelisting replaces validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Whitelisting minimizes unexpected input.",
      "incorrect": {
        "A": "It blocks unknown inputs too.",
        "C": "Performance is not the goal.",
        "D": "Validation is still required."
      }
    }
  },
  {
    "id": "CH10-0258",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "incident notification",
    "difficulty": "Medium",
    "question": "Why should incident notifications be timely?",
    "options": {
      "A": "To increase alert volume",
      "B": "To enable rapid containment and response",
      "C": "To reduce logging",
      "D": "To avoid audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Quick notification reduces impact and downtime.",
      "incorrect": {
        "A": "Noise reduces effectiveness.",
        "C": "Logging remains required.",
        "D": "Audits still occur."
      }
    }
  },
  {
    "id": "CH10-0259",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "access revocation",
    "difficulty": "Medium",
    "question": "When should API access be revoked immediately?",
    "options": {
      "A": "After successful audits",
      "B": "When credentials are suspected to be compromised",
      "C": "During peak traffic",
      "D": "After token expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immediate revocation limits further misuse.",
      "incorrect": {
        "A": "Audits do not require revocation.",
        "C": "Traffic level is irrelevant.",
        "D": "Waiting increases risk."
      }
    }
  },
  {
    "id": "CH10-0260",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security accountability",
    "difficulty": "Easy",
    "question": "Why is accountability important in API security practices?",
    "options": {
      "A": "It slows down development",
      "B": "It ensures ownership and follow-through on security actions",
      "C": "It removes the need for tools",
      "D": "It replaces governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership improves execution of security measures.",
      "incorrect": {
        "A": "Security enables safe speed.",
        "C": "Tools are still needed.",
        "D": "Governance remains essential."
      }
    }
  },

  {
    "id": "CH10-0261",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security balance",
    "difficulty": "Easy",
    "question": "Why must API security balance protection and usability?",
    "options": {
      "A": "Security should block all usage",
      "B": "Overly restrictive security can hinder adoption",
      "C": "Usability eliminates risk",
      "D": "Balance is unnecessary"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive restrictions can prevent legitimate use.",
      "incorrect": {
        "A": "APIs are meant to be consumed.",
        "C": "Usability does not remove risk.",
        "D": "Balance is essential."
      }
    }
  },
  {
    "id": "CH10-0262",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security metrics",
    "difficulty": "Easy",
    "question": "Which metric best reflects proactive API security?",
    "options": {
      "A": "Number of APIs",
      "B": "Time to detect suspicious activity",
      "C": "Payload size",
      "D": "Response formatting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early detection reduces damage.",
      "incorrect": {
        "A": "Count alone is meaningless.",
        "C": "Payload size is unrelated.",
        "D": "Formatting is irrelevant."
      }
    }
  },
  {
    "id": "CH10-0263",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security evolution",
    "difficulty": "Easy",
    "question": "Why must API security evolve continuously?",
    "options": {
      "A": "Threats and usage patterns change",
      "B": "APIs never change",
      "C": "Evolution reduces performance",
      "D": "Security tools are static"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Changing threats and APIs require adaptive security.",
      "incorrect": {
        "B": "APIs evolve frequently.",
        "C": "Security can scale efficiently.",
        "D": "Tools also evolve."
      }
    }
  },
  {
    "id": "CH10-0264",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "shared responsibility",
    "difficulty": "Easy",
    "question": "What best describes responsibility for API security?",
    "options": {
      "A": "Security team only",
      "B": "Shared across development, operations, and governance",
      "C": "External auditors",
      "D": "Automation tools"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security requires collaboration across roles.",
      "incorrect": {
        "A": "Single-team ownership is insufficient.",
        "C": "Auditors do not own security.",
        "D": "Tools assist but do not replace people."
      }
    }
  },
  {
    "id": "CH10-0265",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security resilience",
    "difficulty": "Easy",
    "question": "What is a key attribute of resilient API security?",
    "options": {
      "A": "Preventing all incidents",
      "B": "Detecting, responding, and recovering effectively",
      "C": "Disabling APIs on failure",
      "D": "Avoiding monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience focuses on response and recovery.",
      "incorrect": {
        "A": "Zero incidents is unrealistic.",
        "C": "APIs should recover, not stay offline.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH10-0266",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security governance",
    "difficulty": "Easy",
    "question": "Why is governance important in API security?",
    "options": {
      "A": "It slows innovation",
      "B": "It ensures consistent security standards",
      "C": "It removes enforcement",
      "D": "It replaces monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance enforces consistency and accountability.",
      "incorrect": {
        "A": "Good governance enables safe innovation.",
        "C": "Enforcement remains required.",
        "D": "Monitoring is still necessary."
      }
    }
  },
  {
    "id": "CH10-0267",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security readiness",
    "difficulty": "Easy",
    "question": "What best indicates API security readiness?",
    "options": {
      "A": "No alerts generated",
      "B": "Defined processes, tooling, and trained teams",
      "C": "Manual controls only",
      "D": "No public exposure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Preparedness depends on people, process, and tools.",
      "incorrect": {
        "A": "Lack of alerts may indicate blind spots.",
        "C": "Manual-only approaches do not scale.",
        "D": "Exposure alone is not a measure."
      }
    }
  },
  {
    "id": "CH10-0268",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security maturity",
    "difficulty": "Easy",
    "question": "What characterizes a mature API security program?",
    "options": {
      "A": "One-time controls",
      "B": "Continuous improvement driven by metrics and feedback",
      "C": "Disabling unused endpoints only",
      "D": "Tool-driven security only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity involves ongoing measurement and refinement.",
      "incorrect": {
        "A": "One-time efforts are insufficient.",
        "C": "This alone is not enough.",
        "D": "People and process are also required."
      }
    }
  },
  {
    "id": "CH10-0269",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure APIs summary",
    "difficulty": "Easy",
    "question": "Which combination best defines secure APIs?",
    "options": {
      "A": "Authentication only",
      "B": "Authentication, authorization, monitoring, and governance",
      "C": "Encryption only",
      "D": "Logging only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security requires multiple coordinated controls.",
      "incorrect": {
        "A": "Authentication alone is insufficient.",
        "C": "Encryption does not control access.",
        "D": "Logging alone does not prevent abuse."
      }
    }
  },
  {
    "id": "CH10-0270",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security conclusion",
    "difficulty": "Easy",
    "question": "What is the most important takeaway from API security best practices?",
    "options": {
      "A": "Security can be added later",
      "B": "Security is continuous and shared",
      "C": "Security is optional for trusted users",
      "D": "Security ends at deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security requires ongoing, collaborative effort.",
      "incorrect": {
        "A": "Late security increases risk.",
        "C": "Trust does not eliminate threats.",
        "D": "Security continues after deployment."
      }
    }
  },
  {
    "id": "CH10-0271",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "client secret misuse",
    "difficulty": "Medium",
    "question": "What is the primary risk of embedding client secrets in mobile or browser-based applications?",
    "options": {
      "A": "Increased latency",
      "B": "Secrets can be extracted and reused by attackers",
      "C": "TLS becomes ineffective",
      "D": "Tokens expire faster"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Public clients cannot securely store secrets, making extraction likely.",
      "incorrect": {
        "A": "Latency is unaffected.",
        "C": "TLS remains effective.",
        "D": "Expiration is unrelated."
      }
    }
  },
  {
    "id": "CH10-0272",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authentication",
    "subtopic": "confidential vs public clients",
    "difficulty": "Medium",
    "question": "What differentiates confidential clients from public clients in OAuth?",
    "options": {
      "A": "Confidential clients use HTTPS",
      "B": "Confidential clients can securely store credentials",
      "C": "Public clients cannot request tokens",
      "D": "Public clients bypass authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Confidential clients can safely hold secrets like client credentials.",
      "incorrect": {
        "A": "Both use HTTPS.",
        "C": "Public clients can request tokens.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH10-0273",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "resource-level checks",
    "difficulty": "Hard",
    "question": "Why are resource-level authorization checks critical even after successful authentication?",
    "options": {
      "A": "Authentication grants full access",
      "B": "Authenticated users may not own all resources",
      "C": "Authentication validates payloads",
      "D": "Authentication controls rate limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authentication confirms identity, not permission to specific resources.",
      "incorrect": {
        "A": "Authentication does not imply authorization.",
        "C": "Payload validation is separate.",
        "D": "Rate limits are independent."
      }
    }
  },
  {
    "id": "CH10-0274",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Authorization",
    "subtopic": "over-privileged roles",
    "difficulty": "Medium",
    "question": "What is a common risk of designing overly broad authorization roles?",
    "options": {
      "A": "Improved maintainability",
      "B": "Increased impact of compromised credentials",
      "C": "Reduced authentication complexity",
      "D": "Faster deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Over-privileged roles amplify damage if misused.",
      "incorrect": {
        "A": "Maintainability often decreases.",
        "C": "Authentication is unaffected.",
        "D": "Deployment speed is unrelated."
      }
    }
  },
  {
    "id": "CH10-0275",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "token binding",
    "difficulty": "Hard",
    "question": "What problem does token binding aim to mitigate?",
    "options": {
      "A": "Token expiration",
      "B": "Token replay from a different client",
      "C": "Scope misconfiguration",
      "D": "Certificate expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Token binding ties token usage to a specific client or channel.",
      "incorrect": {
        "A": "Expiration is separate.",
        "C": "Scopes are unaffected.",
        "D": "Certificates are unrelated."
      }
    }
  },
  {
    "id": "CH10-0276",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Token Security",
    "subtopic": "refresh token rotation",
    "difficulty": "Medium",
    "question": "Why is refresh token rotation recommended?",
    "options": {
      "A": "To reduce access token size",
      "B": "To detect and limit reuse of compromised refresh tokens",
      "C": "To disable token expiration",
      "D": "To simplify client implementation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation invalidates old refresh tokens if reused maliciously.",
      "incorrect": {
        "A": "Size is unaffected.",
        "C": "Expiration remains essential.",
        "D": "Clients may become more complex."
      }
    }
  },
  {
    "id": "CH10-0277",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "spike arrest",
    "difficulty": "Medium",
    "question": "What is the primary purpose of a spike arrest policy?",
    "options": {
      "A": "Block all traffic",
      "B": "Protect backends from sudden traffic surges",
      "C": "Encrypt request payloads",
      "D": "Validate schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Spike arrest smooths sudden bursts to protect downstream systems.",
      "incorrect": {
        "A": "Normal traffic must still flow.",
        "C": "Encryption is handled elsewhere.",
        "D": "Schema validation is separate."
      }
    }
  },
  {
    "id": "CH10-0278",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Policies",
    "subtopic": "policy misconfiguration",
    "difficulty": "Medium",
    "question": "What is a common consequence of misconfigured security policies?",
    "options": {
      "A": "Improved availability",
      "B": "Unintended access or denial of service",
      "C": "Reduced audit requirements",
      "D": "Automatic remediation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Misconfigurations can open access or block legitimate users.",
      "incorrect": {
        "A": "Availability often suffers.",
        "C": "Audits remain required.",
        "D": "Manual intervention is usually needed."
      }
    }
  },
  {
    "id": "CH10-0279",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "credential stuffing",
    "difficulty": "Hard",
    "question": "What distinguishes credential stuffing attacks from brute-force attacks?",
    "options": {
      "A": "They guess passwords randomly",
      "B": "They use leaked credential pairs from other breaches",
      "C": "They require no automation",
      "D": "They bypass authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Credential stuffing reuses known username-password combinations.",
      "incorrect": {
        "A": "Random guessing is brute force.",
        "C": "Automation is common.",
        "D": "Authentication is still targeted."
      }
    }
  },
  {
    "id": "CH10-0280",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Threat Protection",
    "subtopic": "business logic abuse",
    "difficulty": "Hard",
    "question": "Why is business logic abuse difficult to detect with traditional security controls?",
    "options": {
      "A": "It uses invalid payloads",
      "B": "It exploits valid functionality in unintended ways",
      "C": "It bypasses TLS",
      "D": "It disables logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Requests appear legitimate but are used maliciously.",
      "incorrect": {
        "A": "Payloads are usually valid.",
        "C": "TLS remains intact.",
        "D": "Logging still works."
      }
    }
  },

  {
    "id": "CH10-0281",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "baseline drift",
    "difficulty": "Medium",
    "question": "What does baseline drift indicate in API monitoring?",
    "options": {
      "A": "Stable traffic patterns",
      "B": "Gradual change in normal behavior over time",
      "C": "Immediate security breach",
      "D": "Improved performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Baselines must be updated as usage patterns evolve.",
      "incorrect": {
        "A": "Drift implies change.",
        "C": "Drift is not always malicious.",
        "D": "Performance may or may not improve."
      }
    }
  },
  {
    "id": "CH10-0282",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Monitoring",
    "subtopic": "false positives",
    "difficulty": "Medium",
    "question": "Why are excessive false positives harmful in API security monitoring?",
    "options": {
      "A": "They increase throughput",
      "B": "They reduce trust in alerts and slow response",
      "C": "They disable logging",
      "D": "They improve detection accuracy"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alert fatigue causes real threats to be missed.",
      "incorrect": {
        "A": "Throughput is unaffected.",
        "C": "Logging continues.",
        "D": "Accuracy decreases."
      }
    }
  },
  {
    "id": "CH10-0283",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret reuse",
    "difficulty": "Medium",
    "question": "Why should the same secret not be reused across multiple APIs?",
    "options": {
      "A": "It increases latency",
      "B": "It expands the impact of a single compromise",
      "C": "It breaks encryption",
      "D": "It simplifies rotation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compromise of one secret affects all systems using it.",
      "incorrect": {
        "A": "Latency is unrelated.",
        "C": "Encryption remains intact.",
        "D": "Rotation becomes harder."
      }
    }
  },
  {
    "id": "CH10-0284",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Secrets Management",
    "subtopic": "secret access logs",
    "difficulty": "Medium",
    "question": "Why should access to secrets be logged?",
    "options": {
      "A": "To reduce secret usage",
      "B": "To provide traceability and detect misuse",
      "C": "To improve performance",
      "D": "To replace encryption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logs support audits and incident investigations.",
      "incorrect": {
        "A": "Usage reduction is not the goal.",
        "C": "Performance is unaffected.",
        "D": "Encryption is still required."
      }
    }
  },
  {
    "id": "CH10-0285",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Compliance",
    "subtopic": "least data exposure",
    "difficulty": "Medium",
    "question": "How does limiting response fields support compliance requirements?",
    "options": {
      "A": "By increasing response size",
      "B": "By minimizing exposure of regulated data",
      "C": "By disabling audits",
      "D": "By improving routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only necessary data should be exposed to consumers.",
      "incorrect": {
        "A": "Responses should be smaller.",
        "C": "Audits remain mandatory.",
        "D": "Routing is unrelated."
      }
    }
  },
  {
    "id": "CH10-0286",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure pagination",
    "difficulty": "Medium",
    "question": "Why should APIs enforce upper limits on pagination parameters?",
    "options": {
      "A": "To reduce documentation",
      "B": "To prevent data scraping and resource exhaustion",
      "C": "To disable caching",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unbounded pagination can expose excessive data or strain systems.",
      "incorrect": {
        "A": "Documentation is unaffected.",
        "C": "Caching is unrelated.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH10-0287",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Design",
    "subtopic": "secure identifiers",
    "difficulty": "Hard",
    "question": "Why are sequential numeric identifiers risky in public APIs?",
    "options": {
      "A": "They reduce performance",
      "B": "They enable resource enumeration attacks",
      "C": "They break authorization",
      "D": "They disable logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable IDs allow attackers to guess other resources.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Authorization may still exist but is stressed.",
        "D": "Logging remains active."
      }
    }
  },
  {
    "id": "CH10-0288",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "incident postmortems",
    "difficulty": "Medium",
    "question": "Why are post-incident reviews important after API security incidents?",
    "options": {
      "A": "To assign blame",
      "B": "To identify root causes and prevent recurrence",
      "C": "To disable affected APIs permanently",
      "D": "To reduce monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Postmortems improve future resilience.",
      "incorrect": {
        "A": "Blame reduces learning.",
        "C": "APIs should recover.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH10-0289",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Operations",
    "subtopic": "access reviews ops",
    "difficulty": "Medium",
    "question": "Why should operational access to APIs be reviewed periodically?",
    "options": {
      "A": "To increase privileges",
      "B": "To remove unnecessary or outdated access",
      "C": "To simplify tooling",
      "D": "To disable authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Access should reflect current roles and responsibilities.",
      "incorrect": {
        "A": "Privileges should be minimized.",
        "C": "Tooling is secondary.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH10-0290",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Culture",
    "subtopic": "security by design",
    "difficulty": "Easy",
    "question": "What does \"security by design\" emphasize in API development?",
    "options": {
      "A": "Adding security after deployment",
      "B": "Incorporating security considerations from the start",
      "C": "Relying solely on gateways",
      "D": "Avoiding documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early security reduces costly fixes later.",
      "incorrect": {
        "A": "Late security increases risk.",
        "C": "Gateways alone are insufficient.",
        "D": "Documentation remains important."
      }
    }
  },

  {
    "id": "CH10-0291",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "defense in depth",
    "difficulty": "Easy",
    "question": "Why is defense-in-depth essential for API security?",
    "options": {
      "A": "Single controls never fail",
      "B": "Multiple layers reduce the chance of total compromise",
      "C": "It removes the need for monitoring",
      "D": "It simplifies implementation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered controls compensate for individual failures.",
      "incorrect": {
        "A": "Controls can fail.",
        "C": "Monitoring remains essential.",
        "D": "Security may become more complex."
      }
    }
  },
  {
    "id": "CH10-0292",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security adaptability",
    "difficulty": "Easy",
    "question": "Why must API security controls be adaptable?",
    "options": {
      "A": "APIs never change",
      "B": "Threats and usage patterns evolve",
      "C": "Adaptability reduces performance",
      "D": "Controls should remain static"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Evolving threats require evolving defenses.",
      "incorrect": {
        "A": "APIs frequently change.",
        "C": "Adaptability can scale efficiently.",
        "D": "Static controls become obsolete."
      }
    }
  },
  {
    "id": "CH10-0293",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security ownership",
    "difficulty": "Easy",
    "question": "Who shares responsibility for maintaining API security?",
    "options": {
      "A": "Security team only",
      "B": "Developers, operations, and governance teams",
      "C": "External vendors",
      "D": "Automation tools"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Effective security requires shared responsibility.",
      "incorrect": {
        "A": "One team alone is insufficient.",
        "C": "Vendors do not own security.",
        "D": "Tools assist but do not replace people."
      }
    }
  },
  {
    "id": "CH10-0294",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security maturity",
    "difficulty": "Easy",
    "question": "What indicates a mature API security posture?",
    "options": {
      "A": "One-time security reviews",
      "B": "Continuous measurement and improvement",
      "C": "No alerts",
      "D": "Manual enforcement only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity involves ongoing assessment and refinement.",
      "incorrect": {
        "A": "One-time reviews are insufficient.",
        "C": "Lack of alerts may indicate blind spots.",
        "D": "Manual-only approaches do not scale."
      }
    }
  },
  {
    "id": "CH10-0295",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security enablement",
    "difficulty": "Easy",
    "question": "How should API security support business goals?",
    "options": {
      "A": "By blocking innovation",
      "B": "By enabling safe and scalable API usage",
      "C": "By disabling public APIs",
      "D": "By reducing monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Good security enables, not blocks, business growth.",
      "incorrect": {
        "A": "Security should not block innovation.",
        "C": "Public APIs can be secure.",
        "D": "Monitoring remains critical."
      }
    }
  },
  {
    "id": "CH10-0296",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security consistency",
    "difficulty": "Easy",
    "question": "Why is consistency important in API security controls?",
    "options": {
      "A": "It reduces usability",
      "B": "It prevents gaps caused by uneven enforcement",
      "C": "It increases complexity",
      "D": "It replaces audits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inconsistent controls create exploitable gaps.",
      "incorrect": {
        "A": "Usability can still be preserved.",
        "C": "Consistency often reduces complexity.",
        "D": "Audits are still required."
      }
    }
  },
  {
    "id": "CH10-0297",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "secure evolution",
    "difficulty": "Easy",
    "question": "What should accompany API evolution to maintain security?",
    "options": {
      "A": "Ignoring old versions",
      "B": "Regular reassessment of risks and controls",
      "C": "Removing monitoring",
      "D": "Manual testing only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Changes introduce new risks that must be reassessed.",
      "incorrect": {
        "A": "Old versions may still be used.",
        "C": "Monitoring remains essential.",
        "D": "Automation should complement testing."
      }
    }
  },
  {
    "id": "CH10-0298",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security resilience",
    "difficulty": "Easy",
    "question": "What best defines resilient API security?",
    "options": {
      "A": "No incidents ever occur",
      "B": "Incidents are detected, contained, and recovered from quickly",
      "C": "APIs are shut down on attack",
      "D": "Security relies on tools only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilience focuses on response and recovery.",
      "incorrect": {
        "A": "Zero incidents is unrealistic.",
        "C": "APIs should recover, not stay offline.",
        "D": "People and processes remain critical."
      }
    }
  },
  {
    "id": "CH10-0299",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security summary",
    "difficulty": "Easy",
    "question": "Which elements together form a strong API security foundation?",
    "options": {
      "A": "Authentication only",
      "B": "Authentication, authorization, monitoring, and governance",
      "C": "Encryption only",
      "D": "Logging only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security requires multiple coordinated controls.",
      "incorrect": {
        "A": "Authentication alone is insufficient.",
        "C": "Encryption does not enforce access.",
        "D": "Logging alone does not prevent attacks."
      }
    }
  },
  {
    "id": "CH10-0300",
    "chapter": 10,
    "chapterTitle": "API Security",
    "topic": "Final Concepts",
    "subtopic": "security conclusion",
    "difficulty": "Easy",
    "question": "What is the most accurate conclusion about API security?",
    "options": {
      "A": "Security can be postponed",
      "B": "Security is continuous, shared, and evolving",
      "C": "Security applies only to public APIs",
      "D": "Security ends after deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modern API security is ongoing and collaborative.",
      "incorrect": {
        "A": "Delaying security increases risk.",
        "C": "Internal APIs also require security.",
        "D": "Security continues throughout the lifecycle."
      }
    }
  }
]
