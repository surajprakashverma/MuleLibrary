[
  {
    "id": "CH12-0001",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Fundamentals",
    "subtopic": "salesforce integration purpose",
    "difficulty": "Easy",
    "question": "Why is Salesforce commonly integrated with MuleSoft?",
    "options": {
      "A": "To replace Salesforce APIs",
      "B": "To connect Salesforce with external systems reliably",
      "C": "To deploy Salesforce metadata",
      "D": "To manage Salesforce licenses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "MuleSoft acts as an integration layer to connect Salesforce with external systems and services.",
      "incorrect": {
        "A": "APIs are still used, not replaced.",
        "C": "Metadata deployment is handled by Salesforce tools.",
        "D": "License management is unrelated."
      }
    }
  },
  {
    "id": "CH12-0002",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Fundamentals",
    "subtopic": "api-led approach",
    "difficulty": "Medium",
    "question": "Which API layer typically exposes Salesforce data to consuming applications?",
    "options": {
      "A": "System API",
      "B": "Process API",
      "C": "Experience API",
      "D": "Transport API"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "System APIs abstract Salesforce and expose its data securely and consistently.",
      "incorrect": {
        "B": "Process APIs orchestrate business logic.",
        "C": "Experience APIs tailor data for consumers.",
        "D": "Transport API is not an API-led layer."
      }
    }
  },
  {
    "id": "CH12-0003",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce APIs",
    "subtopic": "api types",
    "difficulty": "Easy",
    "question": "Which Salesforce API is most commonly used for CRUD operations?",
    "options": {
      "A": "Metadata API",
      "B": "REST API",
      "C": "Tooling API",
      "D": "Bulk API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The REST API is optimized for standard create, read, update, and delete operations.",
      "incorrect": {
        "A": "Metadata API manages configuration.",
        "C": "Tooling API supports development tools.",
        "D": "Bulk API is optimized for large data volumes."
      }
    }
  },
  {
    "id": "CH12-0004",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce APIs",
    "subtopic": "bulk api usage",
    "difficulty": "Medium",
    "question": "When should the Salesforce Bulk API be preferred?",
    "options": {
      "A": "Real-time UI requests",
      "B": "Large-volume asynchronous data loads",
      "C": "Metadata retrieval",
      "D": "Single-record updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk API is designed for high-volume, asynchronous data processing.",
      "incorrect": {
        "A": "Bulk API is not real-time.",
        "C": "Metadata is handled separately.",
        "D": "Single-record updates are inefficient with Bulk API."
      }
    }
  },
  {
    "id": "CH12-0005",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "oauth usage",
    "difficulty": "Medium",
    "question": "Which authentication mechanism is recommended for Salesforce integrations?",
    "options": {
      "A": "Basic authentication",
      "B": "OAuth 2.0",
      "C": "API key only",
      "D": "IP whitelisting only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "OAuth 2.0 provides secure, token-based access and is Salesforce-recommended.",
      "incorrect": {
        "A": "Basic auth is deprecated and insecure.",
        "C": "API keys alone are insufficient.",
        "D": "IP whitelisting is not authentication."
      }
    }
  },
  {
    "id": "CH12-0006",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Connector",
    "subtopic": "connector role",
    "difficulty": "Easy",
    "question": "What is the primary role of the Salesforce connector in MuleSoft?",
    "options": {
      "A": "Deploy Salesforce applications",
      "B": "Simplify interaction with Salesforce APIs",
      "C": "Manage Salesforce users",
      "D": "Monitor Salesforce performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The connector abstracts Salesforce API complexity for Mule developers.",
      "incorrect": {
        "A": "Deployment is not its function.",
        "C": "User management is outside scope.",
        "D": "Monitoring is handled separately."
      }
    }
  },
  {
    "id": "CH12-0007",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Connector",
    "subtopic": "operation selection",
    "difficulty": "Medium",
    "question": "Which connector operation retrieves a Salesforce record by ID?",
    "options": {
      "A": "Create",
      "B": "Update",
      "C": "Retrieve",
      "D": "Upsert"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Retrieve fetches a record using its Salesforce ID.",
      "incorrect": {
        "A": "Create inserts a new record.",
        "B": "Update modifies an existing record.",
        "D": "Upsert creates or updates based on external ID."
      }
    }
  },
  {
    "id": "CH12-0008",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Mapping",
    "subtopic": "field mapping",
    "difficulty": "Medium",
    "question": "Why is explicit field mapping important in Salesforce integrations?",
    "options": {
      "A": "To reduce API calls",
      "B": "To ensure correct data alignment between systems",
      "C": "To improve OAuth security",
      "D": "To enable metadata deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct mapping prevents data corruption and logic errors.",
      "incorrect": {
        "A": "API calls are unaffected.",
        "C": "Security is unrelated.",
        "D": "Metadata deployment is separate."
      }
    }
  },
  {
    "id": "CH12-0009",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Upsert Logic",
    "subtopic": "external id",
    "difficulty": "Medium",
    "question": "What is required to perform an upsert operation in Salesforce?",
    "options": {
      "A": "Record ID",
      "B": "External ID field",
      "C": "Metadata permission",
      "D": "Bulk API only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Upsert relies on an external ID to decide create vs update.",
      "incorrect": {
        "A": "Record ID is not mandatory.",
        "C": "Metadata permission is unrelated.",
        "D": "Upsert is not limited to Bulk API."
      }
    }
  },
  {
    "id": "CH12-0010",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "partial success",
    "difficulty": "Hard",
    "question": "Why must partial success be handled explicitly in Salesforce bulk operations?",
    "options": {
      "A": "Bulk operations never fail",
      "B": "Some records may succeed while others fail",
      "C": "Bulk API retries automatically",
      "D": "Salesforce ignores invalid records"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk operations can succeed partially, requiring granular error handling.",
      "incorrect": {
        "A": "Failures can occur.",
        "C": "Retries must be managed explicitly.",
        "D": "Invalid records are rejected."
      }
    }
  },
  {
    "id": "CH12-0011",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce APIs",
    "subtopic": "soap api usage",
    "difficulty": "Medium",
    "question": "When is the Salesforce SOAP API typically preferred over the REST API?",
    "options": {
      "A": "For lightweight mobile applications",
      "B": "For strongly typed, contract-driven integrations",
      "C": "For large asynchronous data loads",
      "D": "For metadata deployment only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SOAP API provides a strongly typed WSDL contract, useful for strict enterprise integrations.",
      "incorrect": {
        "A": "REST is better for lightweight use cases.",
        "C": "Bulk API suits large data loads.",
        "D": "Metadata API handles metadata deployment."
      }
    }
  },
  {
    "id": "CH12-0012",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce APIs",
    "subtopic": "streaming api",
    "difficulty": "Medium",
    "question": "What is the primary purpose of the Salesforce Streaming API?",
    "options": {
      "A": "Bulk record insertion",
      "B": "Real-time event notifications",
      "C": "Metadata updates",
      "D": "User authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming API enables near real-time event-driven integrations.",
      "incorrect": {
        "A": "Bulk API handles mass data.",
        "C": "Metadata API is separate.",
        "D": "Authentication is handled via OAuth."
      }
    }
  },
  {
    "id": "CH12-0013",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce APIs",
    "subtopic": "change data capture",
    "difficulty": "Medium",
    "question": "What does Change Data Capture (CDC) primarily provide?",
    "options": {
      "A": "Batch data extraction",
      "B": "Notifications of data changes in Salesforce",
      "C": "User access control",
      "D": "Metadata synchronization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CDC publishes events when Salesforce data changes.",
      "incorrect": {
        "A": "Batch extraction uses Bulk API.",
        "C": "Access control is unrelated.",
        "D": "Metadata sync is handled elsewhere."
      }
    }
  },
  {
    "id": "CH12-0014",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "jwt bearer flow",
    "difficulty": "Hard",
    "question": "Why is the JWT Bearer OAuth flow commonly used in server-to-server Salesforce integrations?",
    "options": {
      "A": "It requires user interaction",
      "B": "It enables secure, headless authentication",
      "C": "It avoids token expiration",
      "D": "It replaces API permissions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "JWT Bearer flow supports secure authentication without user interaction.",
      "incorrect": {
        "A": "User interaction is not required.",
        "C": "Tokens still expire.",
        "D": "Permissions are still enforced."
      }
    }
  },
  {
    "id": "CH12-0015",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "token refresh",
    "difficulty": "Medium",
    "question": "Why is refresh token handling important in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To maintain uninterrupted access when tokens expire",
      "C": "To bypass authentication",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Access tokens expire and must be refreshed to avoid failures.",
      "incorrect": {
        "A": "API limits are unaffected.",
        "C": "Authentication cannot be bypassed.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH12-0016",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Rate Limits",
    "subtopic": "api throttling",
    "difficulty": "Medium",
    "question": "What happens when Salesforce API rate limits are exceeded?",
    "options": {
      "A": "Requests are queued automatically",
      "B": "Requests are rejected with errors",
      "C": "Salesforce increases limits dynamically",
      "D": "Only write operations fail"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exceeding limits results in rejected API calls.",
      "incorrect": {
        "A": "Requests are not queued.",
        "C": "Limits are fixed.",
        "D": "All operations can fail."
      }
    }
  },
  {
    "id": "CH12-0017",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Rate Limits",
    "subtopic": "limit mitigation",
    "difficulty": "Hard",
    "question": "Which strategy best helps mitigate Salesforce API rate limit issues?",
    "options": {
      "A": "Increasing payload size",
      "B": "Using caching and batching",
      "C": "Reducing OAuth scopes",
      "D": "Disabling retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Caching and batching reduce the number of API calls.",
      "incorrect": {
        "A": "Payload size does not reduce calls.",
        "C": "Scopes affect access, not limits.",
        "D": "Retries may worsen the issue."
      }
    }
  },
  {
    "id": "CH12-0018",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "eventual consistency",
    "difficulty": "Medium",
    "question": "Why must eventual consistency be considered in Salesforce integrations?",
    "options": {
      "A": "Salesforce updates are always synchronous",
      "B": "Data may not be immediately available across systems",
      "C": "Salesforce guarantees immediate consistency",
      "D": "Bulk API enforces consistency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Distributed systems may take time to reflect updates everywhere.",
      "incorrect": {
        "A": "Many operations are asynchronous.",
        "C": "Immediate consistency is not guaranteed.",
        "D": "Bulk API does not enforce consistency."
      }
    }
  },
  {
    "id": "CH12-0019",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "idempotency",
    "difficulty": "Hard",
    "question": "Why is idempotency important in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To prevent duplicate records during retries",
      "C": "To reduce authentication overhead",
      "D": "To improve UI responsiveness"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent operations avoid duplicates when requests are retried.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Authentication remains unchanged.",
        "D": "UI responsiveness is unrelated."
      }
    }
  },
  {
    "id": "CH12-0020",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "external id usage",
    "difficulty": "Medium",
    "question": "How do external IDs help maintain data consistency?",
    "options": {
      "A": "They increase API limits",
      "B": "They uniquely identify records across systems",
      "C": "They replace Salesforce IDs",
      "D": "They encrypt record data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External IDs align records between Salesforce and external systems.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Salesforce IDs still exist.",
        "D": "Encryption is unrelated."
      }
    }
  },
  {
    "id": "CH12-0021",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "fault responses",
    "difficulty": "Medium",
    "question": "Why should Salesforce fault responses be parsed explicitly?",
    "options": {
      "A": "They are always generic",
      "B": "They provide detailed error context",
      "C": "They replace success responses",
      "D": "They improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fault responses contain valuable diagnostic information.",
      "incorrect": {
        "A": "They often contain specifics.",
        "C": "They occur only on failure.",
        "D": "Performance is unaffected."
      }
    }
  },
  {
    "id": "CH12-0022",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "retry strategy",
    "difficulty": "Hard",
    "question": "When should retries be avoided in Salesforce integrations?",
    "options": {
      "A": "When errors are transient",
      "B": "When errors indicate invalid data",
      "C": "When network latency is high",
      "D": "When using Bulk API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retrying invalid data errors will always fail.",
      "incorrect": {
        "A": "Transient errors often benefit from retries.",
        "C": "Latency alone does not block retries.",
        "D": "Bulk API can still use retries."
      }
    }
  },
  {
    "id": "CH12-0023",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Connector Configuration",
    "subtopic": "environment separation",
    "difficulty": "Medium",
    "question": "Why should separate Salesforce orgs be used for different environments?",
    "options": {
      "A": "To increase API limits",
      "B": "To isolate data and configuration changes",
      "C": "To reduce connector configuration",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Environment separation prevents unintended data or config impact.",
      "incorrect": {
        "A": "Limits are org-specific.",
        "C": "Configuration still exists.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH12-0024",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Connector Configuration",
    "subtopic": "sandbox usage",
    "difficulty": "Easy",
    "question": "Why are Salesforce sandboxes preferred for testing integrations?",
    "options": {
      "A": "They have higher API limits",
      "B": "They protect production data",
      "C": "They eliminate authentication",
      "D": "They improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sandboxes allow safe testing without affecting production data.",
      "incorrect": {
        "A": "Limits may be lower.",
        "C": "Authentication is still required.",
        "D": "Performance is not the goal."
      }
    }
  },
  {
    "id": "CH12-0025",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance",
    "subtopic": "bulk vs rest",
    "difficulty": "Medium",
    "question": "Why does Bulk API generally perform better for large data volumes?",
    "options": {
      "A": "It uses synchronous processing",
      "B": "It processes data asynchronously in batches",
      "C": "It avoids authentication",
      "D": "It ignores validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch-based asynchronous processing improves throughput.",
      "incorrect": {
        "A": "Bulk API is asynchronous.",
        "C": "Authentication still applies.",
        "D": "Validation still occurs."
      }
    }
  },
  {
    "id": "CH12-0026",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance",
    "subtopic": "parallelism",
    "difficulty": "Hard",
    "question": "What risk does excessive parallelism pose in Salesforce integrations?",
    "options": {
      "A": "Lower latency",
      "B": "API limit exhaustion",
      "C": "Improved reliability",
      "D": "Simpler error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Too many concurrent calls can exceed API limits.",
      "incorrect": {
        "A": "Latency may worsen.",
        "C": "Reliability may degrade.",
        "D": "Error handling becomes harder."
      }
    }
  },
  {
    "id": "CH12-0027",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "least privilege",
    "difficulty": "Medium",
    "question": "Why should Salesforce integration users follow the principle of least privilege?",
    "options": {
      "A": "To increase API limits",
      "B": "To minimize security risk",
      "C": "To improve performance",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limiting permissions reduces potential impact of breaches.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Performance is unaffected.",
        "D": "Mappings are unrelated."
      }
    }
  },
  {
    "id": "CH12-0028",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "credential rotation",
    "difficulty": "Medium",
    "question": "Why is credential rotation important for Salesforce integrations?",
    "options": {
      "A": "To improve API speed",
      "B": "To reduce the risk of compromised credentials",
      "C": "To avoid OAuth usage",
      "D": "To increase data consistency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Regular rotation limits the damage of leaked credentials.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "OAuth remains required.",
        "D": "Consistency is unaffected."
      }
    }
  },
  {
    "id": "CH12-0029",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "integration visibility",
    "difficulty": "Easy",
    "question": "Why is monitoring critical for Salesforce integrations?",
    "options": {
      "A": "To eliminate errors",
      "B": "To detect failures and performance issues early",
      "C": "To reduce API usage",
      "D": "To simplify deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Monitoring enables proactive issue detection.",
      "incorrect": {
        "A": "Errors can still occur.",
        "C": "Usage is not directly reduced.",
        "D": "Deployment is separate."
      }
    }
  },
  {
    "id": "CH12-0030",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "failure alerts",
    "difficulty": "Easy",
    "question": "What is the main benefit of alerting on integration failures?",
    "options": {
      "A": "Reduced code complexity",
      "B": "Faster incident response",
      "C": "Higher API limits",
      "D": "Improved data mapping"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alerts enable rapid investigation and resolution.",
      "incorrect": {
        "A": "Code complexity is unaffected.",
        "C": "Limits are unchanged.",
        "D": "Mapping is unrelated."
      }
    }
  },
  {
    "id": "CH12-0031",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Design Patterns",
    "subtopic": "system api abstraction",
    "difficulty": "Medium",
    "question": "Why should Salesforce access be abstracted behind a System API?",
    "options": {
      "A": "To increase API limits",
      "B": "To decouple consumers from Salesforce specifics",
      "C": "To improve OAuth performance",
      "D": "To simplify deployment pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Abstraction isolates consumers from backend changes.",
      "incorrect": {
        "A": "Limits remain unchanged.",
        "C": "OAuth behavior is unaffected.",
        "D": "Deployment is separate."
      }
    }
  },
  {
    "id": "CH12-0032",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Design Patterns",
    "subtopic": "process orchestration",
    "difficulty": "Medium",
    "question": "What role does a Process API play in Salesforce integrations?",
    "options": {
      "A": "Direct database access",
      "B": "Business logic orchestration across systems",
      "C": "User interface delivery",
      "D": "Metadata synchronization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Process APIs coordinate workflows across multiple systems.",
      "incorrect": {
        "A": "Databases are not accessed directly.",
        "C": "UI delivery is not its role.",
        "D": "Metadata sync is separate."
      }
    }
  },
  {
    "id": "CH12-0033",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Design Patterns",
    "subtopic": "experience api usage",
    "difficulty": "Medium",
    "question": "When should an Experience API be introduced in Salesforce integrations?",
    "options": {
      "A": "When exposing raw Salesforce objects",
      "B": "When tailoring data for specific consumers",
      "C": "When handling authentication",
      "D": "When performing bulk loads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Experience APIs adapt data to consumer needs.",
      "incorrect": {
        "A": "Raw exposure increases coupling.",
        "C": "Authentication is separate.",
        "D": "Bulk loads use different patterns."
      }
    }
  },
  {
    "id": "CH12-0034",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "configuration externalization",
    "difficulty": "Easy",
    "question": "Why should Salesforce connection details be externalized?",
    "options": {
      "A": "To reduce payload size",
      "B": "To support multiple environments safely",
      "C": "To improve API limits",
      "D": "To avoid OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Externalization allows environment-specific configuration.",
      "incorrect": {
        "A": "Payload size is unaffected.",
        "C": "Limits remain unchanged.",
        "D": "OAuth is still required."
      }
    }
  },
  {
    "id": "CH12-0035",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "promotion strategy",
    "difficulty": "Medium",
    "question": "What is the safest way to promote Salesforce integrations across environments?",
    "options": {
      "A": "Direct production deployment",
      "B": "Progressive promotion through environments",
      "C": "Manual code changes per environment",
      "D": "Disabling tests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Progressive promotion reduces deployment risk.",
      "incorrect": {
        "A": "Direct production changes are risky.",
        "C": "Manual changes cause inconsistency.",
        "D": "Tests must remain enabled."
      }
    }
  },
  {
    "id": "CH12-0036",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "mocking salesforce",
    "difficulty": "Medium",
    "question": "Why should Salesforce interactions be mocked during unit testing?",
    "options": {
      "A": "To increase API limits",
      "B": "To isolate tests from external dependencies",
      "C": "To bypass authentication",
      "D": "To reduce code coverage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mocking ensures deterministic and reliable tests.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Authentication behavior should still be validated logically.",
        "D": "Coverage should remain meaningful."
      }
    }
  },
  {
    "id": "CH12-0037",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "sandbox testing",
    "difficulty": "Easy",
    "question": "Why are sandboxes used for integration testing?",
    "options": {
      "A": "They remove API limits",
      "B": "They provide a safe environment for validation",
      "C": "They eliminate OAuth",
      "D": "They improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sandboxes protect production data while testing.",
      "incorrect": {
        "A": "Limits still apply.",
        "C": "OAuth remains required.",
        "D": "Performance is not the goal."
      }
    }
  },
  {
    "id": "CH12-0038",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "retry with backoff",
    "difficulty": "Hard",
    "question": "Why should exponential backoff be used for retries?",
    "options": {
      "A": "To increase retry frequency",
      "B": "To reduce pressure on Salesforce during failures",
      "C": "To avoid authentication",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backoff prevents overwhelming Salesforce during outages.",
      "incorrect": {
        "A": "Retry frequency should decrease, not increase.",
        "C": "Authentication is unrelated.",
        "D": "Mappings are unrelated."
      }
    }
  },
  {
    "id": "CH12-0039",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "circuit breaker",
    "difficulty": "Hard",
    "question": "What is the primary purpose of a circuit breaker in Salesforce integrations?",
    "options": {
      "A": "Improve throughput",
      "B": "Prevent repeated calls to a failing system",
      "C": "Increase API limits",
      "D": "Simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers protect systems during downstream failures.",
      "incorrect": {
        "A": "Throughput may temporarily decrease.",
        "C": "Limits remain unchanged.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH12-0040",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Best Practices",
    "subtopic": "integration ownership",
    "difficulty": "Easy",
    "question": "What is a key best practice for long-term Salesforce integration success?",
    "options": {
      "A": "Treat integrations as one-time builds",
      "B": "Assign clear ownership and governance",
      "C": "Disable monitoring",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership ensures maintainability and accountability.",
      "incorrect": {
        "A": "Integrations require ongoing care.",
        "C": "Monitoring is essential.",
        "D": "Documentation remains important."
      }
    }
  },
  {
    "id": "CH12-0041",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Connector",
    "subtopic": "query operation",
    "difficulty": "Easy",
    "question": "Which Salesforce connector operation is used to execute SOQL queries?",
    "options": {
      "A": "Search",
      "B": "Query",
      "C": "Retrieve",
      "D": "Describe"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The Query operation executes SOQL statements against Salesforce.",
      "incorrect": {
        "A": "Search uses SOSL, not SOQL.",
        "C": "Retrieve fetches records by ID.",
        "D": "Describe returns metadata."
      }
    }
  },
  {
    "id": "CH12-0042",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Connector",
    "subtopic": "sosl usage",
    "difficulty": "Medium",
    "question": "When should SOSL be preferred over SOQL?",
    "options": {
      "A": "When querying a single object",
      "B": "When searching across multiple objects",
      "C": "When updating records",
      "D": "When using Bulk API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SOSL is optimized for text searches across multiple objects.",
      "incorrect": {
        "A": "SOQL is better for single-object queries.",
        "C": "SOSL does not update data.",
        "D": "Bulk API is unrelated."
      }
    }
  },
  {
    "id": "CH12-0043",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Connector",
    "subtopic": "describe operation",
    "difficulty": "Medium",
    "question": "What information does the Describe operation return?",
    "options": {
      "A": "Actual record data",
      "B": "Object metadata and field definitions",
      "C": "User authentication tokens",
      "D": "API usage limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Describe provides schema-level metadata about objects.",
      "incorrect": {
        "A": "Record data is not returned.",
        "C": "Authentication is separate.",
        "D": "Limits are accessed differently."
      }
    }
  },
  {
    "id": "CH12-0044",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Handling",
    "subtopic": "null field behavior",
    "difficulty": "Medium",
    "question": "What happens when null values are sent for fields during Salesforce updates?",
    "options": {
      "A": "Fields are always ignored",
      "B": "Existing values may be cleared",
      "C": "Salesforce rejects the request",
      "D": "Nulls are converted to defaults"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sending nulls can explicitly clear existing field values.",
      "incorrect": {
        "A": "Nulls are processed explicitly.",
        "C": "Requests are not rejected solely for nulls.",
        "D": "Defaults are not auto-applied."
      }
    }
  },
  {
    "id": "CH12-0045",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Handling",
    "subtopic": "partial updates",
    "difficulty": "Medium",
    "question": "Why should partial updates be used carefully in Salesforce integrations?",
    "options": {
      "A": "They increase API limits",
      "B": "Omitted fields may be unintentionally overwritten",
      "C": "They always fail validation",
      "D": "They disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Incorrect payload construction can unintentionally modify data.",
      "incorrect": {
        "A": "API limits are unaffected.",
        "C": "Partial updates are supported.",
        "D": "Triggers still execute."
      }
    }
  },
  {
    "id": "CH12-0046",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Bulk Operations",
    "subtopic": "batch size",
    "difficulty": "Hard",
    "question": "Why is selecting an appropriate batch size important for Bulk API jobs?",
    "options": {
      "A": "To avoid OAuth expiration",
      "B": "To balance performance and error handling",
      "C": "To reduce metadata usage",
      "D": "To eliminate retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batch size affects throughput and error isolation.",
      "incorrect": {
        "A": "OAuth expiration is unrelated.",
        "C": "Metadata usage is unaffected.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH12-0047",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Bulk Operations",
    "subtopic": "job lifecycle",
    "difficulty": "Medium",
    "question": "What is the correct order of a Salesforce Bulk API job lifecycle?",
    "options": {
      "A": "Close job → Upload data → Create job",
      "B": "Create job → Upload data → Close job",
      "C": "Upload data → Create job → Close job",
      "D": "Create job → Close job → Upload data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Jobs are created, data is uploaded, then jobs are closed for processing.",
      "incorrect": {
        "A": "Job must exist before data upload.",
        "C": "Job creation comes first.",
        "D": "Closing occurs after upload."
      }
    }
  },
  {
    "id": "CH12-0048",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Bulk Operations",
    "subtopic": "result handling",
    "difficulty": "Medium",
    "question": "Why must Bulk API results be processed explicitly?",
    "options": {
      "A": "Results are returned synchronously",
      "B": "Success and failure are reported per record",
      "C": "Results replace REST responses",
      "D": "Bulk API retries automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each record may succeed or fail independently.",
      "incorrect": {
        "A": "Bulk API is asynchronous.",
        "C": "REST responses are separate.",
        "D": "Retries must be managed."
      }
    }
  },
  {
    "id": "CH12-0049",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Triggers & Automation",
    "subtopic": "trigger impact",
    "difficulty": "Hard",
    "question": "Why should Salesforce triggers be considered during integrations?",
    "options": {
      "A": "They are disabled for API calls",
      "B": "They can impact performance and data behavior",
      "C": "They replace validation rules",
      "D": "They are ignored by Bulk API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Triggers execute during API operations and can affect outcomes.",
      "incorrect": {
        "A": "Triggers execute for API calls.",
        "C": "Validation rules still apply.",
        "D": "Bulk API also triggers automation."
      }
    }
  },
  {
    "id": "CH12-0050",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Triggers & Automation",
    "subtopic": "order of execution",
    "difficulty": "Hard",
    "question": "Why is Salesforce order of execution important in integrations?",
    "options": {
      "A": "It affects OAuth tokens",
      "B": "It determines how validations, triggers, and workflows run",
      "C": "It controls API limits",
      "D": "It affects network latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Understanding execution order prevents unexpected behavior.",
      "incorrect": {
        "A": "OAuth is separate.",
        "C": "Limits are unaffected.",
        "D": "Latency is unrelated."
      }
    }
  },

  {
    "id": "CH12-0051",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Validation",
    "subtopic": "validation rules",
    "difficulty": "Medium",
    "question": "What happens when Salesforce validation rules fail during integration?",
    "options": {
      "A": "Records are auto-corrected",
      "B": "Operations fail with validation errors",
      "C": "Rules are bypassed",
      "D": "Only warnings are generated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation rule failures prevent record persistence.",
      "incorrect": {
        "A": "Auto-correction does not occur.",
        "C": "Rules cannot be bypassed.",
        "D": "Errors block the operation."
      }
    }
  },
  {
    "id": "CH12-0052",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Validation",
    "subtopic": "pre-validation",
    "difficulty": "Medium",
    "question": "Why should data be pre-validated before sending to Salesforce?",
    "options": {
      "A": "To increase API limits",
      "B": "To reduce unnecessary API failures",
      "C": "To avoid OAuth usage",
      "D": "To disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pre-validation prevents avoidable API rejections.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth remains required.",
        "D": "Triggers are not disabled."
      }
    }
  },
  {
    "id": "CH12-0053",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Versioning",
    "subtopic": "api versions",
    "difficulty": "Easy",
    "question": "Why should Salesforce API versions be explicitly managed?",
    "options": {
      "A": "To increase API limits",
      "B": "To avoid unexpected breaking changes",
      "C": "To simplify authentication",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit versioning prevents sudden behavior changes.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Authentication is unchanged.",
        "D": "Payload size is unaffected."
      }
    }
  },
  {
    "id": "CH12-0054",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Versioning",
    "subtopic": "upgrade planning",
    "difficulty": "Medium",
    "question": "What is the safest approach when upgrading Salesforce API versions?",
    "options": {
      "A": "Upgrade directly in production",
      "B": "Test upgrades in lower environments first",
      "C": "Disable validation rules",
      "D": "Increase retry count"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Testing upgrades reduces risk of breaking integrations.",
      "incorrect": {
        "A": "Direct production upgrades are risky.",
        "C": "Validation rules remain necessary.",
        "D": "Retries do not address compatibility."
      }
    }
  },
  {
    "id": "CH12-0055",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "timeout handling",
    "difficulty": "Medium",
    "question": "Why should timeouts be configured carefully for Salesforce calls?",
    "options": {
      "A": "To eliminate retries",
      "B": "To avoid long-running blocked threads",
      "C": "To increase API limits",
      "D": "To disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proper timeouts prevent resource exhaustion.",
      "incorrect": {
        "A": "Retries may still be needed.",
        "C": "Limits are unchanged.",
        "D": "Triggers are unrelated."
      }
    }
  },
  {
    "id": "CH12-0056",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "fallback strategy",
    "difficulty": "Hard",
    "question": "What is the purpose of a fallback strategy in Salesforce integrations?",
    "options": {
      "A": "Improve throughput",
      "B": "Provide alternative behavior when Salesforce is unavailable",
      "C": "Increase API limits",
      "D": "Simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fallbacks ensure graceful degradation during outages.",
      "incorrect": {
        "A": "Throughput may decrease.",
        "C": "Limits are unaffected.",
        "D": "Mappings are unchanged."
      }
    }
  },
  {
    "id": "CH12-0057",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "change management",
    "difficulty": "Medium",
    "question": "Why is governance important for Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To manage changes and reduce integration risk",
      "C": "To remove testing",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance ensures controlled evolution of integrations.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing remains critical.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH12-0058",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "documentation",
    "difficulty": "Easy",
    "question": "Why is documentation essential for Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To support maintenance and onboarding",
      "C": "To eliminate monitoring",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation helps teams understand and maintain integrations.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Monitoring remains required.",
        "D": "Testing is still necessary."
      }
    }
  },
  {
    "id": "CH12-0059",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Excellence",
    "subtopic": "incident handling",
    "difficulty": "Easy",
    "question": "What is the first step when a Salesforce integration incident occurs?",
    "options": {
      "A": "Disable the integration",
      "B": "Identify and assess the impact",
      "C": "Increase retry count",
      "D": "Deploy new code immediately"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Understanding impact guides appropriate response.",
      "incorrect": {
        "A": "Disabling may worsen impact.",
        "C": "Retries may worsen issues.",
        "D": "Immediate deployment is risky."
      }
    }
  },
  {
    "id": "CH12-0060",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Excellence",
    "subtopic": "post-incident review",
    "difficulty": "Easy",
    "question": "Why are post-incident reviews important?",
    "options": {
      "A": "To assign blame",
      "B": "To prevent recurrence and improve reliability",
      "C": "To reduce API usage",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reviews help teams learn and strengthen integrations.",
      "incorrect": {
        "A": "Blame culture is counterproductive.",
        "C": "API usage is unrelated.",
        "D": "Documentation is still needed."
      }
    }
  },

  {
    "id": "CH12-0061",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Best Practices",
    "subtopic": "long-term maintenance",
    "difficulty": "Easy",
    "question": "What practice best supports long-term Salesforce integration stability?",
    "options": {
      "A": "One-time testing",
      "B": "Continuous monitoring and improvement",
      "C": "Avoiding upgrades",
      "D": "Disabling alerts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Continuous improvement keeps integrations reliable.",
      "incorrect": {
        "A": "One-time testing is insufficient.",
        "C": "Avoiding upgrades increases risk.",
        "D": "Alerts are essential."
      }
    }
  },
  {
    "id": "CH12-0062",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Best Practices",
    "subtopic": "ownership model",
    "difficulty": "Easy",
    "question": "Why should Salesforce integrations have clear ownership?",
    "options": {
      "A": "To increase API speed",
      "B": "To ensure accountability and timely maintenance",
      "C": "To reduce mapping effort",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership ensures issues are addressed promptly.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Mapping remains required.",
        "D": "OAuth is unchanged."
      }
    }
  },
  {
    "id": "CH12-0063",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration goal",
    "difficulty": "Easy",
    "question": "What is the primary goal of Salesforce integrations?",
    "options": {
      "A": "Eliminate Salesforce",
      "B": "Enable reliable data and process connectivity",
      "C": "Reduce development effort",
      "D": "Avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations connect Salesforce reliably with other systems.",
      "incorrect": {
        "A": "Salesforce remains core.",
        "C": "Effort reduction is secondary.",
        "D": "Governance is required."
      }
    }
  },
  {
    "id": "CH12-0064",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "enterprise readiness",
    "difficulty": "Easy",
    "question": "Which attribute defines an enterprise-ready Salesforce integration?",
    "options": {
      "A": "Hard-coded credentials",
      "B": "Scalability, security, and resilience",
      "C": "Minimal logging",
      "D": "Single environment support"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise integrations must scale securely and reliably.",
      "incorrect": {
        "A": "Credentials must be secured.",
        "C": "Logging is important.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0065",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "certification focus",
    "difficulty": "Easy",
    "question": "Why is Salesforce integration heavily tested in MuleSoft certifications?",
    "options": {
      "A": "It is optional knowledge",
      "B": "It reflects real-world integration scenarios",
      "C": "It replaces API design topics",
      "D": "It is limited to theory"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Certification emphasizes practical, real-world integration skills.",
      "incorrect": {
        "A": "It is core knowledge.",
        "C": "API design remains important.",
        "D": "The focus is practical."
      }
    }
  },
  {
    "id": "CH12-0066",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for successful Salesforce integrations?",
    "options": {
      "A": "Quick development",
      "B": "Strong design, testing, and governance",
      "C": "Minimal documentation",
      "D": "Avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design, testing, and governance ensure long-term success.",
      "incorrect": {
        "A": "Speed without quality is risky.",
        "C": "Documentation is essential.",
        "D": "Monitoring is required."
      }
    }
  },
  {
    "id": "CH12-0067",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "overall summary",
    "difficulty": "Easy",
    "question": "Which statement best summarizes Salesforce integration best practices?",
    "options": {
      "A": "Build once and forget",
      "B": "Design for change, resilience, and visibility",
      "C": "Avoid API-led architecture",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilient, observable, and flexible design is essential.",
      "incorrect": {
        "A": "Integrations require ongoing care.",
        "C": "API-led is recommended.",
        "D": "Error handling is mandatory."
      }
    }
  },
  {
    "id": "CH12-0068",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports Salesforce integration success?",
    "options": {
      "A": "Short-term delivery only",
      "B": "Product-oriented, long-term ownership",
      "C": "Avoiding refactoring",
      "D": "Minimal testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Treating integrations as products improves sustainability.",
      "incorrect": {
        "A": "Short-term thinking increases risk.",
        "C": "Refactoring is often needed.",
        "D": "Testing is essential."
      }
    }
  },
  {
    "id": "CH12-0069",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "developer responsibility",
    "difficulty": "Easy",
    "question": "What is the developer’s responsibility in Salesforce integrations?",
    "options": {
      "A": "Only initial development",
      "B": "Building, testing, monitoring, and maintaining integrations",
      "C": "Avoiding documentation",
      "D": "Ignoring runtime behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Developers own the full lifecycle of integrations.",
      "incorrect": {
        "A": "Ownership is ongoing.",
        "C": "Documentation is necessary.",
        "D": "Runtime behavior must be understood."
      }
    }
  },
  {
    "id": "CH12-0070",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "What is the final insight for mastering Salesforce integrations with MuleSoft?",
    "options": {
      "A": "Focus only on connectors",
      "B": "Balance correctness, performance, and resilience",
      "C": "Avoid monitoring and alerts",
      "D": "Rely on retries only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Successful integrations balance multiple quality attributes.",
      "incorrect": {
        "A": "Architecture matters beyond connectors.",
        "C": "Monitoring is essential.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0071",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Patterns",
    "subtopic": "request-reply",
    "difficulty": "Easy",
    "question": "When is a request–reply integration pattern most appropriate with Salesforce?",
    "options": {
      "A": "High-volume batch processing",
      "B": "Synchronous data retrieval with immediate response",
      "C": "Event-driven data propagation",
      "D": "Scheduled bulk loads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Request–reply suits synchronous interactions needing immediate results.",
      "incorrect": {
        "A": "Batch processing is asynchronous.",
        "C": "Events use publish–subscribe patterns.",
        "D": "Scheduled loads are not synchronous."
      }
    }
  },
  {
    "id": "CH12-0072",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Patterns",
    "subtopic": "publish-subscribe",
    "difficulty": "Medium",
    "question": "Which Salesforce feature best supports a publish–subscribe integration pattern?",
    "options": {
      "A": "REST API",
      "B": "Change Data Capture events",
      "C": "SOAP API",
      "D": "Metadata API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CDC publishes events that subscribers can consume asynchronously.",
      "incorrect": {
        "A": "REST is request–response.",
        "C": "SOAP is synchronous.",
        "D": "Metadata API handles configuration."
      }
    }
  },
  {
    "id": "CH12-0073",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Limits",
    "subtopic": "daily api limits",
    "difficulty": "Medium",
    "question": "What primarily determines Salesforce daily API limits?",
    "options": {
      "A": "Connected app type",
      "B": "Salesforce edition and licenses",
      "C": "OAuth grant type",
      "D": "Connector version"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API limits are tied to Salesforce edition and user licenses.",
      "incorrect": {
        "A": "Connected apps do not define limits.",
        "C": "Grant type does not affect limits.",
        "D": "Connector version is irrelevant."
      }
    }
  },
  {
    "id": "CH12-0074",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Salesforce Limits",
    "subtopic": "limit monitoring",
    "difficulty": "Medium",
    "question": "Why should API limit consumption be monitored proactively?",
    "options": {
      "A": "To increase throughput",
      "B": "To prevent unexpected integration failures",
      "C": "To bypass authentication",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exhausted limits cause request failures across integrations.",
      "incorrect": {
        "A": "Throughput may decrease when limits are hit.",
        "C": "Authentication cannot be bypassed.",
        "D": "Mappings are unrelated."
      }
    }
  },
  {
    "id": "CH12-0075",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Volume",
    "subtopic": "large data extraction",
    "difficulty": "Medium",
    "question": "Which approach is best for extracting very large datasets from Salesforce?",
    "options": {
      "A": "Repeated REST queries",
      "B": "Bulk API query jobs",
      "C": "SOAP retrieve calls",
      "D": "Streaming API"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk API is optimized for large-scale data extraction.",
      "incorrect": {
        "A": "REST queries are inefficient at scale.",
        "C": "SOAP is not optimized for volume.",
        "D": "Streaming API is event-based."
      }
    }
  },
  {
    "id": "CH12-0076",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Volume",
    "subtopic": "pagination",
    "difficulty": "Easy",
    "question": "Why is pagination required when querying Salesforce data?",
    "options": {
      "A": "To improve authentication",
      "B": "To handle limits on returned record counts",
      "C": "To avoid validation rules",
      "D": "To disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Salesforce limits the number of records returned per query.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Validation rules still apply.",
        "D": "Triggers are unaffected."
      }
    }
  },
  {
    "id": "CH12-0077",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Transactions",
    "subtopic": "transaction boundaries",
    "difficulty": "Hard",
    "question": "Why must transaction boundaries be carefully considered in Salesforce integrations?",
    "options": {
      "A": "Salesforce supports distributed transactions",
      "B": "Failures may leave systems in inconsistent states",
      "C": "Transactions improve API limits",
      "D": "Transactions disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Partial failures can cause data inconsistency across systems.",
      "incorrect": {
        "A": "Distributed transactions are not supported.",
        "C": "Limits are unrelated.",
        "D": "Triggers still execute."
      }
    }
  },
  {
    "id": "CH12-0078",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Transactions",
    "subtopic": "rollback behavior",
    "difficulty": "Hard",
    "question": "What happens when a Salesforce transaction fails due to validation errors?",
    "options": {
      "A": "Partial data is committed",
      "B": "The entire transaction is rolled back",
      "C": "Only triggers are rolled back",
      "D": "Salesforce retries automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation failures cause a full rollback of the transaction.",
      "incorrect": {
        "A": "Salesforce ensures atomicity.",
        "C": "Triggers are part of the transaction.",
        "D": "Retries are not automatic."
      }
    }
  },
  {
    "id": "CH12-0079",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Ownership",
    "subtopic": "system of record",
    "difficulty": "Medium",
    "question": "Why must a clear system of record be defined in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To prevent conflicting data updates",
      "C": "To reduce OAuth scopes",
      "D": "To simplify UI development"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership avoids data conflicts and overwrites.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Scopes do not define ownership.",
        "D": "UI concerns are separate."
      }
    }
  },
  {
    "id": "CH12-0080",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Ownership",
    "subtopic": "bidirectional sync",
    "difficulty": "Hard",
    "question": "What is the primary risk of bidirectional data synchronization with Salesforce?",
    "options": {
      "A": "Lower throughput",
      "B": "Data update conflicts and loops",
      "C": "Reduced API limits",
      "D": "Authentication failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without control, updates can loop or overwrite each other.",
      "incorrect": {
        "A": "Throughput is not the main risk.",
        "C": "Limits are unchanged.",
        "D": "Authentication remains stable."
      }
    }
  },

  {
    "id": "CH12-0081",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "ip restrictions",
    "difficulty": "Medium",
    "question": "Why are IP restrictions sometimes configured for Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To restrict access to trusted network locations",
      "C": "To avoid OAuth",
      "D": "To improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "IP restrictions add an extra layer of security.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth is still required.",
        "D": "Performance is unrelated."
      }
    }
  },
  {
    "id": "CH12-0082",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "connected apps",
    "difficulty": "Medium",
    "question": "What is the purpose of a Salesforce connected app in integrations?",
    "options": {
      "A": "Deploy Mule applications",
      "B": "Define OAuth access and policies",
      "C": "Increase data storage",
      "D": "Control trigger execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connected apps define OAuth configuration and access control.",
      "incorrect": {
        "A": "Deployment is unrelated.",
        "C": "Storage is unaffected.",
        "D": "Triggers are not controlled here."
      }
    }
  },
  {
    "id": "CH12-0083",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "token scope",
    "difficulty": "Medium",
    "question": "Why should OAuth scopes be minimized in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To reduce security exposure",
      "C": "To avoid refresh tokens",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Minimal scopes limit access if credentials are compromised.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Refresh tokens may still be used.",
        "D": "Mappings are unaffected."
      }
    }
  },
  {
    "id": "CH12-0084",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability",
    "subtopic": "horizontal scaling",
    "difficulty": "Medium",
    "question": "What must be considered when horizontally scaling Salesforce integrations?",
    "options": {
      "A": "OAuth tokens are unlimited",
      "B": "Concurrent API usage may increase limit consumption",
      "C": "Triggers are disabled automatically",
      "D": "Bulk API is no longer needed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "More instances can consume API limits faster.",
      "incorrect": {
        "A": "Tokens and limits are constrained.",
        "C": "Triggers still execute.",
        "D": "Bulk API may still be required."
      }
    }
  },
  {
    "id": "CH12-0085",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability",
    "subtopic": "stateless design",
    "difficulty": "Easy",
    "question": "Why should Salesforce integrations be designed as stateless services?",
    "options": {
      "A": "To increase payload size",
      "B": "To support scalability and resilience",
      "C": "To reduce API limits",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless services scale more easily and recover faster.",
      "incorrect": {
        "A": "Payload size is irrelevant.",
        "C": "Limits are unchanged.",
        "D": "Authentication remains required."
      }
    }
  },
  {
    "id": "CH12-0086",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Observability",
    "subtopic": "logging strategy",
    "difficulty": "Medium",
    "question": "What is a key requirement for effective logging in Salesforce integrations?",
    "options": {
      "A": "Logging every payload entirely",
      "B": "Including correlation identifiers",
      "C": "Disabling logs in production",
      "D": "Logging only errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs help trace requests across systems.",
      "incorrect": {
        "A": "Sensitive data should be handled carefully.",
        "C": "Production logs are essential.",
        "D": "Contextual logs are also important."
      }
    }
  },
  {
    "id": "CH12-0087",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Observability",
    "subtopic": "metrics",
    "difficulty": "Medium",
    "question": "Which metric is most useful for monitoring Salesforce integration health?",
    "options": {
      "A": "CPU temperature",
      "B": "Error rate of API calls",
      "C": "Source code size",
      "D": "Number of fields mapped"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error rates directly indicate integration health.",
      "incorrect": {
        "A": "Hardware metrics are indirect.",
        "C": "Code size is irrelevant.",
        "D": "Field count does not show health."
      }
    }
  },
  {
    "id": "CH12-0088",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Change Management",
    "subtopic": "schema changes",
    "difficulty": "Hard",
    "question": "Why can Salesforce schema changes break integrations?",
    "options": {
      "A": "Salesforce disables APIs",
      "B": "Field additions, removals, or type changes affect mappings",
      "C": "OAuth tokens expire",
      "D": "API limits reset"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schema changes can invalidate existing mappings and logic.",
      "incorrect": {
        "A": "APIs remain enabled.",
        "C": "Token expiration is unrelated.",
        "D": "Limits do not reset."
      }
    }
  },
  {
    "id": "CH12-0089",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Change Management",
    "subtopic": "impact analysis",
    "difficulty": "Medium",
    "question": "What should be done before deploying Salesforce schema changes?",
    "options": {
      "A": "Disable integrations",
      "B": "Perform impact analysis on dependent integrations",
      "C": "Increase retry count",
      "D": "Clear API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Impact analysis prevents breaking dependent systems.",
      "incorrect": {
        "A": "Disabling integrations is disruptive.",
        "C": "Retries do not fix schema mismatches.",
        "D": "Limits are unrelated."
      }
    }
  },
  {
    "id": "CH12-0090",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Best Practices",
    "subtopic": "contract testing",
    "difficulty": "Hard",
    "question": "Why is contract testing valuable in Salesforce integrations?",
    "options": {
      "A": "It replaces unit testing",
      "B": "It validates expectations between systems",
      "C": "It increases API limits",
      "D": "It disables triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract testing ensures systems agree on data structures and behavior.",
      "incorrect": {
        "A": "Unit testing is still required.",
        "C": "Limits are unaffected.",
        "D": "Triggers are not disabled."
      }
    }
  },

  {
    "id": "CH12-0091",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Best Practices",
    "subtopic": "backward compatibility",
    "difficulty": "Medium",
    "question": "Why is backward compatibility important in Salesforce integrations?",
    "options": {
      "A": "To increase development speed",
      "B": "To prevent breaking existing consumers",
      "C": "To reduce OAuth scopes",
      "D": "To simplify UI logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward compatibility protects existing integrations.",
      "incorrect": {
        "A": "Speed is secondary.",
        "C": "Scopes are unrelated.",
        "D": "UI logic is separate."
      }
    }
  },
  {
    "id": "CH12-0092",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "rollback strategy",
    "difficulty": "Medium",
    "question": "Why is a rollback strategy essential for Salesforce integration deployments?",
    "options": {
      "A": "To increase API limits",
      "B": "To quickly recover from failed releases",
      "C": "To avoid testing",
      "D": "To disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollback allows fast recovery from faulty deployments.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing remains essential.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH12-0093",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "configuration drift",
    "difficulty": "Medium",
    "question": "What risk does configuration drift pose in Salesforce integrations?",
    "options": {
      "A": "Improved flexibility",
      "B": "Inconsistent behavior across environments",
      "C": "Higher API limits",
      "D": "Simpler debugging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Drift causes unexpected differences between environments.",
      "incorrect": {
        "A": "Flexibility decreases.",
        "C": "Limits are unaffected.",
        "D": "Debugging becomes harder."
      }
    }
  },
  {
    "id": "CH12-0094",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "automation",
    "difficulty": "Easy",
    "question": "Why should Salesforce integration deployments be automated?",
    "options": {
      "A": "To avoid version control",
      "B": "To reduce human error and ensure consistency",
      "C": "To disable approvals",
      "D": "To increase API speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation improves reliability and repeatability.",
      "incorrect": {
        "A": "Version control remains essential.",
        "C": "Approvals may still exist.",
        "D": "API speed is unrelated."
      }
    }
  },
  {
    "id": "CH12-0095",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "end-to-end testing",
    "difficulty": "Medium",
    "question": "What is the goal of end-to-end testing in Salesforce integrations?",
    "options": {
      "A": "Validate individual DataWeave expressions",
      "B": "Verify complete business flows across systems",
      "C": "Replace unit tests",
      "D": "Increase API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "End-to-end tests validate full integration behavior.",
      "incorrect": {
        "A": "That is unit testing.",
        "C": "Unit tests are still needed.",
        "D": "Limits are unrelated."
      }
    }
  },
  {
    "id": "CH12-0096",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "test data management",
    "difficulty": "Medium",
    "question": "Why is test data management critical in Salesforce integrations?",
    "options": {
      "A": "To increase API usage",
      "B": "To ensure repeatable and reliable test results",
      "C": "To bypass validation rules",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent test data enables reliable testing.",
      "incorrect": {
        "A": "Usage should be controlled.",
        "C": "Validation rules still apply.",
        "D": "OAuth is unchanged."
      }
    }
  },
  {
    "id": "CH12-0097",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operations",
    "subtopic": "runbook usage",
    "difficulty": "Easy",
    "question": "What is the primary purpose of an operational runbook for Salesforce integrations?",
    "options": {
      "A": "Replace monitoring",
      "B": "Guide incident response and troubleshooting",
      "C": "Increase API limits",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runbooks help operators respond effectively to issues.",
      "incorrect": {
        "A": "Monitoring is still required.",
        "C": "Limits are unaffected.",
        "D": "Runbooks are documentation."
      }
    }
  },
  {
    "id": "CH12-0098",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operations",
    "subtopic": "on-call readiness",
    "difficulty": "Easy",
    "question": "Why is on-call readiness important for Salesforce integrations?",
    "options": {
      "A": "To reduce development effort",
      "B": "To ensure rapid response to production issues",
      "C": "To increase API speed",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rapid response minimizes business impact.",
      "incorrect": {
        "A": "Development effort is separate.",
        "C": "Speed is unrelated.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH12-0099",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Maturity",
    "subtopic": "integration maturity model",
    "difficulty": "Medium",
    "question": "What indicates a mature Salesforce integration practice?",
    "options": {
      "A": "No monitoring",
      "B": "Strong governance, automation, and observability",
      "C": "Manual deployments",
      "D": "Minimal testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity includes governance, automation, and visibility.",
      "incorrect": {
        "A": "Monitoring is essential.",
        "C": "Manual processes increase risk.",
        "D": "Testing is critical."
      }
    }
  },
  {
    "id": "CH12-0100",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Maturity",
    "subtopic": "continuous improvement",
    "difficulty": "Easy",
    "question": "Why is continuous improvement necessary for Salesforce integrations?",
    "options": {
      "A": "To avoid documentation",
      "B": "To adapt to changing business and platform needs",
      "C": "To reduce API limits",
      "D": "To eliminate governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business and platform evolution require ongoing improvement.",
      "incorrect": {
        "A": "Documentation remains important.",
        "C": "Limits are unchanged.",
        "D": "Governance is still required."
      }
    }
  },

  {
    "id": "CH12-0101",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "risk management",
    "difficulty": "Easy",
    "question": "What is the biggest risk of poorly designed Salesforce integrations?",
    "options": {
      "A": "Higher development speed",
      "B": "Business disruption due to failures",
      "C": "Lower documentation effort",
      "D": "Improved flexibility"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integration failures can directly impact business operations.",
      "incorrect": {
        "A": "Speed without quality is risky.",
        "C": "Low documentation increases risk.",
        "D": "Flexibility decreases."
      }
    }
  },
  {
    "id": "CH12-0102",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "design principle",
    "difficulty": "Easy",
    "question": "Which principle should guide Salesforce integration design?",
    "options": {
      "A": "Tight coupling",
      "B": "Loose coupling and clear contracts",
      "C": "Minimal error handling",
      "D": "Hard-coded configurations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and adaptability.",
      "incorrect": {
        "A": "Tight coupling increases fragility.",
        "C": "Error handling is essential.",
        "D": "Hard-coding is discouraged."
      }
    }
  },
  {
    "id": "CH12-0103",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam focus",
    "difficulty": "Easy",
    "question": "Which area is most emphasized in Salesforce integration exam questions?",
    "options": {
      "A": "UI customization",
      "B": "Real-world integration scenarios and trade-offs",
      "C": "Salesforce licensing",
      "D": "Marketing features"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams focus on practical integration decisions.",
      "incorrect": {
        "A": "UI is less relevant.",
        "C": "Licensing is peripheral.",
        "D": "Marketing features are irrelevant."
      }
    }
  },
  {
    "id": "CH12-0104",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "success factor",
    "difficulty": "Easy",
    "question": "What is the strongest indicator of a successful Salesforce integration?",
    "options": {
      "A": "No code changes",
      "B": "Reliable, observable, and maintainable behavior",
      "C": "High API usage",
      "D": "Minimal testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability and maintainability define success.",
      "incorrect": {
        "A": "Code evolves over time.",
        "C": "High usage may indicate inefficiency.",
        "D": "Testing is essential."
      }
    }
  },
  {
    "id": "CH12-0105",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "ownership mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term Salesforce integration success?",
    "options": {
      "A": "Project-only mindset",
      "B": "Product ownership mindset",
      "C": "Avoiding refactoring",
      "D": "Minimal monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Treating integrations as products ensures longevity.",
      "incorrect": {
        "A": "Projects end; integrations persist.",
        "C": "Refactoring is often required.",
        "D": "Monitoring is critical."
      }
    }
  },
  {
    "id": "CH12-0106",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "developer role",
    "difficulty": "Easy",
    "question": "What is the ongoing role of developers in Salesforce integrations?",
    "options": {
      "A": "Only initial build",
      "B": "Build, evolve, monitor, and support integrations",
      "C": "Avoid documentation",
      "D": "Ignore runtime issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Developers own the full integration lifecycle.",
      "incorrect": {
        "A": "Ownership is continuous.",
        "C": "Documentation is necessary.",
        "D": "Runtime behavior must be understood."
      }
    }
  },
  {
    "id": "CH12-0107",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "platform evolution",
    "difficulty": "Easy",
    "question": "Why must Salesforce platform evolution be monitored continuously?",
    "options": {
      "A": "To reduce API limits",
      "B": "To adapt integrations to new features and changes",
      "C": "To avoid testing",
      "D": "To disable governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform updates can impact existing integrations.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing remains essential.",
        "D": "Governance is still required."
      }
    }
  },
  {
    "id": "CH12-0108",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for mastering Salesforce integrations?",
    "options": {
      "A": "Focus only on APIs",
      "B": "Balance design, security, scalability, and operations",
      "C": "Avoid monitoring",
      "D": "Rely on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Successful integrations balance multiple quality attributes.",
      "incorrect": {
        "A": "Architecture goes beyond APIs.",
        "C": "Monitoring is essential.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0109",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "enterprise readiness",
    "difficulty": "Easy",
    "question": "Which trait best defines enterprise-ready Salesforce integrations?",
    "options": {
      "A": "Hard-coded logic",
      "B": "Governed, observable, and resilient design",
      "C": "Minimal documentation",
      "D": "Single environment deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise readiness requires governance and resilience.",
      "incorrect": {
        "A": "Hard-coding increases risk.",
        "C": "Documentation is essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0110",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "Which statement best summarizes Salesforce integration excellence?",
    "options": {
      "A": "Build fast and move on",
      "B": "Design for change, visibility, and reliability",
      "C": "Avoid governance",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-term success depends on resilient, observable design.",
      "incorrect": {
        "A": "Speed without quality is risky.",
        "C": "Governance is required.",
        "D": "Error handling is mandatory."
      }
    }
  },
  {
    "id": "CH12-0111",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced APIs",
    "subtopic": "composite api",
    "difficulty": "Medium",
    "question": "What is the primary advantage of using the Salesforce Composite API?",
    "options": {
      "A": "Unlimited API calls",
      "B": "Executing multiple related operations in a single request",
      "C": "Bulk data extraction",
      "D": "Metadata deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composite API reduces round trips by combining multiple operations in one call.",
      "incorrect": {
        "A": "API limits still apply.",
        "C": "Bulk API is used for large volumes.",
        "D": "Metadata API handles deployments."
      }
    }
  },
  {
    "id": "CH12-0112",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced APIs",
    "subtopic": "composite error handling",
    "difficulty": "Hard",
    "question": "Why must error handling be carefully designed when using the Composite API?",
    "options": {
      "A": "All subrequests always succeed",
      "B": "Failures in one subrequest can affect others",
      "C": "Composite API ignores validation rules",
      "D": "Retries are automatic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composite requests may have dependencies, so failures must be handled explicitly.",
      "incorrect": {
        "A": "Subrequests can fail independently.",
        "C": "Validation rules still apply.",
        "D": "Retries must be managed by the client."
      }
    }
  },
  {
    "id": "CH12-0113",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced APIs",
    "subtopic": "composite graph",
    "difficulty": "Hard",
    "question": "What capability does the Composite Graph API uniquely provide?",
    "options": {
      "A": "Asynchronous batch execution",
      "B": "Referencing results of previous subrequests",
      "C": "Metadata updates",
      "D": "Streaming event consumption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composite Graph allows chaining requests using prior responses.",
      "incorrect": {
        "A": "Execution is synchronous.",
        "C": "Metadata is not handled here.",
        "D": "Streaming APIs handle events."
      }
    }
  },
  {
    "id": "CH12-0114",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced APIs",
    "subtopic": "limits awareness",
    "difficulty": "Medium",
    "question": "How do Composite API calls impact Salesforce API limits?",
    "options": {
      "A": "They bypass limits",
      "B": "They count as a single API call",
      "C": "Each subrequest consumes limits",
      "D": "They reset limits"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Each subrequest counts toward API usage limits.",
      "incorrect": {
        "A": "Limits cannot be bypassed.",
        "B": "Subrequests are counted individually.",
        "D": "Limits are not reset."
      }
    }
  },
  {
    "id": "CH12-0115",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Event-Driven Integration",
    "subtopic": "platform events",
    "difficulty": "Medium",
    "question": "What is the main use case for Salesforce Platform Events?",
    "options": {
      "A": "Synchronous CRUD operations",
      "B": "Asynchronous event-driven communication",
      "C": "Bulk data migration",
      "D": "Metadata synchronization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform Events enable loosely coupled, event-driven integrations.",
      "incorrect": {
        "A": "CRUD uses REST/SOAP APIs.",
        "C": "Bulk API is used for migration.",
        "D": "Metadata API handles configuration."
      }
    }
  },
  {
    "id": "CH12-0116",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Event-Driven Integration",
    "subtopic": "event replay",
    "difficulty": "Hard",
    "question": "Why is event replay important in Salesforce event-driven integrations?",
    "options": {
      "A": "To improve API limits",
      "B": "To recover missed events after downtime",
      "C": "To simplify authentication",
      "D": "To increase throughput"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Replay ensures events are not lost during outages.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Authentication is unchanged.",
        "D": "Throughput is secondary."
      }
    }
  },
  {
    "id": "CH12-0117",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Event-Driven Integration",
    "subtopic": "cdc ordering",
    "difficulty": "Hard",
    "question": "What challenge must be handled when consuming Change Data Capture events?",
    "options": {
      "A": "Lack of authentication",
      "B": "Potential out-of-order event delivery",
      "C": "Low data volume",
      "D": "Missing payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumers must handle possible event ordering issues.",
      "incorrect": {
        "A": "Authentication is required.",
        "C": "Volume may be high.",
        "D": "Payloads are included."
      }
    }
  },
  {
    "id": "CH12-0118",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Transformation",
    "subtopic": "dataweave usage",
    "difficulty": "Medium",
    "question": "Why is DataWeave critical in Salesforce integrations?",
    "options": {
      "A": "It replaces Salesforce APIs",
      "B": "It transforms data between Salesforce and external models",
      "C": "It manages authentication",
      "D": "It increases API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave maps and transforms data across system boundaries.",
      "incorrect": {
        "A": "APIs are still required.",
        "C": "Authentication is separate.",
        "D": "Limits are unaffected."
      }
    }
  },
  {
    "id": "CH12-0119",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Transformation",
    "subtopic": "null handling",
    "difficulty": "Medium",
    "question": "Why must null handling be explicit in Salesforce data mappings?",
    "options": {
      "A": "Nulls are ignored by Salesforce",
      "B": "Nulls may clear existing field values",
      "C": "Nulls cause authentication failures",
      "D": "Nulls improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit nulls can overwrite or clear Salesforce fields.",
      "incorrect": {
        "A": "Nulls are processed explicitly.",
        "C": "Authentication is unrelated.",
        "D": "Performance is unaffected."
      }
    }
  },
  {
    "id": "CH12-0120",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Transformation",
    "subtopic": "type coercion",
    "difficulty": "Hard",
    "question": "What risk does incorrect type coercion pose in Salesforce integrations?",
    "options": {
      "A": "Higher API limits",
      "B": "Runtime transformation errors",
      "C": "Improved scalability",
      "D": "Simpler mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Type mismatches can cause runtime failures or rejected records.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Scalability may decrease.",
        "D": "Mappings become brittle."
      }
    }
  },

  {
    "id": "CH12-0121",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Security",
    "subtopic": "field-level security",
    "difficulty": "Medium",
    "question": "Why must field-level security be considered in Salesforce integrations?",
    "options": {
      "A": "It affects API limits",
      "B": "It controls access to sensitive fields",
      "C": "It disables triggers",
      "D": "It simplifies authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Field-level security restricts access to sensitive data.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Triggers still run.",
        "D": "Authentication is separate."
      }
    }
  },
  {
    "id": "CH12-0122",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Security",
    "subtopic": "profile vs permission sets",
    "difficulty": "Medium",
    "question": "Why are permission sets preferred over profiles for integrations?",
    "options": {
      "A": "They increase API limits",
      "B": "They allow granular, flexible access control",
      "C": "They disable validation rules",
      "D": "They avoid OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Permission sets enable flexible, least-privilege access.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Validation rules still apply.",
        "D": "OAuth remains required."
      }
    }
  },
  {
    "id": "CH12-0123",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "api ownership",
    "difficulty": "Easy",
    "question": "Why should API ownership be clearly defined in Salesforce integrations?",
    "options": {
      "A": "To increase development speed",
      "B": "To ensure accountability and controlled changes",
      "C": "To reduce API limits",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership prevents unmanaged changes.",
      "incorrect": {
        "A": "Speed alone is risky.",
        "C": "Limits are unrelated.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH12-0124",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "change approval",
    "difficulty": "Medium",
    "question": "Why are change approval processes important for Salesforce integrations?",
    "options": {
      "A": "To slow down delivery",
      "B": "To reduce unintended downstream impact",
      "C": "To increase retries",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Controlled approvals minimize integration risks.",
      "incorrect": {
        "A": "Speed must be balanced with safety.",
        "C": "Retries do not fix logic issues.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH12-0125",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance Optimization",
    "subtopic": "selective queries",
    "difficulty": "Medium",
    "question": "Why should SOQL queries be selective in integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To improve performance and reduce resource usage",
      "C": "To disable validation rules",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Selective queries reduce load and improve response time.",
      "incorrect": {
        "A": "Limits remain unchanged.",
        "C": "Validation rules still apply.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH12-0126",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance Optimization",
    "subtopic": "payload minimization",
    "difficulty": "Easy",
    "question": "Why should Salesforce API payloads be minimized?",
    "options": {
      "A": "To increase field coverage",
      "B": "To reduce network and processing overhead",
      "C": "To bypass validation",
      "D": "To avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller payloads improve performance and efficiency.",
      "incorrect": {
        "A": "Unnecessary fields increase overhead.",
        "C": "Validation still occurs.",
        "D": "Authentication is required."
      }
    }
  },
  {
    "id": "CH12-0127",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Concerns",
    "subtopic": "throttling strategy",
    "difficulty": "Hard",
    "question": "Why might throttling be implemented in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To protect Salesforce from traffic spikes",
      "C": "To simplify mappings",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Throttling prevents overwhelming Salesforce APIs.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Mappings are unaffected.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH12-0128",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Concerns",
    "subtopic": "backpressure",
    "difficulty": "Hard",
    "question": "What problem does backpressure handling address in integrations?",
    "options": {
      "A": "Authentication failures",
      "B": "Downstream system overload",
      "C": "Schema mismatches",
      "D": "Token expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backpressure protects downstream systems from overload.",
      "incorrect": {
        "A": "Authentication is separate.",
        "C": "Schema issues require validation.",
        "D": "Token expiration is unrelated."
      }
    }
  },
  {
    "id": "CH12-0129",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Concerns",
    "subtopic": "queue-based decoupling",
    "difficulty": "Medium",
    "question": "Why are queues often introduced in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To decouple producers and consumers",
      "C": "To simplify OAuth",
      "D": "To eliminate retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Queues improve resilience and decoupling.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth remains required.",
        "D": "Retries may still occur."
      }
    }
  },
  {
    "id": "CH12-0130",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Concerns",
    "subtopic": "dead letter queues",
    "difficulty": "Medium",
    "question": "What is the purpose of a dead letter queue in integrations?",
    "options": {
      "A": "Increase throughput",
      "B": "Capture failed messages for later analysis",
      "C": "Reduce API limits",
      "D": "Simplify transformations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DLQs store failed messages without blocking processing.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Limits are unchanged.",
        "D": "Transformations are unaffected."
      }
    }
  },

  {
    "id": "CH12-0131",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing Strategies",
    "subtopic": "contract validation",
    "difficulty": "Medium",
    "question": "Why is contract validation critical in Salesforce integrations?",
    "options": {
      "A": "It replaces integration testing",
      "B": "It ensures consumers and providers agree on data structure",
      "C": "It increases API limits",
      "D": "It avoids governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract validation prevents breaking changes.",
      "incorrect": {
        "A": "Integration tests are still needed.",
        "C": "Limits are unaffected.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH12-0132",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing Strategies",
    "subtopic": "mock vs sandbox",
    "difficulty": "Medium",
    "question": "When should mocking be preferred over sandbox testing?",
    "options": {
      "A": "For full end-to-end validation",
      "B": "For fast, isolated unit tests",
      "C": "For production verification",
      "D": "For performance benchmarking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mocks enable fast and deterministic unit tests.",
      "incorrect": {
        "A": "End-to-end requires real systems.",
        "C": "Production should not be used.",
        "D": "Performance tests differ."
      }
    }
  },
  {
    "id": "CH12-0133",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing Strategies",
    "subtopic": "data cleanup",
    "difficulty": "Easy",
    "question": "Why is test data cleanup important in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To prevent test data pollution",
      "C": "To avoid authentication",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cleanup keeps environments stable and predictable.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication remains required.",
        "D": "Mappings are unaffected."
      }
    }
  },
  {
    "id": "CH12-0134",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Lifecycle Management",
    "subtopic": "version deprecation",
    "difficulty": "Medium",
    "question": "Why must deprecated Salesforce API versions be monitored?",
    "options": {
      "A": "To increase API speed",
      "B": "To plan timely upgrades before removal",
      "C": "To avoid OAuth",
      "D": "To disable validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deprecated APIs may be removed, breaking integrations.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "OAuth remains required.",
        "D": "Validation still applies."
      }
    }
  },
  {
    "id": "CH12-0135",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Lifecycle Management",
    "subtopic": "release coordination",
    "difficulty": "Medium",
    "question": "Why should Salesforce releases be coordinated with integration teams?",
    "options": {
      "A": "To increase API limits",
      "B": "To assess impact of new features and changes",
      "C": "To reduce documentation",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform changes can affect existing integrations.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Documentation is important.",
        "D": "Testing remains critical."
      }
    }
  },
  {
    "id": "CH12-0136",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Reliability",
    "subtopic": "idempotent consumers",
    "difficulty": "Hard",
    "question": "Why should event consumers be idempotent in Salesforce integrations?",
    "options": {
      "A": "To increase throughput",
      "B": "To safely handle duplicate event deliveries",
      "C": "To reduce API limits",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotency prevents duplicate processing effects.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Limits are unchanged.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH12-0137",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Reliability",
    "subtopic": "exactly-once myth",
    "difficulty": "Hard",
    "question": "Why is exactly-once delivery difficult to guarantee in integrations?",
    "options": {
      "A": "Salesforce does not support APIs",
      "B": "Distributed systems experience retries and failures",
      "C": "OAuth tokens expire",
      "D": "Triggers are disabled"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Network failures and retries make exactly-once semantics difficult.",
      "incorrect": {
        "A": "APIs are well supported.",
        "C": "Token expiration is manageable.",
        "D": "Triggers still execute."
      }
    }
  },
  {
    "id": "CH12-0138",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Reliability",
    "subtopic": "at-least-once handling",
    "difficulty": "Medium",
    "question": "What design approach best supports at-least-once delivery?",
    "options": {
      "A": "Ignoring duplicates",
      "B": "Idempotent processing logic",
      "C": "Disabling retries",
      "D": "Avoiding queues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent logic safely handles repeated deliveries.",
      "incorrect": {
        "A": "Ignoring duplicates causes data issues.",
        "C": "Retries are often necessary.",
        "D": "Queues improve resilience."
      }
    }
  },
  {
    "id": "CH12-0139",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture",
    "subtopic": "api-led layering",
    "difficulty": "Easy",
    "question": "Why is API-led architecture recommended for Salesforce integrations?",
    "options": {
      "A": "It eliminates the need for APIs",
      "B": "It improves reuse, scalability, and maintainability",
      "C": "It bypasses security",
      "D": "It reduces testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layered APIs improve reuse and decoupling.",
      "incorrect": {
        "A": "APIs remain central.",
        "C": "Security is enforced.",
        "D": "Testing is still required."
      }
    }
  },
  {
    "id": "CH12-0140",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture",
    "subtopic": "system api stability",
    "difficulty": "Medium",
    "question": "Why should System APIs be kept stable in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To prevent cascading changes to consumers",
      "C": "To avoid OAuth",
      "D": "To simplify UI logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable System APIs shield consumers from backend changes.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth is still required.",
        "D": "UI logic is separate."
      }
    }
  },

  {
    "id": "CH12-0141",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration resilience",
    "difficulty": "Easy",
    "question": "Which characteristic most improves Salesforce integration resilience?",
    "options": {
      "A": "Hard-coded endpoints",
      "B": "Loose coupling and graceful error handling",
      "C": "Minimal logging",
      "D": "Single deployment environment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling and resilience patterns reduce failure impact.",
      "incorrect": {
        "A": "Hard-coding increases fragility.",
        "C": "Logging is essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0142",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "scalability factor",
    "difficulty": "Easy",
    "question": "What is a key scalability consideration in Salesforce integrations?",
    "options": {
      "A": "Ignoring API limits",
      "B": "Designing for stateless processing",
      "C": "Hard-coding credentials",
      "D": "Avoiding queues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless designs scale more effectively.",
      "incorrect": {
        "A": "Limits must be respected.",
        "C": "Credentials must be secured.",
        "D": "Queues often help scalability."
      }
    }
  },
  {
    "id": "CH12-0143",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "security principle",
    "difficulty": "Easy",
    "question": "Which security principle is most important for Salesforce integrations?",
    "options": {
      "A": "Maximum privilege",
      "B": "Least privilege",
      "C": "Shared credentials",
      "D": "Disabled auditing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege limits security exposure.",
      "incorrect": {
        "A": "Excess privilege increases risk.",
        "C": "Credentials should not be shared.",
        "D": "Auditing is essential."
      }
    }
  },
  {
    "id": "CH12-0144",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational excellence",
    "difficulty": "Easy",
    "question": "What best represents operational excellence in Salesforce integrations?",
    "options": {
      "A": "Manual monitoring",
      "B": "Automation, observability, and clear ownership",
      "C": "Minimal testing",
      "D": "Avoiding documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operational excellence depends on automation and visibility.",
      "incorrect": {
        "A": "Manual monitoring does not scale.",
        "C": "Testing is essential.",
        "D": "Documentation is required."
      }
    }
  },
  {
    "id": "CH12-0145",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term Salesforce integration success?",
    "options": {
      "A": "One-time project delivery",
      "B": "Product-oriented lifecycle ownership",
      "C": "Avoiding refactoring",
      "D": "Minimal governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Treating integrations as products ensures sustainability.",
      "incorrect": {
        "A": "Integrations live beyond projects.",
        "C": "Refactoring is often necessary.",
        "D": "Governance is critical."
      }
    }
  },
  {
    "id": "CH12-0146",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "developer responsibility",
    "difficulty": "Easy",
    "question": "What is the ongoing responsibility of developers in Salesforce integrations?",
    "options": {
      "A": "Initial build only",
      "B": "Build, monitor, evolve, and support integrations",
      "C": "Avoid documentation",
      "D": "Ignore runtime behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Developers own the full lifecycle.",
      "incorrect": {
        "A": "Ownership is continuous.",
        "C": "Documentation is necessary.",
        "D": "Runtime behavior matters."
      }
    }
  },
  {
    "id": "CH12-0147",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam readiness",
    "difficulty": "Easy",
    "question": "What best prepares candidates for Salesforce integration exam questions?",
    "options": {
      "A": "Memorizing API names",
      "B": "Understanding real-world integration trade-offs",
      "C": "Ignoring edge cases",
      "D": "Avoiding hands-on practice"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario-based reasoning.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "Edge cases are tested.",
        "D": "Hands-on practice is critical."
      }
    }
  },
  {
    "id": "CH12-0148",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "success indicator",
    "difficulty": "Easy",
    "question": "Which indicator best reflects successful Salesforce integrations?",
    "options": {
      "A": "High API usage",
      "B": "Reliable, observable, and maintainable behavior",
      "C": "Minimal governance",
      "D": "Single environment support"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reliability and maintainability define success.",
      "incorrect": {
        "A": "High usage may indicate inefficiency.",
        "C": "Governance is necessary.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0149",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for enterprise Salesforce integrations?",
    "options": {
      "A": "Build quickly and move on",
      "B": "Design for change, security, and resilience",
      "C": "Avoid monitoring",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise integrations must evolve safely over time.",
      "incorrect": {
        "A": "Speed without quality is risky.",
        "C": "Monitoring is essential.",
        "D": "Error handling is mandatory."
      }
    }
  },
  {
    "id": "CH12-0150",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "Which statement best summarizes Salesforce integration excellence?",
    "options": {
      "A": "Avoid complexity at all costs",
      "B": "Balance architecture, security, performance, and operations",
      "C": "Focus only on connectors",
      "D": "Ignore platform evolution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Successful integrations balance multiple architectural concerns.",
      "incorrect": {
        "A": "Complexity must be managed, not avoided blindly.",
        "C": "Connectors are only one part of the solution.",
        "D": "Platform evolution must be tracked."
      }
    }
  },
  {
    "id": "CH12-0151",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Asynchronous Processing",
    "subtopic": "future methods impact",
    "difficulty": "Medium",
    "question": "Why should asynchronous Salesforce processing be considered in high-latency integrations?",
    "options": {
      "A": "It increases API limits",
      "B": "It prevents user-facing delays",
      "C": "It disables validation rules",
      "D": "It simplifies authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Asynchronous processing decouples user actions from long-running operations.",
      "incorrect": {
        "A": "API limits remain unchanged.",
        "C": "Validation rules still apply.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH12-0152",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Asynchronous Processing",
    "subtopic": "queueable jobs",
    "difficulty": "Medium",
    "question": "What advantage do queueable jobs provide over synchronous calls?",
    "options": {
      "A": "Unlimited execution time",
      "B": "Chaining and controlled background execution",
      "C": "Bypassing governor limits",
      "D": "Immediate user response with results"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Queueable jobs allow chaining and background execution without blocking callers.",
      "incorrect": {
        "A": "Execution time is still governed.",
        "C": "Governor limits still apply.",
        "D": "Results are not immediate."
      }
    }
  },
  {
    "id": "CH12-0153",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governor Limits",
    "subtopic": "limit awareness",
    "difficulty": "Medium",
    "question": "Why must MuleSoft integrations be aware of Salesforce governor limits?",
    "options": {
      "A": "They affect network latency",
      "B": "They restrict resource usage per transaction",
      "C": "They control OAuth token lifetime",
      "D": "They determine API versions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governor limits restrict resource usage and can cause transaction failures.",
      "incorrect": {
        "A": "Latency is unrelated.",
        "C": "Token lifetime is separate.",
        "D": "API versions are independent."
      }
    }
  },
  {
    "id": "CH12-0154",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governor Limits",
    "subtopic": "bulkification",
    "difficulty": "Hard",
    "question": "Why is bulkification important when integrating with Salesforce?",
    "options": {
      "A": "To simplify OAuth",
      "B": "To reduce per-record processing overhead",
      "C": "To increase payload size",
      "D": "To bypass validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulkification reduces repeated processing and helps stay within limits.",
      "incorrect": {
        "A": "OAuth is unrelated.",
        "C": "Larger payloads may reduce performance.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH12-0155",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "retry strategies",
    "difficulty": "Medium",
    "question": "When should retries be avoided in Salesforce integrations?",
    "options": {
      "A": "For transient network failures",
      "B": "For validation or data integrity errors",
      "C": "For timeout errors",
      "D": "For temporary platform outages"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation errors require data correction, not retries.",
      "incorrect": {
        "A": "Retries may succeed.",
        "C": "Retries can help timeouts.",
        "D": "Retries may help after recovery."
      }
    }
  },
  {
    "id": "CH12-0156",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "error classification",
    "difficulty": "Medium",
    "question": "Why should Salesforce errors be classified before handling?",
    "options": {
      "A": "To reduce logging",
      "B": "To apply appropriate recovery strategies",
      "C": "To increase API speed",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Different error types require different handling approaches.",
      "incorrect": {
        "A": "Logging is still important.",
        "C": "Speed is unaffected.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH12-0157",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "eventual consistency",
    "difficulty": "Medium",
    "question": "What does eventual consistency imply in Salesforce integrations?",
    "options": {
      "A": "Immediate synchronization",
      "B": "Temporary data divergence that resolves over time",
      "C": "Permanent data mismatch",
      "D": "Disabled validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Eventual consistency accepts temporary divergence for scalability.",
      "incorrect": {
        "A": "Immediate sync is not guaranteed.",
        "C": "Divergence should resolve.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH12-0158",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "compensating actions",
    "difficulty": "Hard",
    "question": "Why are compensating actions used in distributed Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To undo effects of partially completed operations",
      "C": "To simplify authentication",
      "D": "To improve query performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compensations restore consistency after partial failures.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication is unrelated.",
        "D": "Query performance is unaffected."
      }
    }
  },
  {
    "id": "CH12-0159",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Synchronization",
    "subtopic": "one-way sync",
    "difficulty": "Easy",
    "question": "When is one-way data synchronization preferable with Salesforce?",
    "options": {
      "A": "When both systems modify data",
      "B": "When Salesforce is the single system of record",
      "C": "When low latency is required",
      "D": "When data volumes are large"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "One-way sync avoids conflicts when one system owns the data.",
      "incorrect": {
        "A": "Bidirectional sync may be needed.",
        "C": "Latency is not the deciding factor.",
        "D": "Volume alone does not dictate direction."
      }
    }
  },
  {
    "id": "CH12-0160",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Synchronization",
    "subtopic": "conflict resolution",
    "difficulty": "Hard",
    "question": "What is the biggest challenge in bidirectional Salesforce data synchronization?",
    "options": {
      "A": "Low throughput",
      "B": "Conflict detection and resolution",
      "C": "OAuth token expiration",
      "D": "API version mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Conflicts arise when both systems update the same records.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Token renewal is manageable.",
        "D": "Versions can be aligned."
      }
    }
  },

  {
    "id": "CH12-0161",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "alert thresholds",
    "difficulty": "Medium",
    "question": "Why should alert thresholds be tuned for Salesforce integrations?",
    "options": {
      "A": "To reduce API limits",
      "B": "To avoid alert fatigue while catching real issues",
      "C": "To disable logging",
      "D": "To simplify testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proper thresholds balance awareness and noise reduction.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Logging remains necessary.",
        "D": "Testing is unrelated."
      }
    }
  },
  {
    "id": "CH12-0162",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "synthetic checks",
    "difficulty": "Medium",
    "question": "What is the purpose of synthetic monitoring in Salesforce integrations?",
    "options": {
      "A": "Increase API limits",
      "B": "Detect issues before users experience them",
      "C": "Replace logging",
      "D": "Avoid authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Synthetic checks proactively validate integration health.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Logging is still required.",
        "D": "Authentication remains necessary."
      }
    }
  },
  {
    "id": "CH12-0163",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "token rotation",
    "difficulty": "Medium",
    "question": "Why is OAuth token rotation important in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To reduce risk if credentials are compromised",
      "C": "To bypass permission sets",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Regular rotation limits exposure of compromised tokens.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Permission sets still apply.",
        "D": "Mappings are unaffected."
      }
    }
  },
  {
    "id": "CH12-0164",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "secret storage",
    "difficulty": "Easy",
    "question": "Where should Salesforce client secrets be stored in MuleSoft?",
    "options": {
      "A": "Hard-coded in flows",
      "B": "Secure property stores or secret managers",
      "C": "Version control repositories",
      "D": "Log files"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secrets must be stored securely and centrally.",
      "incorrect": {
        "A": "Hard-coding is insecure.",
        "C": "Repositories expose secrets.",
        "D": "Logs must never contain secrets."
      }
    }
  },
  {
    "id": "CH12-0165",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Environment Strategy",
    "subtopic": "sandbox usage",
    "difficulty": "Easy",
    "question": "Why should Salesforce sandboxes be used for integration testing?",
    "options": {
      "A": "They increase API limits",
      "B": "They isolate testing from production data",
      "C": "They disable validation rules",
      "D": "They simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sandboxes protect production data and behavior.",
      "incorrect": {
        "A": "Limits are similar.",
        "C": "Validation rules still apply.",
        "D": "OAuth configuration remains."
      }
    }
  },
  {
    "id": "CH12-0166",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Environment Strategy",
    "subtopic": "data masking",
    "difficulty": "Medium",
    "question": "Why is data masking important in non-production Salesforce environments?",
    "options": {
      "A": "To increase API speed",
      "B": "To protect sensitive information",
      "C": "To reduce governor limits",
      "D": "To improve query performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Masking prevents exposure of sensitive data.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Limits are unaffected.",
        "D": "Performance is unchanged."
      }
    }
  },
  {
    "id": "CH12-0167",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Release Management",
    "subtopic": "blue-green deployments",
    "difficulty": "Medium",
    "question": "What is a benefit of blue-green deployment for Salesforce integrations?",
    "options": {
      "A": "Higher API limits",
      "B": "Reduced downtime during releases",
      "C": "Simpler authentication",
      "D": "Less monitoring required"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blue-green enables near-zero downtime releases.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication remains the same.",
        "D": "Monitoring is still critical."
      }
    }
  },
  {
    "id": "CH12-0168",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Release Management",
    "subtopic": "canary releases",
    "difficulty": "Hard",
    "question": "Why are canary releases useful in Salesforce integrations?",
    "options": {
      "A": "They bypass testing",
      "B": "They limit exposure of faulty changes",
      "C": "They increase throughput",
      "D": "They reduce API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Canaries expose changes to a small subset before full rollout.",
      "incorrect": {
        "A": "Testing is still required.",
        "C": "Throughput is secondary.",
        "D": "Limits are unaffected."
      }
    }
  },
  {
    "id": "CH12-0169",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Documentation",
    "subtopic": "operational docs",
    "difficulty": "Easy",
    "question": "What is the primary value of operational documentation for integrations?",
    "options": {
      "A": "Increase development speed",
      "B": "Enable effective support and troubleshooting",
      "C": "Reduce API usage",
      "D": "Avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation helps teams respond to incidents efficiently.",
      "incorrect": {
        "A": "Speed is not the main value.",
        "C": "Usage is unrelated.",
        "D": "Monitoring is still needed."
      }
    }
  },
  {
    "id": "CH12-0170",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Documentation",
    "subtopic": "api contracts",
    "difficulty": "Medium",
    "question": "Why should API contracts be explicitly documented?",
    "options": {
      "A": "To increase API speed",
      "B": "To set clear expectations for consumers",
      "C": "To avoid validation rules",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contracts define expectations and reduce integration errors.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "Validation rules still apply.",
        "D": "OAuth is separate."
      }
    }
  },

  {
    "id": "CH12-0171",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Management",
    "subtopic": "api efficiency",
    "difficulty": "Medium",
    "question": "How does efficient API usage impact Salesforce integration costs?",
    "options": {
      "A": "It reduces licensing fees directly",
      "B": "It minimizes consumption of limited resources",
      "C": "It disables monitoring",
      "D": "It avoids testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Efficient usage prevents hitting costly limits.",
      "incorrect": {
        "A": "Licensing is separate.",
        "C": "Monitoring is still required.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH12-0172",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Management",
    "subtopic": "batching strategy",
    "difficulty": "Medium",
    "question": "Why does batching requests help control Salesforce API consumption?",
    "options": {
      "A": "It increases payload size",
      "B": "It reduces the number of API calls",
      "C": "It simplifies authentication",
      "D": "It disables retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Batching reduces call count while processing multiple records.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Authentication remains required.",
        "D": "Retries may still be needed."
      }
    }
  },
  {
    "id": "CH12-0173",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Decisions",
    "subtopic": "sync vs async",
    "difficulty": "Medium",
    "question": "What factor most influences choosing synchronous vs asynchronous integration?",
    "options": {
      "A": "API version",
      "B": "Business requirement for immediate response",
      "C": "OAuth grant type",
      "D": "Field-level security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business latency requirements drive the choice.",
      "incorrect": {
        "A": "Version is independent.",
        "C": "Grant type is unrelated.",
        "D": "Security applies to both."
      }
    }
  },
  {
    "id": "CH12-0174",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Decisions",
    "subtopic": "tight coupling risk",
    "difficulty": "Medium",
    "question": "What is the primary risk of tightly coupled Salesforce integrations?",
    "options": {
      "A": "Higher performance",
      "B": "Cascading failures when changes occur",
      "C": "Lower API usage",
      "D": "Simpler governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tight coupling propagates changes and failures.",
      "incorrect": {
        "A": "Performance may degrade.",
        "C": "Usage may increase.",
        "D": "Governance becomes harder."
      }
    }
  },
  {
    "id": "CH12-0175",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Decisions",
    "subtopic": "decoupling benefits",
    "difficulty": "Easy",
    "question": "What is a key benefit of decoupling Salesforce integrations?",
    "options": {
      "A": "Higher API limits",
      "B": "Independent evolution of systems",
      "C": "Reduced security",
      "D": "Elimination of testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Decoupling allows systems to change independently.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Security must remain strong.",
        "D": "Testing is still required."
      }
    }
  },
  {
    "id": "CH12-0176",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Quality Assurance",
    "subtopic": "non-functional testing",
    "difficulty": "Medium",
    "question": "Which non-functional aspect is critical for Salesforce integrations?",
    "options": {
      "A": "Code formatting",
      "B": "Performance and scalability",
      "C": "Variable naming",
      "D": "UI layout"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations must perform reliably under load.",
      "incorrect": {
        "A": "Formatting is cosmetic.",
        "C": "Naming is less critical.",
        "D": "UI layout is irrelevant."
      }
    }
  },
  {
    "id": "CH12-0177",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Quality Assurance",
    "subtopic": "failure testing",
    "difficulty": "Hard",
    "question": "Why should failure scenarios be tested in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To validate resilience and recovery behavior",
      "C": "To avoid monitoring",
      "D": "To simplify deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Testing failures ensures graceful recovery.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Monitoring is still required.",
        "D": "Deployment complexity remains."
      }
    }
  },
  {
    "id": "CH12-0178",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Quality Assurance",
    "subtopic": "load testing",
    "difficulty": "Medium",
    "question": "What is the goal of load testing Salesforce integrations?",
    "options": {
      "A": "Reduce API limits",
      "B": "Verify behavior under expected and peak loads",
      "C": "Disable retries",
      "D": "Simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Load testing validates performance and stability.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Retries may still be needed.",
        "D": "Mappings are unaffected."
      }
    }
  },
  {
    "id": "CH12-0179",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "policy enforcement",
    "difficulty": "Medium",
    "question": "Why is policy enforcement important in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To ensure consistent security and usage standards",
      "C": "To disable validation rules",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policies enforce standards across integrations.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "Validation rules still apply.",
        "D": "Documentation remains important."
      }
    }
  },
  {
    "id": "CH12-0180",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "centralized visibility",
    "difficulty": "Easy",
    "question": "What is a benefit of centralized visibility across Salesforce integrations?",
    "options": {
      "A": "Higher API limits",
      "B": "Faster issue detection and resolution",
      "C": "Reduced authentication complexity",
      "D": "Simpler mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Centralized visibility improves operational response.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication remains the same.",
        "D": "Mappings are unaffected."
      }
    }
  },

  {
    "id": "CH12-0181",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Alignment",
    "subtopic": "business alignment",
    "difficulty": "Easy",
    "question": "Why should Salesforce integrations align with business processes?",
    "options": {
      "A": "To increase API limits",
      "B": "To ensure integrations deliver business value",
      "C": "To reduce testing",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alignment ensures integrations support real business needs.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing remains essential.",
        "D": "Governance is required."
      }
    }
  },
  {
    "id": "CH12-0182",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Alignment",
    "subtopic": "roi measurement",
    "difficulty": "Medium",
    "question": "How can the ROI of Salesforce integrations be measured?",
    "options": {
      "A": "By API call count alone",
      "B": "By business outcomes and efficiency gains",
      "C": "By code complexity",
      "D": "By deployment frequency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ROI is reflected in improved business outcomes.",
      "incorrect": {
        "A": "API count is insufficient.",
        "C": "Complexity does not equal value.",
        "D": "Frequency alone is not ROI."
      }
    }
  },
  {
    "id": "CH12-0183",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Alignment",
    "subtopic": "future readiness",
    "difficulty": "Medium",
    "question": "Why should Salesforce integrations be designed for future readiness?",
    "options": {
      "A": "To avoid refactoring",
      "B": "To adapt to changing business and platform needs",
      "C": "To increase API limits",
      "D": "To reduce documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Future-ready designs accommodate change.",
      "incorrect": {
        "A": "Refactoring may still be needed.",
        "C": "Limits are unchanged.",
        "D": "Documentation remains important."
      }
    }
  },
  {
    "id": "CH12-0184",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Alignment",
    "subtopic": "technology choices",
    "difficulty": "Easy",
    "question": "What should guide technology choices in Salesforce integrations?",
    "options": {
      "A": "Personal preference",
      "B": "Business requirements and constraints",
      "C": "Latest trends only",
      "D": "Ease of initial development"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Technology must serve business needs.",
      "incorrect": {
        "A": "Personal preference is risky.",
        "C": "Trends may not fit requirements.",
        "D": "Long-term needs matter."
      }
    }
  },
  {
    "id": "CH12-0185",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Alignment",
    "subtopic": "integration roadmap",
    "difficulty": "Medium",
    "question": "Why is an integration roadmap valuable?",
    "options": {
      "A": "To eliminate governance",
      "B": "To plan and prioritize integration evolution",
      "C": "To increase API limits",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Roadmaps guide structured evolution.",
      "incorrect": {
        "A": "Governance remains essential.",
        "C": "Limits are unrelated.",
        "D": "Testing is still required."
      }
    }
  },
  {
    "id": "CH12-0186",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "success criteria",
    "difficulty": "Easy",
    "question": "Which criteria best defines Salesforce integration success?",
    "options": {
      "A": "Fast initial delivery",
      "B": "Reliable, secure, and maintainable operation",
      "C": "Minimal documentation",
      "D": "High API usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-term reliability and security define success.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Documentation is essential.",
        "D": "High usage may indicate inefficiency."
      }
    }
  },
  {
    "id": "CH12-0187",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "developer mindset",
    "difficulty": "Easy",
    "question": "What mindset should developers adopt for Salesforce integrations?",
    "options": {
      "A": "One-time project mindset",
      "B": "Product lifecycle ownership mindset",
      "C": "Avoiding refactoring",
      "D": "Minimal monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations require ongoing ownership.",
      "incorrect": {
        "A": "Projects end but integrations persist.",
        "C": "Refactoring is often required.",
        "D": "Monitoring is critical."
      }
    }
  },
  {
    "id": "CH12-0188",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key principle",
    "difficulty": "Easy",
    "question": "Which principle is most important for enterprise Salesforce integrations?",
    "options": {
      "A": "Tight coupling",
      "B": "Loose coupling and resilience",
      "C": "Minimal governance",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and change tolerance.",
      "incorrect": {
        "A": "Tight coupling increases risk.",
        "C": "Governance is necessary.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "CH12-0189",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational maturity",
    "difficulty": "Easy",
    "question": "What indicates high operational maturity in Salesforce integrations?",
    "options": {
      "A": "Manual deployments",
      "B": "Automated, observable, and governed operations",
      "C": "Minimal testing",
      "D": "No documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mature operations rely on automation and visibility.",
      "incorrect": {
        "A": "Manual processes increase risk.",
        "C": "Testing is essential.",
        "D": "Documentation is required."
      }
    }
  },
  {
    "id": "CH12-0190",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing takeaway",
    "difficulty": "Easy",
    "question": "What is the ultimate takeaway for Salesforce integrations with MuleSoft?",
    "options": {
      "A": "Focus only on connectors",
      "B": "Design holistically for business, technology, and operations",
      "C": "Avoid monitoring",
      "D": "Rely solely on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Holistic design ensures sustainable integration success.",
      "incorrect": {
        "A": "Connectors are only one component.",
        "C": "Monitoring is mandatory.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0191",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "high-volume events",
    "difficulty": "Medium",
    "question": "Why should high-volume Salesforce events be processed asynchronously?",
    "options": {
      "A": "To bypass API limits",
      "B": "To avoid blocking upstream systems",
      "C": "To simplify authentication",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Asynchronous processing prevents upstream systems from being blocked by heavy workloads.",
      "incorrect": {
        "A": "API limits still apply.",
        "C": "Authentication is unchanged.",
        "D": "Retries may still be required."
      }
    }
  },
  {
    "id": "CH12-0192",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "event filtering",
    "difficulty": "Medium",
    "question": "What is the main benefit of filtering Salesforce events before processing?",
    "options": {
      "A": "Increased payload size",
      "B": "Reduced unnecessary downstream processing",
      "C": "Higher API limits",
      "D": "Simpler OAuth configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering ensures only relevant events are processed.",
      "incorrect": {
        "A": "Payload size should be minimized.",
        "C": "API limits are unaffected.",
        "D": "OAuth is unrelated."
      }
    }
  },
  {
    "id": "CH12-0193",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "event deduplication",
    "difficulty": "Hard",
    "question": "Why is event deduplication important in Salesforce integrations?",
    "options": {
      "A": "To increase throughput",
      "B": "To prevent duplicate side effects from repeated events",
      "C": "To simplify transformations",
      "D": "To reduce API versions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Duplicate events can cause repeated updates or data corruption if not handled.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Transformations are unrelated.",
        "D": "API versions are irrelevant."
      }
    }
  },
  {
    "id": "CH12-0194",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "replay id tracking",
    "difficulty": "Hard",
    "question": "Why must replay IDs be tracked when consuming Salesforce events?",
    "options": {
      "A": "To improve authentication",
      "B": "To resume consumption after failures without data loss",
      "C": "To increase API limits",
      "D": "To disable triggers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Replay IDs allow consumers to restart from the correct position after interruptions.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Limits are unaffected.",
        "D": "Triggers still execute."
      }
    }
  },
  {
    "id": "CH12-0195",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "event retention",
    "difficulty": "Medium",
    "question": "What risk exists if Salesforce event retention limits are exceeded?",
    "options": {
      "A": "API calls are blocked permanently",
      "B": "Older events may no longer be replayable",
      "C": "OAuth tokens expire",
      "D": "Triggers stop firing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Events outside the retention window cannot be replayed.",
      "incorrect": {
        "A": "Calls are not permanently blocked.",
        "C": "Token expiration is unrelated.",
        "D": "Triggers continue to execute."
      }
    }
  },
  {
    "id": "CH12-0196",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Advanced Eventing",
    "subtopic": "event ordering",
    "difficulty": "Hard",
    "question": "How should integrations handle out-of-order Salesforce events?",
    "options": {
      "A": "Ignore ordering completely",
      "B": "Implement ordering or reconciliation logic",
      "C": "Disable retries",
      "D": "Force synchronous processing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ordering logic ensures data consistency when events arrive out of sequence.",
      "incorrect": {
        "A": "Ignoring order can corrupt data.",
        "C": "Retries do not fix ordering.",
        "D": "Synchronous processing is not guaranteed."
      }
    }
  },
  {
    "id": "CH12-0197",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Governance",
    "subtopic": "data ownership",
    "difficulty": "Medium",
    "question": "Why must data ownership be explicitly defined in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To prevent conflicting updates between systems",
      "C": "To simplify authentication",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership prevents conflicting writes and data inconsistency.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Authentication is unaffected.",
        "D": "Logging remains important."
      }
    }
  },
  {
    "id": "CH12-0198",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Governance",
    "subtopic": "master data",
    "difficulty": "Medium",
    "question": "What role does Salesforce often play in enterprise master data management?",
    "options": {
      "A": "Temporary cache only",
      "B": "System of record for customer-related data",
      "C": "Pure analytics platform",
      "D": "Authentication provider"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Salesforce frequently acts as the authoritative source for customer data.",
      "incorrect": {
        "A": "It is not just a cache.",
        "C": "Analytics is not its primary role.",
        "D": "Authentication is separate."
      }
    }
  },
  {
    "id": "CH12-0199",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Governance",
    "subtopic": "data lineage",
    "difficulty": "Medium",
    "question": "Why is data lineage important in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To trace data origin and transformations",
      "C": "To disable validation rules",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lineage helps trace where data originated and how it was transformed.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Validation still applies.",
        "D": "OAuth is unchanged."
      }
    }
  },
  {
    "id": "CH12-0200",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Governance",
    "subtopic": "auditability",
    "difficulty": "Medium",
    "question": "What supports auditability in Salesforce integrations?",
    "options": {
      "A": "Hard-coded logic",
      "B": "Comprehensive logging and traceability",
      "C": "Minimal documentation",
      "D": "Disabled monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logs and traceability enable audits and compliance checks.",
      "incorrect": {
        "A": "Hard-coding reduces transparency.",
        "C": "Documentation is essential.",
        "D": "Monitoring supports audits."
      }
    }
  },

  {
    "id": "CH12-0201",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability Patterns",
    "subtopic": "fan-out",
    "difficulty": "Medium",
    "question": "What scalability challenge does fan-out address in integrations?",
    "options": {
      "A": "Single consumer bottlenecks",
      "B": "Delivering data to multiple downstream systems",
      "C": "OAuth token expiration",
      "D": "Schema mismatches"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fan-out distributes events or data to multiple consumers.",
      "incorrect": {
        "A": "Bottlenecks may still occur.",
        "C": "Token expiration is unrelated.",
        "D": "Schema issues require mapping."
      }
    }
  },
  {
    "id": "CH12-0202",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability Patterns",
    "subtopic": "fan-in",
    "difficulty": "Medium",
    "question": "When is fan-in integration commonly used?",
    "options": {
      "A": "To send one event to many systems",
      "B": "To consolidate data from multiple sources",
      "C": "To increase API limits",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fan-in aggregates inputs from multiple sources into one.",
      "incorrect": {
        "A": "That describes fan-out.",
        "C": "Limits are unaffected.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH12-0203",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability Patterns",
    "subtopic": "parallel processing",
    "difficulty": "Hard",
    "question": "Why should parallel processing be carefully controlled in Salesforce integrations?",
    "options": {
      "A": "It simplifies governance",
      "B": "It may exhaust API or governor limits",
      "C": "It disables retries",
      "D": "It avoids error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excessive parallelism can quickly consume limited resources.",
      "incorrect": {
        "A": "Governance becomes more complex.",
        "C": "Retries may still be needed.",
        "D": "Error handling remains required."
      }
    }
  },
  {
    "id": "CH12-0204",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability Patterns",
    "subtopic": "rate limiting",
    "difficulty": "Medium",
    "question": "What is the purpose of rate limiting in Salesforce integrations?",
    "options": {
      "A": "Increase API limits",
      "B": "Protect Salesforce from excessive request rates",
      "C": "Simplify transformations",
      "D": "Disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limiting prevents overload and throttling errors.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Transformations are unrelated.",
        "D": "Retries may still be required."
      }
    }
  },
  {
    "id": "CH12-0205",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability Patterns",
    "subtopic": "burst handling",
    "difficulty": "Hard",
    "question": "How should Salesforce integrations handle sudden traffic bursts?",
    "options": {
      "A": "Ignore excess traffic",
      "B": "Buffer requests using queues",
      "C": "Disable authentication",
      "D": "Force synchronous processing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Queues absorb bursts and smooth processing.",
      "incorrect": {
        "A": "Ignoring traffic causes data loss.",
        "C": "Authentication must remain enabled.",
        "D": "Synchronous processing increases risk."
      }
    }
  },
  {
    "id": "CH12-0206",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Strategy",
    "subtopic": "capacity planning",
    "difficulty": "Medium",
    "question": "Why is capacity planning important for Salesforce integrations?",
    "options": {
      "A": "To avoid documentation",
      "B": "To anticipate growth and prevent outages",
      "C": "To reduce API versions",
      "D": "To simplify authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Capacity planning helps prevent performance degradation and failures.",
      "incorrect": {
        "A": "Documentation remains important.",
        "C": "Versions are unrelated.",
        "D": "Authentication is unaffected."
      }
    }
  },
  {
    "id": "CH12-0207",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Strategy",
    "subtopic": "sla definition",
    "difficulty": "Medium",
    "question": "What is the purpose of defining SLAs for Salesforce integrations?",
    "options": {
      "A": "Increase API limits",
      "B": "Set expectations for availability and performance",
      "C": "Disable monitoring",
      "D": "Avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLAs define acceptable service levels.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "Monitoring supports SLAs.",
        "D": "Testing remains essential."
      }
    }
  },
  {
    "id": "CH12-0208",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Strategy",
    "subtopic": "incident escalation",
    "difficulty": "Easy",
    "question": "Why is an incident escalation process required for integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To ensure timely response to critical failures",
      "C": "To simplify mappings",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Escalation ensures critical issues are handled promptly.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Mappings are unaffected.",
        "D": "Documentation remains important."
      }
    }
  },
  {
    "id": "CH12-0209",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Strategy",
    "subtopic": "on-call rotation",
    "difficulty": "Easy",
    "question": "What is the benefit of an on-call rotation for integration teams?",
    "options": {
      "A": "Reduced testing effort",
      "B": "Continuous coverage for production issues",
      "C": "Higher API limits",
      "D": "Simpler deployments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "On-call rotations ensure availability to handle incidents.",
      "incorrect": {
        "A": "Testing remains essential.",
        "C": "Limits are unchanged.",
        "D": "Deployments are unaffected."
      }
    }
  },
  {
    "id": "CH12-0210",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operational Strategy",
    "subtopic": "postmortems",
    "difficulty": "Medium",
    "question": "Why are post-incident postmortems valuable?",
    "options": {
      "A": "To assign blame",
      "B": "To learn and prevent recurrence",
      "C": "To reduce API limits",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Postmortems drive continuous improvement.",
      "incorrect": {
        "A": "Blame cultures are counterproductive.",
        "C": "Limits are unrelated.",
        "D": "Monitoring remains critical."
      }
    }
  },

  {
    "id": "CH12-0211",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Review",
    "subtopic": "long-term sustainability",
    "difficulty": "Easy",
    "question": "What supports long-term sustainability of Salesforce integrations?",
    "options": {
      "A": "Hard-coded logic",
      "B": "Governance, documentation, and automation",
      "C": "Minimal testing",
      "D": "Single environment support"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainable integrations rely on structure and automation.",
      "incorrect": {
        "A": "Hard-coding increases fragility.",
        "C": "Testing is essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0212",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Review",
    "subtopic": "technology evolution",
    "difficulty": "Medium",
    "question": "Why must Salesforce integrations adapt to technology evolution?",
    "options": {
      "A": "To avoid refactoring",
      "B": "To remain compatible with platform changes",
      "C": "To increase API limits",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform evolution can impact existing integrations.",
      "incorrect": {
        "A": "Refactoring may still be needed.",
        "C": "Limits are unchanged.",
        "D": "OAuth remains required."
      }
    }
  },
  {
    "id": "CH12-0213",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Review",
    "subtopic": "platform roadmap",
    "difficulty": "Medium",
    "question": "Why should Salesforce platform roadmaps be reviewed by integration teams?",
    "options": {
      "A": "To increase API limits",
      "B": "To anticipate upcoming changes impacting integrations",
      "C": "To reduce testing",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Roadmaps help teams prepare for upcoming changes.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing remains essential.",
        "D": "Governance is required."
      }
    }
  },
  {
    "id": "CH12-0214",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Strategic Review",
    "subtopic": "continuous improvement",
    "difficulty": "Easy",
    "question": "Why is continuous improvement critical for integrations?",
    "options": {
      "A": "To eliminate documentation",
      "B": "To adapt to changing business and technical needs",
      "C": "To increase API limits",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Continuous improvement keeps integrations relevant and reliable.",
      "incorrect": {
        "A": "Documentation remains essential.",
        "C": "Limits are unchanged.",
        "D": "Monitoring is required."
      }
    }
  },
  {
    "id": "CH12-0215",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "enterprise readiness",
    "difficulty": "Easy",
    "question": "Which attribute best defines enterprise-ready Salesforce integrations?",
    "options": {
      "A": "Hard-coded endpoints",
      "B": "Resilience, observability, and governance",
      "C": "Minimal testing",
      "D": "Single environment deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise readiness requires resilience and governance.",
      "incorrect": {
        "A": "Hard-coding increases risk.",
        "C": "Testing is essential.",
        "D": "Multiple environments are needed."
      }
    }
  },
  {
    "id": "CH12-0216",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration excellence",
    "difficulty": "Easy",
    "question": "What best characterizes Salesforce integration excellence?",
    "options": {
      "A": "Fast development only",
      "B": "Balanced focus on design, operations, and security",
      "C": "Avoiding refactoring",
      "D": "Minimal monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excellence requires balance across disciplines.",
      "incorrect": {
        "A": "Speed alone is insufficient.",
        "C": "Refactoring is often required.",
        "D": "Monitoring is mandatory."
      }
    }
  },
  {
    "id": "CH12-0217",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "developer ownership",
    "difficulty": "Easy",
    "question": "What is the developer’s role in Salesforce integrations?",
    "options": {
      "A": "Initial implementation only",
      "B": "Full lifecycle ownership and continuous improvement",
      "C": "Avoid documentation",
      "D": "Ignore runtime issues"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Developers own integrations throughout their lifecycle.",
      "incorrect": {
        "A": "Ownership is continuous.",
        "C": "Documentation is essential.",
        "D": "Runtime behavior must be monitored."
      }
    }
  },
  {
    "id": "CH12-0218",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key lesson",
    "difficulty": "Easy",
    "question": "What is the key lesson from large-scale Salesforce integrations?",
    "options": {
      "A": "Avoid complexity entirely",
      "B": "Design for failure and recovery",
      "C": "Disable monitoring",
      "D": "Rely solely on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Failures are inevitable and must be planned for.",
      "incorrect": {
        "A": "Complexity must be managed, not avoided.",
        "C": "Monitoring is essential.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0219",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam perspective",
    "difficulty": "Easy",
    "question": "From an exam perspective, what is most important in Salesforce integration scenarios?",
    "options": {
      "A": "Memorizing API names",
      "B": "Understanding trade-offs and design decisions",
      "C": "Ignoring edge cases",
      "D": "Avoiding hands-on practice"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario-based reasoning.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "Edge cases are tested.",
        "D": "Hands-on practice is crucial."
      }
    }
  },
  {
    "id": "CH12-0220",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "What is the final insight for mastering Salesforce integrations?",
    "options": {
      "A": "Focus only on connectors",
      "B": "Think holistically across architecture, data, and operations",
      "C": "Avoid governance",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Holistic thinking ensures robust integrations.",
      "incorrect": {
        "A": "Connectors are only part of the solution.",
        "C": "Governance is required.",
        "D": "Error handling is mandatory."
      }
    }
  },
  {
    "id": "CH12-0221",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration maturity",
    "difficulty": "Easy",
    "question": "Which factor best indicates mature Salesforce integrations?",
    "options": {
      "A": "Manual deployments",
      "B": "Automated, observable, and governed systems",
      "C": "Minimal documentation",
      "D": "Single environment usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is reflected in automation and governance.",
      "incorrect": {
        "A": "Manual processes increase risk.",
        "C": "Documentation is necessary.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0222",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational mindset",
    "difficulty": "Easy",
    "question": "What operational mindset best supports Salesforce integrations?",
    "options": {
      "A": "Reactive only",
      "B": "Proactive monitoring and improvement",
      "C": "Avoiding alerts",
      "D": "Ignoring metrics"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proactive operations reduce incidents.",
      "incorrect": {
        "A": "Reactive approaches increase downtime.",
        "C": "Alerts are necessary.",
        "D": "Metrics provide insight."
      }
    }
  },
  {
    "id": "CH12-0223",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "long-term success",
    "difficulty": "Easy",
    "question": "What most contributes to long-term success of Salesforce integrations?",
    "options": {
      "A": "One-time development effort",
      "B": "Continuous ownership and improvement",
      "C": "Minimal governance",
      "D": "Hard-coded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-term success requires ongoing care.",
      "incorrect": {
        "A": "Integrations persist beyond projects.",
        "C": "Governance is critical.",
        "D": "Hard-coding increases fragility."
      }
    }
  },
  {
    "id": "CH12-0224",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "design philosophy",
    "difficulty": "Easy",
    "question": "Which design philosophy best suits Salesforce integrations?",
    "options": {
      "A": "Tight coupling",
      "B": "Loose coupling with clear contracts",
      "C": "Minimal testing",
      "D": "Hard-coded configurations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves resilience and change tolerance.",
      "incorrect": {
        "A": "Tight coupling increases risk.",
        "C": "Testing is essential.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "CH12-0225",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam readiness",
    "difficulty": "Easy",
    "question": "What best prepares candidates for Salesforce integration exam questions?",
    "options": {
      "A": "Memorizing syntax",
      "B": "Understanding real-world integration scenarios",
      "C": "Ignoring non-functional aspects",
      "D": "Avoiding hands-on work"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams focus on applied understanding.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "Non-functional aspects are tested.",
        "D": "Hands-on experience is important."
      }
    }
  },
  {
    "id": "CH12-0226",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration balance",
    "difficulty": "Easy",
    "question": "Which balance is essential in Salesforce integrations?",
    "options": {
      "A": "Speed over quality",
      "B": "Flexibility, security, and performance",
      "C": "Minimal logging",
      "D": "Single environment focus"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Balanced design ensures sustainability.",
      "incorrect": {
        "A": "Quality cannot be sacrificed.",
        "C": "Logging is necessary.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0227",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational discipline",
    "difficulty": "Easy",
    "question": "What demonstrates strong operational discipline in integrations?",
    "options": {
      "A": "Manual fixes",
      "B": "Defined processes, automation, and monitoring",
      "C": "Minimal testing",
      "D": "Ignoring metrics"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Discipline relies on structured operations.",
      "incorrect": {
        "A": "Manual fixes increase risk.",
        "C": "Testing is essential.",
        "D": "Metrics provide insight."
      }
    }
  },
  {
    "id": "CH12-0228",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing principle",
    "difficulty": "Easy",
    "question": "Which principle should guide all Salesforce integrations?",
    "options": {
      "A": "Avoid governance",
      "B": "Design for change and resilience",
      "C": "Hard-code business rules",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Change is inevitable and must be planned for.",
      "incorrect": {
        "A": "Governance is essential.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Error handling is required."
      }
    }
  },
  {
    "id": "CH12-0229",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "overall takeaway",
    "difficulty": "Easy",
    "question": "What is the overall takeaway for Salesforce integrations with MuleSoft?",
    "options": {
      "A": "Focus only on implementation",
      "B": "Treat integrations as long-lived products",
      "C": "Avoid monitoring",
      "D": "Rely only on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product thinking ensures sustainability.",
      "incorrect": {
        "A": "Implementation is only the start.",
        "C": "Monitoring is mandatory.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0230",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "final message",
    "difficulty": "Easy",
    "question": "Which statement best summarizes enterprise Salesforce integration success?",
    "options": {
      "A": "Build fast and forget",
      "B": "Design holistically across data, APIs, and operations",
      "C": "Avoid governance",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Holistic design ensures long-term success.",
      "incorrect": {
        "A": "Integrations require ongoing care.",
        "C": "Governance is required.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH12-0231",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Consumption",
    "subtopic": "rest vs soap",
    "difficulty": "Medium",
    "question": "Why is REST API generally preferred over SOAP for Salesforce integrations?",
    "options": {
      "A": "SOAP does not support authentication",
      "B": "REST is lightweight and easier to consume",
      "C": "REST bypasses Salesforce limits",
      "D": "SOAP cannot return JSON"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "REST APIs are lightweight, easier to integrate, and widely supported.",
      "incorrect": {
        "A": "SOAP supports authentication.",
        "C": "Limits still apply.",
        "D": "SOAP can return structured responses."
      }
    }
  },
  {
    "id": "CH12-0232",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Consumption",
    "subtopic": "http methods",
    "difficulty": "Easy",
    "question": "Which HTTP method is typically used to update an existing Salesforce record?",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PATCH",
      "D": "OPTIONS"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "PATCH is used to partially update Salesforce records.",
      "incorrect": {
        "A": "GET retrieves data.",
        "B": "POST usually creates data.",
        "D": "OPTIONS is for metadata."
      }
    }
  },
  {
    "id": "CH12-0233",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Consumption",
    "subtopic": "http status handling",
    "difficulty": "Medium",
    "question": "What does HTTP status code 401 indicate when calling Salesforce APIs?",
    "options": {
      "A": "Insufficient permissions",
      "B": "Authentication failure",
      "C": "Resource not found",
      "D": "Request timeout"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "401 indicates authentication issues such as invalid or expired tokens.",
      "incorrect": {
        "A": "This is usually 403.",
        "C": "404 indicates missing resources.",
        "D": "408 indicates timeout."
      }
    }
  },
  {
    "id": "CH12-0234",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Bulk Processing",
    "subtopic": "bulk api usage",
    "difficulty": "Medium",
    "question": "When should the Salesforce Bulk API be preferred?",
    "options": {
      "A": "For real-time queries",
      "B": "For large data volumes",
      "C": "For metadata updates",
      "D": "For event subscriptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk API is designed for handling large data volumes efficiently.",
      "incorrect": {
        "A": "REST is better for real-time.",
        "C": "Metadata API handles metadata.",
        "D": "Events use streaming APIs."
      }
    }
  },
  {
    "id": "CH12-0235",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Bulk Processing",
    "subtopic": "bulk api limits",
    "difficulty": "Hard",
    "question": "What is a key constraint when using Salesforce Bulk API?",
    "options": {
      "A": "No authentication support",
      "B": "Job and batch size limits",
      "C": "No error reporting",
      "D": "Synchronous execution only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulk API enforces limits on job and batch sizes.",
      "incorrect": {
        "A": "Authentication is supported.",
        "C": "Errors are reported per batch.",
        "D": "Bulk processing is asynchronous."
      }
    }
  },
  {
    "id": "CH12-0236",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "jwt bearer flow",
    "difficulty": "Hard",
    "question": "Why is the JWT Bearer OAuth flow commonly used in server-to-server Salesforce integrations?",
    "options": {
      "A": "It requires user interaction",
      "B": "It avoids storing user credentials",
      "C": "It increases API limits",
      "D": "It disables token expiration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "JWT flow enables secure, non-interactive authentication without storing user credentials.",
      "incorrect": {
        "A": "JWT is non-interactive.",
        "C": "Limits are unaffected.",
        "D": "Tokens still expire."
      }
    }
  },
  {
    "id": "CH12-0237",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "connected app",
    "difficulty": "Medium",
    "question": "What is the role of a Connected App in Salesforce integrations?",
    "options": {
      "A": "Execute SOQL queries",
      "B": "Define OAuth policies and access",
      "C": "Manage API limits",
      "D": "Transform payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Connected Apps define OAuth scopes, policies, and access controls.",
      "incorrect": {
        "A": "Queries are executed via APIs.",
        "C": "Limits are platform-defined.",
        "D": "Transformations occur externally."
      }
    }
  },
  {
    "id": "CH12-0238",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Authentication",
    "subtopic": "oauth scopes",
    "difficulty": "Medium",
    "question": "Why should OAuth scopes be minimized in Salesforce integrations?",
    "options": {
      "A": "To improve performance",
      "B": "To enforce least-privilege access",
      "C": "To avoid token expiration",
      "D": "To reduce API latency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Minimized scopes reduce security exposure.",
      "incorrect": {
        "A": "Performance impact is negligible.",
        "C": "Expiration is unrelated.",
        "D": "Latency is unaffected."
      }
    }
  },
  {
    "id": "CH12-0239",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Management",
    "subtopic": "partial failures",
    "difficulty": "Hard",
    "question": "How should partial failures be handled in bulk Salesforce operations?",
    "options": {
      "A": "Abort entire job",
      "B": "Log and retry failed records selectively",
      "C": "Ignore failures",
      "D": "Disable validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Selective retries prevent reprocessing successful records.",
      "incorrect": {
        "A": "Aborting wastes completed work.",
        "C": "Ignoring failures causes data loss.",
        "D": "Validation rules should not be disabled."
      }
    }
  },
  {
    "id": "CH12-0240",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Management",
    "subtopic": "idempotency keys",
    "difficulty": "Hard",
    "question": "Why are idempotency keys useful in Salesforce integrations?",
    "options": {
      "A": "They increase throughput",
      "B": "They prevent duplicate record creation",
      "C": "They reduce API limits",
      "D": "They simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotency keys ensure repeated requests do not create duplicates.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Limits remain unchanged.",
        "D": "OAuth is unaffected."
      }
    }
  },

  {
    "id": "CH12-0241",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Modeling",
    "subtopic": "external ids",
    "difficulty": "Medium",
    "question": "Why are External IDs important in Salesforce integrations?",
    "options": {
      "A": "They replace record IDs",
      "B": "They support upsert operations",
      "C": "They disable validation rules",
      "D": "They increase API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External IDs allow systems to upsert records reliably.",
      "incorrect": {
        "A": "Salesforce IDs still exist.",
        "C": "Validation rules still apply.",
        "D": "Limits are unchanged."
      }
    }
  },
  {
    "id": "CH12-0242",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Modeling",
    "subtopic": "lookup vs master-detail",
    "difficulty": "Medium",
    "question": "Why does relationship type matter in Salesforce integrations?",
    "options": {
      "A": "It affects record visibility and deletion behavior",
      "B": "It controls OAuth scopes",
      "C": "It changes API limits",
      "D": "It simplifies transformations"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Relationship types affect cascading deletes and access.",
      "incorrect": {
        "B": "OAuth is unrelated.",
        "C": "Limits are unaffected.",
        "D": "Transformations are separate."
      }
    }
  },
  {
    "id": "CH12-0243",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance",
    "subtopic": "selective soql",
    "difficulty": "Medium",
    "question": "What makes a SOQL query selective?",
    "options": {
      "A": "Using ORDER BY",
      "B": "Filtering on indexed fields",
      "C": "Selecting many fields",
      "D": "Avoiding WHERE clause"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Indexed fields improve selectivity and performance.",
      "incorrect": {
        "A": "Sorting does not ensure selectivity.",
        "C": "More fields increase payload size.",
        "D": "WHERE clause is essential."
      }
    }
  },
  {
    "id": "CH12-0244",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance",
    "subtopic": "query limits",
    "difficulty": "Hard",
    "question": "What risk arises from non-selective SOQL queries?",
    "options": {
      "A": "OAuth failures",
      "B": "Query timeout or governor limit errors",
      "C": "Token expiration",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Non-selective queries can exceed limits and fail.",
      "incorrect": {
        "A": "Authentication is unrelated.",
        "C": "Token expiry is separate.",
        "D": "Schema mismatch is unrelated."
      }
    }
  },
  {
    "id": "CH12-0245",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "circuit breaker",
    "difficulty": "Hard",
    "question": "Why are circuit breakers used in Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To prevent cascading failures",
      "C": "To disable retries",
      "D": "To simplify payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Circuit breakers stop repeated failures from overwhelming systems.",
      "incorrect": {
        "A": "Speed is not the goal.",
        "C": "Retries may still occur.",
        "D": "Payloads are unrelated."
      }
    }
  },
  {
    "id": "CH12-0246",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "fallback strategy",
    "difficulty": "Medium",
    "question": "What is a fallback strategy in Salesforce integrations?",
    "options": {
      "A": "Retry indefinitely",
      "B": "Provide an alternative response when failure occurs",
      "C": "Disable authentication",
      "D": "Ignore errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fallbacks maintain partial functionality during failures.",
      "incorrect": {
        "A": "Infinite retries increase load.",
        "C": "Authentication must remain enabled.",
        "D": "Errors must be handled."
      }
    }
  },
  {
    "id": "CH12-0247",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "environment parity",
    "difficulty": "Medium",
    "question": "Why is environment parity important in Salesforce integrations?",
    "options": {
      "A": "To reduce API limits",
      "B": "To ensure behavior consistency across environments",
      "C": "To simplify OAuth",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parity prevents environment-specific failures.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "OAuth remains the same.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH12-0248",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "rollback strategy",
    "difficulty": "Medium",
    "question": "Why should rollback strategies exist for Salesforce integrations?",
    "options": {
      "A": "To increase speed",
      "B": "To recover quickly from failed releases",
      "C": "To disable logging",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rollbacks reduce downtime when deployments fail.",
      "incorrect": {
        "A": "Speed is secondary.",
        "C": "Logging remains important.",
        "D": "Testing is still required."
      }
    }
  },
  {
    "id": "CH12-0249",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "config externalization",
    "difficulty": "Easy",
    "question": "Why should configuration be externalized in integrations?",
    "options": {
      "A": "To hard-code values",
      "B": "To promote environment-specific flexibility",
      "C": "To reduce security",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External configuration enables safer deployments across environments.",
      "incorrect": {
        "A": "Hard-coding is risky.",
        "C": "Security must be preserved.",
        "D": "Governance is still required."
      }
    }
  },
  {
    "id": "CH12-0250",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "secrets management",
    "difficulty": "Easy",
    "question": "What is the correct approach for managing secrets in Salesforce integrations?",
    "options": {
      "A": "Store in source code",
      "B": "Use secure vaults or secret managers",
      "C": "Log them for debugging",
      "D": "Share across teams"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Secrets must be stored securely and never exposed.",
      "incorrect": {
        "A": "Source code exposure is insecure.",
        "C": "Logging secrets is dangerous.",
        "D": "Secrets must be restricted."
      }
    }
  },

  {
    "id": "CH12-0251",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration robustness",
    "difficulty": "Easy",
    "question": "What most improves robustness of Salesforce integrations?",
    "options": {
      "A": "Hard-coded logic",
      "B": "Error handling, retries, and monitoring",
      "C": "Minimal testing",
      "D": "Single environment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Robust integrations rely on resilience patterns.",
      "incorrect": {
        "A": "Hard-coding increases fragility.",
        "C": "Testing is essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0252",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational visibility",
    "difficulty": "Easy",
    "question": "Why is operational visibility critical for Salesforce integrations?",
    "options": {
      "A": "To increase API speed",
      "B": "To detect and resolve issues quickly",
      "C": "To disable retries",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Visibility enables fast diagnosis and recovery.",
      "incorrect": {
        "A": "Speed is not the primary goal.",
        "C": "Retries may still be needed.",
        "D": "Governance is necessary."
      }
    }
  },
  {
    "id": "CH12-0253",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "design maturity",
    "difficulty": "Easy",
    "question": "Which characteristic indicates mature Salesforce integration design?",
    "options": {
      "A": "Tight coupling",
      "B": "Loose coupling with clear contracts",
      "C": "Minimal logging",
      "D": "Hard-coded endpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling improves long-term sustainability.",
      "incorrect": {
        "A": "Tight coupling increases risk.",
        "C": "Logging is essential.",
        "D": "Hard-coding reduces flexibility."
      }
    }
  },
  {
    "id": "CH12-0254",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam success",
    "difficulty": "Easy",
    "question": "What is most important for success in Salesforce integration exam questions?",
    "options": {
      "A": "Memorizing error codes",
      "B": "Understanding design trade-offs",
      "C": "Ignoring operational concerns",
      "D": "Avoiding scenario questions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario-based decision making.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "Operational aspects are tested.",
        "D": "Scenario questions are core."
      }
    }
  },
  {
    "id": "CH12-0255",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing principle",
    "difficulty": "Easy",
    "question": "Which principle should guide Salesforce integrations at scale?",
    "options": {
      "A": "Speed over stability",
      "B": "Design for change and failure",
      "C": "Minimal governance",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scalable integrations assume change and failure.",
      "incorrect": {
        "A": "Stability is critical.",
        "C": "Governance is essential.",
        "D": "Monitoring is mandatory."
      }
    }
  },

  {
    "id": "CH12-0256",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "long term ownership",
    "difficulty": "Easy",
    "question": "What ensures long-term success of Salesforce integrations?",
    "options": {
      "A": "One-time development",
      "B": "Continuous ownership and improvement",
      "C": "Avoiding refactoring",
      "D": "Minimal testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations require ongoing care.",
      "incorrect": {
        "A": "Integrations persist beyond projects.",
        "C": "Refactoring may be required.",
        "D": "Testing is essential."
      }
    }
  },
  {
    "id": "CH12-0257",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "architecture mindset",
    "difficulty": "Easy",
    "question": "Which mindset best supports Salesforce integration architecture?",
    "options": {
      "A": "Point-to-point focus",
      "B": "API-led and reusable design",
      "C": "Hard-coded integrations",
      "D": "Minimal abstraction"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led design promotes reuse and scalability.",
      "incorrect": {
        "A": "Point-to-point increases fragility.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Abstraction improves maintainability."
      }
    }
  },
  {
    "id": "CH12-0258",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "security priority",
    "difficulty": "Easy",
    "question": "What should always be a top priority in Salesforce integrations?",
    "options": {
      "A": "Performance only",
      "B": "Security and least privilege",
      "C": "Minimal documentation",
      "D": "Rapid delivery"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security cannot be compromised.",
      "incorrect": {
        "A": "Performance alone is insufficient.",
        "C": "Documentation is necessary.",
        "D": "Speed must be balanced."
      }
    }
  },
  {
    "id": "CH12-0259",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational excellence",
    "difficulty": "Easy",
    "question": "What defines operational excellence in Salesforce integrations?",
    "options": {
      "A": "Manual monitoring",
      "B": "Automation, monitoring, and governance",
      "C": "Minimal alerts",
      "D": "Single deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excellence depends on automation and visibility.",
      "incorrect": {
        "A": "Manual approaches do not scale.",
        "C": "Alerts are essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0260",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "final takeaway",
    "difficulty": "Easy",
    "question": "What is the ultimate takeaway for enterprise Salesforce integrations?",
    "options": {
      "A": "Build quickly and forget",
      "B": "Treat integrations as long-lived products",
      "C": "Avoid monitoring",
      "D": "Disable error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product thinking ensures sustainability.",
      "incorrect": {
        "A": "Integrations require ongoing care.",
        "C": "Monitoring is mandatory.",
        "D": "Error handling is required."
      }
    }
  },
  {
    "id": "CH12-0261",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Streaming APIs",
    "subtopic": "push topics",
    "difficulty": "Medium",
    "question": "What is a key limitation of Salesforce PushTopics compared to Change Data Capture?",
    "options": {
      "A": "They do not support replay",
      "B": "They require explicit SOQL definition",
      "C": "They cannot be consumed externally",
      "D": "They bypass sharing rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PushTopics require predefined SOQL queries, making them less flexible.",
      "incorrect": {
        "A": "Replay is limited but not the core issue.",
        "C": "External consumption is supported.",
        "D": "Sharing rules still apply."
      }
    }
  },
  {
    "id": "CH12-0262",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Streaming APIs",
    "subtopic": "cdc advantages",
    "difficulty": "Medium",
    "question": "Why is Change Data Capture preferred for near-real-time Salesforce integrations?",
    "options": {
      "A": "It eliminates API limits",
      "B": "It captures all data changes automatically",
      "C": "It replaces REST APIs",
      "D": "It disables validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "CDC publishes create, update, delete events automatically.",
      "incorrect": {
        "A": "Limits still apply.",
        "C": "REST APIs are still required.",
        "D": "Validation rules remain active."
      }
    }
  },
  {
    "id": "CH12-0263",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Streaming APIs",
    "subtopic": "event volume",
    "difficulty": "Hard",
    "question": "What must be considered when consuming high volumes of Salesforce CDC events?",
    "options": {
      "A": "OAuth scope selection",
      "B": "Backpressure and consumer scalability",
      "C": "API versioning",
      "D": "Metadata deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High event volumes require scalable consumers and buffering.",
      "incorrect": {
        "A": "Scopes are unrelated.",
        "C": "Versioning does not address volume.",
        "D": "Metadata is unrelated."
      }
    }
  },
  {
    "id": "CH12-0264",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Integrity",
    "subtopic": "transaction boundaries",
    "difficulty": "Hard",
    "question": "Why are transaction boundaries important in Salesforce integrations?",
    "options": {
      "A": "They control API limits",
      "B": "They define atomic success or failure of operations",
      "C": "They simplify OAuth",
      "D": "They reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transactions ensure operations either fully succeed or fail.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "OAuth is unaffected.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH12-0265",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Integrity",
    "subtopic": "partial commits",
    "difficulty": "Hard",
    "question": "What risk do partial commits introduce in distributed integrations?",
    "options": {
      "A": "Reduced performance",
      "B": "Inconsistent system state",
      "C": "OAuth token expiry",
      "D": "Schema mismatch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Partial commits can leave systems in inconsistent states.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Token expiry is unrelated.",
        "D": "Schema mismatch is unrelated."
      }
    }
  },
  {
    "id": "CH12-0266",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Upsert Strategy",
    "subtopic": "external id selection",
    "difficulty": "Medium",
    "question": "What is a key requirement for a field used as an External ID?",
    "options": {
      "A": "It must be encrypted",
      "B": "It should be unique and immutable",
      "C": "It must be a formula field",
      "D": "It must be system-generated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "External IDs must uniquely and consistently identify records.",
      "incorrect": {
        "A": "Encryption is optional.",
        "C": "Formula fields are not ideal.",
        "D": "They can be business-defined."
      }
    }
  },
  {
    "id": "CH12-0267",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Upsert Strategy",
    "subtopic": "duplicate prevention",
    "difficulty": "Medium",
    "question": "How do External IDs help prevent duplicates during integration?",
    "options": {
      "A": "By enforcing governor limits",
      "B": "By enabling idempotent upsert operations",
      "C": "By disabling validation rules",
      "D": "By replacing Salesforce IDs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Upserts using External IDs avoid duplicate record creation.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Validation still applies.",
        "D": "Salesforce IDs still exist."
      }
    }
  },
  {
    "id": "CH12-0268",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Batch Processing",
    "subtopic": "batch size tuning",
    "difficulty": "Hard",
    "question": "Why must batch sizes be tuned carefully in Salesforce integrations?",
    "options": {
      "A": "To avoid OAuth failures",
      "B": "To balance throughput and governor limits",
      "C": "To simplify payload mapping",
      "D": "To avoid schema changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Oversized batches risk governor limit violations.",
      "incorrect": {
        "A": "OAuth is unaffected.",
        "C": "Mapping complexity is unrelated.",
        "D": "Schema changes are unrelated."
      }
    }
  },
  {
    "id": "CH12-0269",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Batch Processing",
    "subtopic": "failure isolation",
    "difficulty": "Medium",
    "question": "Why should batch failures be isolated rather than failing entire jobs?",
    "options": {
      "A": "To reduce API limits",
      "B": "To allow partial success and recovery",
      "C": "To disable retries",
      "D": "To simplify logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolating failures prevents reprocessing successful records.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Retries may still be needed.",
        "D": "Logging remains essential."
      }
    }
  },
  {
    "id": "CH12-0270",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Batch Processing",
    "subtopic": "reprocessing strategy",
    "difficulty": "Medium",
    "question": "What is the safest way to reprocess failed Salesforce records?",
    "options": {
      "A": "Replay the entire batch",
      "B": "Replay only failed records using identifiers",
      "C": "Disable validation rules",
      "D": "Change API versions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Targeted reprocessing avoids duplicate side effects.",
      "incorrect": {
        "A": "Replaying all records risks duplication.",
        "C": "Validation rules must remain active.",
        "D": "API versions are unrelated."
      }
    }
  },

  {
    "id": "CH12-0271",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security Architecture",
    "subtopic": "ip relaxation",
    "difficulty": "Medium",
    "question": "Why should IP relaxation be carefully controlled in Salesforce integrations?",
    "options": {
      "A": "It reduces API speed",
      "B": "It increases attack surface",
      "C": "It disables OAuth",
      "D": "It breaks connected apps"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Relaxing IP restrictions increases security exposure.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "OAuth still applies.",
        "D": "Connected apps still function."
      }
    }
  },
  {
    "id": "CH12-0272",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security Architecture",
    "subtopic": "least privilege",
    "difficulty": "Easy",
    "question": "Why should integration users follow the principle of least privilege?",
    "options": {
      "A": "To increase API limits",
      "B": "To minimize security risk",
      "C": "To simplify testing",
      "D": "To avoid OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege reduces impact of compromised credentials.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Testing is unaffected.",
        "D": "OAuth remains required."
      }
    }
  },
  {
    "id": "CH12-0273",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security Architecture",
    "subtopic": "user vs integration user",
    "difficulty": "Medium",
    "question": "Why should a dedicated integration user be used instead of a human user?",
    "options": {
      "A": "It increases API limits",
      "B": "It avoids dependency on individual accounts",
      "C": "It disables validation rules",
      "D": "It improves query performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dedicated users prevent outages caused by user changes.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Validation rules still apply.",
        "D": "Performance is unrelated."
      }
    }
  },
  {
    "id": "CH12-0274",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Observability",
    "subtopic": "correlation ids",
    "difficulty": "Medium",
    "question": "Why are correlation IDs important in Salesforce integrations?",
    "options": {
      "A": "They increase API limits",
      "B": "They enable end-to-end request tracing",
      "C": "They simplify authentication",
      "D": "They reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs help trace requests across systems.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "Authentication is unaffected.",
        "D": "Payload size is unchanged."
      }
    }
  },
  {
    "id": "CH12-0275",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Observability",
    "subtopic": "log levels",
    "difficulty": "Easy",
    "question": "Why should log levels be configurable in integrations?",
    "options": {
      "A": "To disable monitoring",
      "B": "To balance visibility and performance",
      "C": "To increase API speed",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic log levels allow troubleshooting without overhead.",
      "incorrect": {
        "A": "Monitoring is still required.",
        "C": "Speed is not the goal.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH12-0276",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience Patterns",
    "subtopic": "timeouts",
    "difficulty": "Medium",
    "question": "Why should explicit timeouts be configured in Salesforce integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To prevent resource exhaustion",
      "C": "To disable retries",
      "D": "To simplify payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timeouts prevent threads from being blocked indefinitely.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Retries may still be used.",
        "D": "Payloads are unrelated."
      }
    }
  },
  {
    "id": "CH12-0277",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience Patterns",
    "subtopic": "retry backoff",
    "difficulty": "Hard",
    "question": "Why is exponential backoff preferred for retries?",
    "options": {
      "A": "It increases throughput",
      "B": "It reduces pressure on recovering systems",
      "C": "It disables error handling",
      "D": "It avoids OAuth refresh"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backoff prevents overwhelming systems during recovery.",
      "incorrect": {
        "A": "Throughput is secondary.",
        "C": "Error handling remains necessary.",
        "D": "OAuth refresh is unrelated."
      }
    }
  },
  {
    "id": "CH12-0278",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment Strategy",
    "subtopic": "feature flags",
    "difficulty": "Medium",
    "question": "Why are feature flags useful in Salesforce integrations?",
    "options": {
      "A": "They increase API limits",
      "B": "They enable controlled rollout of changes",
      "C": "They simplify OAuth",
      "D": "They disable validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Feature flags reduce risk by allowing gradual enablement.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "OAuth is unaffected.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH12-0279",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment Strategy",
    "subtopic": "config drift",
    "difficulty": "Medium",
    "question": "What risk does configuration drift introduce?",
    "options": {
      "A": "Higher API limits",
      "B": "Unexpected behavior across environments",
      "C": "OAuth failures",
      "D": "Schema mismatches"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Drift causes environment inconsistencies and defects.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth is unrelated.",
        "D": "Schema mismatch is separate."
      }
    }
  },
  {
    "id": "CH12-0280",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment Strategy",
    "subtopic": "immutable artifacts",
    "difficulty": "Medium",
    "question": "Why should integration artifacts be immutable once built?",
    "options": {
      "A": "To simplify logging",
      "B": "To ensure deployment consistency",
      "C": "To increase API limits",
      "D": "To avoid testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures the same artifact runs everywhere.",
      "incorrect": {
        "A": "Logging is unrelated.",
        "C": "Limits are unchanged.",
        "D": "Testing is still required."
      }
    }
  },

  {
    "id": "CH12-0281",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Enterprise Readiness",
    "subtopic": "governance enforcement",
    "difficulty": "Medium",
    "question": "Why is governance enforcement critical at scale?",
    "options": {
      "A": "To slow development",
      "B": "To ensure consistency and compliance",
      "C": "To reduce API speed",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Governance ensures standards are consistently applied.",
      "incorrect": {
        "A": "Governance enables safe speed.",
        "C": "Speed is unaffected.",
        "D": "Monitoring remains essential."
      }
    }
  },
  {
    "id": "CH12-0282",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Enterprise Readiness",
    "subtopic": "shared services",
    "difficulty": "Medium",
    "question": "What is the benefit of shared integration services?",
    "options": {
      "A": "Increased coupling",
      "B": "Reuse and reduced duplication",
      "C": "Higher API limits",
      "D": "Reduced security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared services promote reuse and consistency.",
      "incorrect": {
        "A": "Coupling should be minimized.",
        "C": "Limits are unchanged.",
        "D": "Security must remain strong."
      }
    }
  },
  {
    "id": "CH12-0283",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Enterprise Readiness",
    "subtopic": "ownership model",
    "difficulty": "Easy",
    "question": "Why must ownership models be clearly defined?",
    "options": {
      "A": "To increase API limits",
      "B": "To ensure accountability",
      "C": "To simplify OAuth",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership prevents operational gaps.",
      "incorrect": {
        "A": "Limits are unrelated.",
        "C": "OAuth is unaffected.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH12-0284",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing Strategy",
    "subtopic": "contract testing",
    "difficulty": "Medium",
    "question": "Why is contract testing valuable in Salesforce integrations?",
    "options": {
      "A": "It replaces unit tests",
      "B": "It detects breaking API changes early",
      "C": "It increases API speed",
      "D": "It disables validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract tests prevent consumer-provider mismatches.",
      "incorrect": {
        "A": "Unit tests are still required.",
        "C": "Speed is unaffected.",
        "D": "Validation rules remain active."
      }
    }
  },
  {
    "id": "CH12-0285",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing Strategy",
    "subtopic": "test isolation",
    "difficulty": "Medium",
    "question": "Why should integration tests be isolated?",
    "options": {
      "A": "To increase API limits",
      "B": "To ensure repeatable and reliable results",
      "C": "To disable authentication",
      "D": "To simplify payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Isolation prevents interference from other tests.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication is still required.",
        "D": "Payloads are unrelated."
      }
    }
  },
  {
    "id": "CH12-0286",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Awareness",
    "subtopic": "api consumption",
    "difficulty": "Easy",
    "question": "Why should API consumption be monitored continuously?",
    "options": {
      "A": "To reduce development effort",
      "B": "To avoid hitting platform limits",
      "C": "To simplify OAuth",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Monitoring prevents outages caused by exhausted limits.",
      "incorrect": {
        "A": "Effort is unrelated.",
        "C": "OAuth is unaffected.",
        "D": "Retries are still needed."
      }
    }
  },
  {
    "id": "CH12-0287",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Awareness",
    "subtopic": "inefficient polling",
    "difficulty": "Medium",
    "question": "Why is excessive polling discouraged in Salesforce integrations?",
    "options": {
      "A": "It improves data freshness",
      "B": "It wastes API calls and resources",
      "C": "It simplifies design",
      "D": "It avoids CDC usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Polling consumes limits without guaranteed changes.",
      "incorrect": {
        "A": "Freshness is not guaranteed.",
        "C": "Design becomes less efficient.",
        "D": "CDC is often preferable."
      }
    }
  },
  {
    "id": "CH12-0288",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Review",
    "subtopic": "point-to-point risk",
    "difficulty": "Medium",
    "question": "What is a major drawback of point-to-point integrations?",
    "options": {
      "A": "Low performance",
      "B": "Poor scalability and maintainability",
      "C": "OAuth incompatibility",
      "D": "Schema rigidity"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Point-to-point designs scale poorly and increase coupling.",
      "incorrect": {
        "A": "Performance may vary.",
        "C": "OAuth still works.",
        "D": "Schema rigidity is not inherent."
      }
    }
  },
  {
    "id": "CH12-0289",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Review",
    "subtopic": "api-led benefits",
    "difficulty": "Easy",
    "question": "What is a primary benefit of API-led connectivity?",
    "options": {
      "A": "Reduced security",
      "B": "Reuse and loose coupling",
      "C": "Higher API limits",
      "D": "Less governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-led architecture promotes reuse and flexibility.",
      "incorrect": {
        "A": "Security remains strong.",
        "C": "Limits are unchanged.",
        "D": "Governance is essential."
      }
    }
  },
  {
    "id": "CH12-0290",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Review",
    "subtopic": "system api role",
    "difficulty": "Medium",
    "question": "What is the primary responsibility of a System API?",
    "options": {
      "A": "Business orchestration",
      "B": "Abstracting underlying systems",
      "C": "User experience delivery",
      "D": "Policy enforcement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "System APIs shield consumers from backend complexity.",
      "incorrect": {
        "A": "Process APIs handle orchestration.",
        "C": "Experience APIs handle UX.",
        "D": "Policies apply across layers."
      }
    }
  },

  {
    "id": "CH12-0291",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "enterprise mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports enterprise Salesforce integrations?",
    "options": {
      "A": "Quick fixes",
      "B": "Product-oriented lifecycle ownership",
      "C": "Minimal documentation",
      "D": "Ad-hoc monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise integrations require long-term ownership.",
      "incorrect": {
        "A": "Quick fixes increase risk.",
        "C": "Documentation is essential.",
        "D": "Monitoring must be systematic."
      }
    }
  },
  {
    "id": "CH12-0292",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "resilience principle",
    "difficulty": "Easy",
    "question": "Which principle best improves integration resilience?",
    "options": {
      "A": "Avoiding retries",
      "B": "Designing for failure",
      "C": "Hard-coding logic",
      "D": "Minimal logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resilient systems assume failure will occur.",
      "incorrect": {
        "A": "Retries are often necessary.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Logging is essential."
      }
    }
  },
  {
    "id": "CH12-0293",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "operational readiness",
    "difficulty": "Easy",
    "question": "What indicates strong operational readiness?",
    "options": {
      "A": "Manual deployments",
      "B": "Automation, monitoring, and alerting",
      "C": "Minimal testing",
      "D": "Single environment usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation and observability define readiness.",
      "incorrect": {
        "A": "Manual processes increase risk.",
        "C": "Testing is essential.",
        "D": "Multiple environments are required."
      }
    }
  },
  {
    "id": "CH12-0294",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "security takeaway",
    "difficulty": "Easy",
    "question": "What is the key security takeaway for Salesforce integrations?",
    "options": {
      "A": "Trust internal systems",
      "B": "Apply least privilege everywhere",
      "C": "Disable validation rules",
      "D": "Avoid auditing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege minimizes blast radius.",
      "incorrect": {
        "A": "Zero trust is preferred.",
        "C": "Validation rules must remain.",
        "D": "Auditing is critical."
      }
    }
  },
  {
    "id": "CH12-0295",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "scalability insight",
    "difficulty": "Easy",
    "question": "What most enables scalability in integrations?",
    "options": {
      "A": "Tight coupling",
      "B": "Stateless and asynchronous design",
      "C": "Hard-coded flows",
      "D": "Minimal governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless async designs scale effectively.",
      "incorrect": {
        "A": "Tight coupling limits scale.",
        "C": "Hard-coding reduces flexibility.",
        "D": "Governance is necessary."
      }
    }
  },
  {
    "id": "CH12-0296",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam focus",
    "difficulty": "Easy",
    "question": "What do Salesforce integration exams primarily test?",
    "options": {
      "A": "Syntax memorization",
      "B": "Design decisions and trade-offs",
      "C": "UI configuration",
      "D": "Metadata deployment steps"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams emphasize scenario-based reasoning.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "UI is not the focus.",
        "D": "Deployment details are secondary."
      }
    }
  },
  {
    "id": "CH12-0297",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration excellence",
    "difficulty": "Easy",
    "question": "What best defines integration excellence?",
    "options": {
      "A": "Fast delivery only",
      "B": "Balanced focus on design, security, and operations",
      "C": "Minimal testing",
      "D": "No monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excellence requires balance across disciplines.",
      "incorrect": {
        "A": "Speed alone is risky.",
        "C": "Testing is mandatory.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH12-0298",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "long-term view",
    "difficulty": "Easy",
    "question": "What ensures long-term success of Salesforce integrations?",
    "options": {
      "A": "One-time implementation",
      "B": "Continuous improvement and ownership",
      "C": "Minimal documentation",
      "D": "Ignoring failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations require ongoing evolution.",
      "incorrect": {
        "A": "They outlive projects.",
        "C": "Documentation is required.",
        "D": "Failures must be addressed."
      }
    }
  },
  {
    "id": "CH12-0299",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key lesson",
    "difficulty": "Easy",
    "question": "What is the most important lesson from enterprise Salesforce integrations?",
    "options": {
      "A": "Avoid complexity entirely",
      "B": "Design for change, failure, and scale",
      "C": "Disable governance",
      "D": "Focus only on connectors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Change and failure are inevitable at scale.",
      "incorrect": {
        "A": "Complexity must be managed.",
        "C": "Governance is essential.",
        "D": "Connectors are only part of the solution."
      }
    }
  },
  {
    "id": "CH12-0300",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing statement",
    "difficulty": "Easy",
    "question": "Which statement best summarizes Salesforce integration success?",
    "options": {
      "A": "Build fast and forget",
      "B": "Treat integrations as long-lived, governed products",
      "C": "Avoid monitoring",
      "D": "Rely solely on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product thinking ensures sustainable integrations.",
      "incorrect": {
        "A": "Integrations require ongoing care.",
        "C": "Monitoring is mandatory.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0301",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Architecture",
    "subtopic": "sync vs async",
    "difficulty": "Medium",
    "question": "When is asynchronous integration preferred over synchronous integration with Salesforce?",
    "options": {
      "A": "When immediate response is mandatory",
      "B": "When long-running or high-volume processing is required",
      "C": "When UI-driven integrations are needed",
      "D": "When OAuth tokens are short-lived"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Asynchronous integration prevents timeouts and improves scalability for heavy workloads.",
      "incorrect": {
        "A": "Synchronous is used for immediate responses.",
        "C": "UI use cases often need synchronous calls.",
        "D": "Token lifetime does not dictate sync vs async."
      }
    }
  },
  {
    "id": "CH12-0302",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Integration Architecture",
    "subtopic": "loose coupling",
    "difficulty": "Medium",
    "question": "What is the primary benefit of loose coupling in Salesforce integrations?",
    "options": {
      "A": "Higher API limits",
      "B": "Independent evolution of systems",
      "C": "Simpler authentication",
      "D": "Reduced need for monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling allows systems to change independently without breaking integrations.",
      "incorrect": {
        "A": "API limits are unchanged.",
        "C": "Authentication remains the same.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH12-0303",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Design",
    "subtopic": "contract stability",
    "difficulty": "Hard",
    "question": "Why is API contract stability critical in Salesforce integrations?",
    "options": {
      "A": "It increases API throughput",
      "B": "It prevents breaking downstream consumers",
      "C": "It eliminates versioning",
      "D": "It reduces payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts ensure consumers continue to function despite internal changes.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Versioning may still be required.",
        "D": "Payload size is not the primary concern."
      }
    }
  },
  {
    "id": "CH12-0304",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Design",
    "subtopic": "versioning strategy",
    "difficulty": "Medium",
    "question": "When should a new API version be introduced in Salesforce integrations?",
    "options": {
      "A": "For every internal code change",
      "B": "When a breaking contract change is required",
      "C": "When API limits change",
      "D": "When logging is updated"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "New versions protect existing consumers from breaking changes.",
      "incorrect": {
        "A": "Internal changes do not always require new versions.",
        "C": "Limits do not affect contracts.",
        "D": "Logging changes are non-breaking."
      }
    }
  },
  {
    "id": "CH12-0305",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "retry conditions",
    "difficulty": "Hard",
    "question": "Which type of Salesforce error is most suitable for automatic retry?",
    "options": {
      "A": "Validation rule failure",
      "B": "Temporary network failure",
      "C": "Missing required field",
      "D": "Authorization failure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transient network issues are ideal candidates for retry mechanisms.",
      "incorrect": {
        "A": "Validation errors require data correction.",
        "C": "Missing fields need payload fixes.",
        "D": "Authorization issues require security fixes."
      }
    }
  },
  {
    "id": "CH12-0306",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Error Handling",
    "subtopic": "dead letter queue",
    "difficulty": "Medium",
    "question": "What is the primary purpose of a Dead Letter Queue in integrations?",
    "options": {
      "A": "Improve performance",
      "B": "Store messages that failed repeated processing",
      "C": "Replace retries",
      "D": "Increase API limits"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DLQs allow failed messages to be reviewed and reprocessed safely.",
      "incorrect": {
        "A": "Performance is not the goal.",
        "C": "Retries still occur before DLQ.",
        "D": "API limits are unaffected."
      }
    }
  },
  {
    "id": "CH12-0307",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "eventual consistency",
    "difficulty": "Medium",
    "question": "Why is eventual consistency acceptable in many Salesforce integrations?",
    "options": {
      "A": "Salesforce does not support transactions",
      "B": "Distributed systems cannot guarantee immediate consistency",
      "C": "API limits require delays",
      "D": "OAuth enforces it"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Distributed systems trade immediate consistency for availability and scalability.",
      "incorrect": {
        "A": "Salesforce supports transactional behavior.",
        "C": "Limits are unrelated.",
        "D": "OAuth is unrelated."
      }
    }
  },
  {
    "id": "CH12-0308",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "compensating actions",
    "difficulty": "Hard",
    "question": "What is the role of compensating actions in integrations?",
    "options": {
      "A": "Increase throughput",
      "B": "Undo effects of failed downstream operations",
      "C": "Disable retries",
      "D": "Simplify logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compensating actions restore consistency when distributed steps fail.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Retries may still occur.",
        "D": "Logging is separate."
      }
    }
  },

  {
    "id": "CH12-0309",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance Optimization",
    "subtopic": "payload minimization",
    "difficulty": "Medium",
    "question": "Why should payloads be minimized in Salesforce integrations?",
    "options": {
      "A": "To reduce OAuth complexity",
      "B": "To improve performance and reduce limits usage",
      "C": "To avoid validation rules",
      "D": "To simplify retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller payloads reduce processing time and API consumption.",
      "incorrect": {
        "A": "OAuth is unaffected.",
        "C": "Validation rules still apply.",
        "D": "Retries are independent."
      }
    }
  },
  {
    "id": "CH12-0310",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Performance Optimization",
    "subtopic": "caching strategy",
    "difficulty": "Medium",
    "question": "When is caching most effective in Salesforce integrations?",
    "options": {
      "A": "For highly volatile data",
      "B": "For frequently accessed, rarely changing data",
      "C": "For write-heavy operations",
      "D": "For authentication tokens only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Caching stable data reduces repeated API calls.",
      "incorrect": {
        "A": "Volatile data risks staleness.",
        "C": "Writes should not be cached.",
        "D": "Caching applies beyond tokens."
      }
    }
  },

  {
    "id": "CH12-0311",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "token rotation",
    "difficulty": "Medium",
    "question": "Why is OAuth token rotation important?",
    "options": {
      "A": "It increases API limits",
      "B": "It reduces impact of compromised tokens",
      "C": "It improves performance",
      "D": "It removes authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Regular rotation limits exposure from leaked credentials.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Performance is unaffected.",
        "D": "Authentication remains mandatory."
      }
    }
  },
  {
    "id": "CH12-0312",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "audit logs",
    "difficulty": "Easy",
    "question": "What is the main purpose of audit logs in integrations?",
    "options": {
      "A": "Increase speed",
      "B": "Provide traceability and compliance evidence",
      "C": "Reduce payload size",
      "D": "Disable monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audit logs support security investigations and compliance.",
      "incorrect": {
        "A": "Speed is unrelated.",
        "C": "Payload size is unchanged.",
        "D": "Monitoring remains essential."
      }
    }
  },

  {
    "id": "CH12-0313",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment Strategy",
    "subtopic": "blue green",
    "difficulty": "Medium",
    "question": "What is the benefit of blue-green deployment for integrations?",
    "options": {
      "A": "Faster development",
      "B": "Near-zero downtime releases",
      "C": "Reduced testing",
      "D": "Simpler configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Blue-green deployment allows safe switching between versions.",
      "incorrect": {
        "A": "Development speed is unaffected.",
        "C": "Testing is still required.",
        "D": "Configuration remains complex."
      }
    }
  },
  {
    "id": "CH12-0314",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment Strategy",
    "subtopic": "rollback readiness",
    "difficulty": "Medium",
    "question": "Why must rollback plans be tested before production deployment?",
    "options": {
      "A": "To increase confidence",
      "B": "To ensure recovery works under pressure",
      "C": "To reduce governance",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Untested rollbacks may fail during real incidents.",
      "incorrect": {
        "A": "Confidence alone is insufficient.",
        "C": "Governance remains required.",
        "D": "Monitoring is still needed."
      }
    }
  },

  {
    "id": "CH12-0315",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "alert thresholds",
    "difficulty": "Easy",
    "question": "Why should alert thresholds be carefully tuned?",
    "options": {
      "A": "To eliminate alerts",
      "B": "To avoid alert fatigue while catching real issues",
      "C": "To increase API speed",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Proper thresholds balance visibility and noise.",
      "incorrect": {
        "A": "Alerts are necessary.",
        "C": "Speed is unrelated.",
        "D": "OAuth is unaffected."
      }
    }
  },
  {
    "id": "CH12-0316",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "sli sli",
    "difficulty": "Medium",
    "question": "Why are SLIs and SLOs important for integrations?",
    "options": {
      "A": "They increase API limits",
      "B": "They define measurable reliability goals",
      "C": "They simplify development",
      "D": "They remove the need for testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLIs/SLOs quantify expected service reliability.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Development remains complex.",
        "D": "Testing is still required."
      }
    }
  },

  {
    "id": "CH12-0317",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "standards enforcement",
    "difficulty": "Medium",
    "question": "Why are integration standards critical in large enterprises?",
    "options": {
      "A": "They slow delivery",
      "B": "They ensure consistency and maintainability",
      "C": "They reduce security",
      "D": "They eliminate documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards prevent fragmentation and technical debt.",
      "incorrect": {
        "A": "Standards enable safe speed.",
        "C": "Security is strengthened.",
        "D": "Documentation is still needed."
      }
    }
  },
  {
    "id": "CH12-0318",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "review process",
    "difficulty": "Easy",
    "question": "What is the main purpose of architectural review boards?",
    "options": {
      "A": "Approve budgets",
      "B": "Ensure designs align with enterprise standards",
      "C": "Write integration code",
      "D": "Disable innovation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reviews ensure long-term architectural health.",
      "incorrect": {
        "A": "Budgets are not the focus.",
        "C": "Boards do not implement code.",
        "D": "Innovation is guided, not blocked."
      }
    }
  },

  {
    "id": "CH12-0319",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "scalability principle",
    "difficulty": "Easy",
    "question": "What principle most improves scalability of integrations?",
    "options": {
      "A": "Stateful design",
      "B": "Stateless and asynchronous processing",
      "C": "Hard-coded workflows",
      "D": "Minimal monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless async designs scale horizontally.",
      "incorrect": {
        "A": "State increases coupling.",
        "C": "Hard-coding limits growth.",
        "D": "Monitoring is essential."
      }
    }
  },
  {
    "id": "CH12-0320",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "integration mindset",
    "difficulty": "Easy",
    "question": "What mindset best supports long-term integration success?",
    "options": {
      "A": "Project-only thinking",
      "B": "Product lifecycle ownership",
      "C": "Minimal testing",
      "D": "Quick fixes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Integrations live far beyond initial projects.",
      "incorrect": {
        "A": "Projects end, integrations persist.",
        "C": "Testing is essential.",
        "D": "Quick fixes increase risk."
      }
    }
  },

  {
    "id": "CH12-0321",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "key takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for Salesforce integration architects?",
    "options": {
      "A": "Avoid complexity at all costs",
      "B": "Design for change, failure, and growth",
      "C": "Focus only on connectors",
      "D": "Disable governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Architects must plan for evolution and scale.",
      "incorrect": {
        "A": "Complexity must be managed.",
        "C": "Connectors are only tools.",
        "D": "Governance is essential."
      }
    }
  },

  {
    "id": "CH12-0322",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "exam focus",
    "difficulty": "Easy",
    "question": "What do certification exams primarily evaluate?",
    "options": {
      "A": "Syntax memorization",
      "B": "Scenario-based design reasoning",
      "C": "UI configuration steps",
      "D": "Metadata XML structure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exams test decision-making in realistic scenarios.",
      "incorrect": {
        "A": "Memorization alone is insufficient.",
        "C": "UI is not the focus.",
        "D": "XML knowledge is secondary."
      }
    }
  },

  {
    "id": "CH12-0323",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing insight",
    "difficulty": "Easy",
    "question": "Which statement best summarizes enterprise Salesforce integration success?",
    "options": {
      "A": "Build once and forget",
      "B": "Treat integrations as governed, evolving products",
      "C": "Avoid monitoring",
      "D": "Rely only on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product thinking ensures long-term reliability.",
      "incorrect": {
        "A": "Integrations require continuous care.",
        "C": "Monitoring is mandatory.",
        "D": "Retries alone are insufficient."
      }
    }
  },
  {
    "id": "CH12-0324",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability",
    "subtopic": "horizontal scaling",
    "difficulty": "Medium",
    "question": "Why is horizontal scaling preferred for Salesforce integration runtimes?",
    "options": {
      "A": "It eliminates governor limits",
      "B": "It allows load distribution across multiple workers",
      "C": "It removes the need for retries",
      "D": "It simplifies authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Horizontal scaling distributes load, improving resilience and throughput.",
      "incorrect": {
        "A": "Governor limits still apply.",
        "C": "Retries are still needed.",
        "D": "Authentication remains unchanged."
      }
    }
  },
  {
    "id": "CH12-0325",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Scalability",
    "subtopic": "state management",
    "difficulty": "Medium",
    "question": "Why should Salesforce integrations minimize in-memory state?",
    "options": {
      "A": "To improve UI performance",
      "B": "To enable horizontal scaling and failover",
      "C": "To reduce payload size",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless designs scale better and recover faster from failures.",
      "incorrect": {
        "A": "UI performance is unrelated.",
        "C": "Payload size is unaffected.",
        "D": "OAuth is unrelated."
      }
    }
  },
  {
    "id": "CH12-0326",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "graceful degradation",
    "difficulty": "Medium",
    "question": "What does graceful degradation mean in Salesforce integrations?",
    "options": {
      "A": "Stopping all processing on failure",
      "B": "Providing limited functionality when dependencies fail",
      "C": "Retrying indefinitely",
      "D": "Ignoring errors silently"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Graceful degradation maintains partial service instead of full outage.",
      "incorrect": {
        "A": "Total stoppage increases impact.",
        "C": "Infinite retries cause overload.",
        "D": "Errors must be visible."
      }
    }
  },
  {
    "id": "CH12-0327",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Resilience",
    "subtopic": "bulkhead pattern",
    "difficulty": "Hard",
    "question": "What problem does the bulkhead pattern solve in integrations?",
    "options": {
      "A": "Authentication failures",
      "B": "Failure isolation between components",
      "C": "Schema evolution",
      "D": "Payload transformation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Bulkheads isolate failures so one component does not impact others.",
      "incorrect": {
        "A": "Authentication is separate.",
        "C": "Schema evolution is unrelated.",
        "D": "Transformations are unrelated."
      }
    }
  },
  {
    "id": "CH12-0328",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Consumption",
    "subtopic": "composite api",
    "difficulty": "Medium",
    "question": "Why is the Salesforce Composite API useful in integrations?",
    "options": {
      "A": "It bypasses governor limits",
      "B": "It reduces round trips by bundling requests",
      "C": "It replaces Bulk API",
      "D": "It disables validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composite API minimizes network calls and improves efficiency.",
      "incorrect": {
        "A": "Limits still apply.",
        "C": "Bulk API serves different use cases.",
        "D": "Validation rules still apply."
      }
    }
  },
  {
    "id": "CH12-0329",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "API Consumption",
    "subtopic": "composite limits",
    "difficulty": "Hard",
    "question": "What must be considered when using Salesforce Composite APIs?",
    "options": {
      "A": "Lack of authentication",
      "B": "Limits on number of subrequests",
      "C": "No error reporting",
      "D": "Only synchronous execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composite APIs enforce limits on bundled subrequests.",
      "incorrect": {
        "A": "Authentication is required.",
        "C": "Errors are reported per request.",
        "D": "Execution model is not the limitation."
      }
    }
  },
  {
    "id": "CH12-0330",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "source of truth",
    "difficulty": "Medium",
    "question": "Why must a single source of truth be defined in integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To prevent conflicting updates across systems",
      "C": "To simplify OAuth",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership avoids data conflicts and overwrites.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth is unrelated.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH12-0331",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Data Consistency",
    "subtopic": "conflict resolution",
    "difficulty": "Hard",
    "question": "What is a common strategy for resolving data conflicts in integrations?",
    "options": {
      "A": "Last write always wins",
      "B": "Timestamp or system-priority based resolution",
      "C": "Ignoring conflicts",
      "D": "Disabling validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deterministic rules prevent unpredictable overwrites.",
      "incorrect": {
        "A": "Last-write can cause data loss.",
        "C": "Conflicts must be handled.",
        "D": "Validation rules should remain."
      }
    }
  },
  {
    "id": "CH12-0332",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "credential rotation",
    "difficulty": "Medium",
    "question": "Why should integration credentials be rotated periodically?",
    "options": {
      "A": "To increase API speed",
      "B": "To reduce long-term security exposure",
      "C": "To simplify testing",
      "D": "To avoid monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rotation limits the impact of compromised credentials.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "Testing remains necessary.",
        "D": "Monitoring is still required."
      }
    }
  },
  {
    "id": "CH12-0333",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Security",
    "subtopic": "field-level security",
    "difficulty": "Medium",
    "question": "Why must field-level security be respected in integrations?",
    "options": {
      "A": "To improve performance",
      "B": "To prevent unauthorized data access",
      "C": "To reduce API limits",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ignoring FLS can expose sensitive data.",
      "incorrect": {
        "A": "Performance is unrelated.",
        "C": "Limits are unaffected.",
        "D": "Mappings are separate."
      }
    }
  },
  {
    "id": "CH12-0334",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "error rate metrics",
    "difficulty": "Easy",
    "question": "Why should error rates be continuously monitored?",
    "options": {
      "A": "To increase throughput",
      "B": "To detect abnormal behavior early",
      "C": "To reduce payload size",
      "D": "To simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rising error rates often indicate systemic problems.",
      "incorrect": {
        "A": "Throughput is unrelated.",
        "C": "Payload size is unaffected.",
        "D": "OAuth is unrelated."
      }
    }
  },
  {
    "id": "CH12-0335",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Monitoring",
    "subtopic": "latency tracking",
    "difficulty": "Medium",
    "question": "Why is latency tracking important for Salesforce integrations?",
    "options": {
      "A": "To remove retries",
      "B": "To identify performance degradation",
      "C": "To simplify logging",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Latency increases often signal downstream or network issues.",
      "incorrect": {
        "A": "Retries are still needed.",
        "C": "Logging remains essential.",
        "D": "Governance is still required."
      }
    }
  },
  {
    "id": "CH12-0336",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "negative testing",
    "difficulty": "Medium",
    "question": "Why is negative testing important in Salesforce integrations?",
    "options": {
      "A": "To improve performance",
      "B": "To validate error handling and resilience",
      "C": "To reduce API usage",
      "D": "To simplify mappings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Negative tests ensure systems behave correctly under failure.",
      "incorrect": {
        "A": "Performance is unrelated.",
        "C": "API usage is unchanged.",
        "D": "Mappings are unaffected."
      }
    }
  },
  {
    "id": "CH12-0337",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Testing",
    "subtopic": "mocking dependencies",
    "difficulty": "Medium",
    "question": "Why should external systems be mocked during integration testing?",
    "options": {
      "A": "To increase API limits",
      "B": "To ensure tests are repeatable and isolated",
      "C": "To avoid authentication",
      "D": "To disable validation rules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mocking removes dependency on external availability.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Authentication behavior should still be tested.",
        "D": "Validation rules remain."
      }
    }
  },
  {
    "id": "CH12-0338",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "configuration versioning",
    "difficulty": "Medium",
    "question": "Why should configuration changes be version-controlled?",
    "options": {
      "A": "To increase API speed",
      "B": "To ensure traceability and rollback",
      "C": "To simplify OAuth",
      "D": "To reduce logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Versioning allows controlled rollback and auditing.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "OAuth is unrelated.",
        "D": "Logging remains important."
      }
    }
  },
  {
    "id": "CH12-0339",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Deployment",
    "subtopic": "promotion strategy",
    "difficulty": "Medium",
    "question": "What is the safest strategy for promoting integrations across environments?",
    "options": {
      "A": "Direct production deployment",
      "B": "Progressive promotion with validation",
      "C": "Skipping QA",
      "D": "Manual configuration only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Progressive promotion reduces deployment risk.",
      "incorrect": {
        "A": "Direct deployment increases risk.",
        "C": "Skipping QA is unsafe.",
        "D": "Manual steps are error-prone."
      }
    }
  },
  {
    "id": "CH12-0340",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "policy enforcement",
    "difficulty": "Medium",
    "question": "Why is policy enforcement important in Salesforce integrations?",
    "options": {
      "A": "To reduce flexibility",
      "B": "To ensure security and compliance",
      "C": "To simplify development",
      "D": "To eliminate monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Policies ensure integrations comply with enterprise rules.",
      "incorrect": {
        "A": "Policies balance flexibility and control.",
        "C": "Development is still complex.",
        "D": "Monitoring remains required."
      }
    }
  },
  {
    "id": "CH12-0341",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Governance",
    "subtopic": "documentation",
    "difficulty": "Easy",
    "question": "Why is up-to-date documentation critical for integrations?",
    "options": {
      "A": "To increase API limits",
      "B": "To support maintenance and onboarding",
      "C": "To simplify OAuth",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Documentation enables long-term maintainability.",
      "incorrect": {
        "A": "Limits are unaffected.",
        "C": "OAuth is unrelated.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH12-0342",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operations",
    "subtopic": "incident response",
    "difficulty": "Medium",
    "question": "Why should integrations have defined incident response procedures?",
    "options": {
      "A": "To avoid alerts",
      "B": "To ensure fast and coordinated recovery",
      "C": "To reduce governance",
      "D": "To simplify payloads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear procedures reduce downtime during failures.",
      "incorrect": {
        "A": "Alerts are necessary.",
        "C": "Governance remains required.",
        "D": "Payloads are unrelated."
      }
    }
  },
  {
    "id": "CH12-0343",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Operations",
    "subtopic": "runbooks",
    "difficulty": "Easy",
    "question": "What is the primary purpose of operational runbooks?",
    "options": {
      "A": "Increase API limits",
      "B": "Guide teams during incidents",
      "C": "Replace monitoring",
      "D": "Simplify OAuth"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Runbooks provide step-by-step recovery guidance.",
      "incorrect": {
        "A": "Limits are unchanged.",
        "C": "Monitoring is still needed.",
        "D": "OAuth is unrelated."
      }
    }
  },
  {
    "id": "CH12-0344",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Management",
    "subtopic": "limit awareness",
    "difficulty": "Easy",
    "question": "Why must API limit consumption be tracked continuously?",
    "options": {
      "A": "To improve payload mapping",
      "B": "To prevent service disruption",
      "C": "To simplify authentication",
      "D": "To disable retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exceeding limits can cause outages.",
      "incorrect": {
        "A": "Mapping is unrelated.",
        "C": "Authentication is unaffected.",
        "D": "Retries are still required."
      }
    }
  },
  {
    "id": "CH12-0345",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Cost Management",
    "subtopic": "efficient design",
    "difficulty": "Medium",
    "question": "What design choice best reduces Salesforce API consumption?",
    "options": {
      "A": "Frequent polling",
      "B": "Event-driven integration",
      "C": "Synchronous batch calls",
      "D": "Manual retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Event-driven models avoid unnecessary API calls.",
      "incorrect": {
        "A": "Polling wastes API calls.",
        "C": "Synchronous batching is inefficient.",
        "D": "Manual retries increase load."
      }
    }
  },
  {
    "id": "CH12-0346",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Review",
    "subtopic": "anti-patterns",
    "difficulty": "Medium",
    "question": "Which practice is considered an integration anti-pattern?",
    "options": {
      "A": "API-led architecture",
      "B": "Hard-coded credentials",
      "C": "Externalized configuration",
      "D": "Asynchronous messaging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hard-coded credentials pose severe security risks.",
      "incorrect": {
        "A": "API-led design is recommended.",
        "C": "Externalization is best practice.",
        "D": "Async messaging improves resilience."
      }
    }
  },
  {
    "id": "CH12-0347",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Architecture Review",
    "subtopic": "evolution readiness",
    "difficulty": "Medium",
    "question": "Why should integrations be designed for evolution?",
    "options": {
      "A": "Salesforce never changes",
      "B": "Business and platforms evolve continuously",
      "C": "To avoid documentation",
      "D": "To disable governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Change is inevitable and must be planned for.",
      "incorrect": {
        "A": "Salesforce evolves frequently.",
        "C": "Documentation is required.",
        "D": "Governance remains critical."
      }
    }
  },
  {
    "id": "CH12-0348",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "enterprise success",
    "difficulty": "Easy",
    "question": "What most contributes to enterprise integration success?",
    "options": {
      "A": "Quick delivery only",
      "B": "Strong design, security, and operations",
      "C": "Minimal testing",
      "D": "Ignoring failures"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Success requires balance across multiple disciplines.",
      "incorrect": {
        "A": "Speed alone is risky.",
        "C": "Testing is mandatory.",
        "D": "Failures must be handled."
      }
    }
  },
  {
    "id": "CH12-0349",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "architect mindset",
    "difficulty": "Easy",
    "question": "What mindset should Salesforce integration architects adopt?",
    "options": {
      "A": "Project-centric thinking",
      "B": "Product and lifecycle ownership",
      "C": "Minimal governance",
      "D": "Ad-hoc monitoring"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Architects must think long-term and holistically.",
      "incorrect": {
        "A": "Projects end, integrations persist.",
        "C": "Governance is essential.",
        "D": "Monitoring must be systematic."
      }
    }
  },
  {
    "id": "CH12-0350",
    "chapter": 12,
    "chapterTitle": "Salesforce Integration",
    "topic": "Final Review",
    "subtopic": "closing takeaway",
    "difficulty": "Easy",
    "question": "Which statement best summarizes Salesforce integration best practices?",
    "options": {
      "A": "Build fast and forget",
      "B": "Design for resilience, security, and change",
      "C": "Avoid monitoring",
      "D": "Rely only on retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Best practices focus on long-term robustness.",
      "incorrect": {
        "A": "Integrations require continuous care.",
        "C": "Monitoring is mandatory.",
        "D": "Retries alone are insufficient."
      }
    }
  }
]
