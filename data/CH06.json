[
  {
    "id": "CH06-0001",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "DataWeave Basics",
    "subtopic": "Purpose",
    "difficulty": "Easy",
    "question": "What is the primary purpose of DataWeave in MuleSoft?",
    "options": {
      "A": "API security enforcement",
      "B": "Data transformation between formats",
      "C": "Thread management",
      "D": "Runtime deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave is MuleSoftâ€™s functional language for transforming data between formats.",
      "incorrect": {
        "A": "Security is handled via policies.",
        "C": "Threading is managed by the runtime.",
        "D": "Deployment is handled by Runtime Manager."
      }
    }
  },
  {
    "id": "CH06-0002",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "DataWeave Basics",
    "subtopic": "Execution model",
    "difficulty": "Medium",
    "question": "How does DataWeave execute transformations?",
    "options": {
      "A": "Imperatively line by line",
      "B": "Declaratively using functional expressions",
      "C": "Procedurally using loops",
      "D": "Asynchronously by default"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave follows a declarative, functional programming paradigm.",
      "incorrect": {
        "A": "It is not imperative.",
        "C": "Loops exist but are not procedural.",
        "D": "Execution is synchronous unless configured otherwise."
      }
    }
  },
  {
    "id": "CH06-0003",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "DataWeave Language",
    "subtopic": "Header structure",
    "difficulty": "Easy",
    "question": "Which statement correctly defines a DataWeave script header?",
    "options": {
      "A": "%dw 2.0",
      "B": "#%mule 4",
      "C": "@DataWeave",
      "D": "use dw::core"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Every DataWeave 2.x script starts with %dw 2.0.",
      "incorrect": {
        "B": "This is not a valid DataWeave header.",
        "C": "Annotations are not used this way.",
        "D": "Modules are imported separately."
      }
    }
  },
  {
    "id": "CH06-0004",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Directive",
    "subtopic": "Output formats",
    "difficulty": "Easy",
    "question": "Which output directive produces JSON?",
    "options": {
      "A": "output application/xml",
      "B": "output application/java",
      "C": "output application/json",
      "D": "output text/plain"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "application/json explicitly produces JSON output.",
      "incorrect": {
        "A": "Produces XML.",
        "B": "Produces Java objects.",
        "D": "Produces plain text."
      }
    }
  },
  {
    "id": "CH06-0005",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Input Data",
    "subtopic": "Payload access",
    "difficulty": "Easy",
    "question": "How is the Mule event payload accessed in DataWeave?",
    "options": {
      "A": "payload",
      "B": "vars.payload",
      "C": "event.payload",
      "D": "message.body"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The payload keyword directly references the Mule event payload.",
      "incorrect": {
        "B": "vars is a different scope.",
        "C": "event is not used in DW.",
        "D": "This syntax is not valid in Mule 4."
      }
    }
  },
  {
    "id": "CH06-0006",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Variables",
    "subtopic": "Variable access",
    "difficulty": "Easy",
    "question": "How are flow variables accessed in DataWeave?",
    "options": {
      "A": "flowVars",
      "B": "vars",
      "C": "attributes",
      "D": "session"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "vars is the correct scope for flow variables in Mule 4.",
      "incorrect": {
        "A": "Used in Mule 3, not Mule 4.",
        "C": "attributes holds metadata.",
        "D": "Sessions are not supported."
      }
    }
  },

  {
    "id": "CH06-0007",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Data Types",
    "subtopic": "Primitive types",
    "difficulty": "Medium",
    "question": "Which of the following is NOT a primitive DataWeave type?",
    "options": {
      "A": "String",
      "B": "Boolean",
      "C": "Object",
      "D": "Number"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object is a complex type, not a primitive.",
      "incorrect": {
        "A": "String is primitive.",
        "B": "Boolean is primitive.",
        "D": "Number is primitive."
      }
    }
  },

  {
    "id": "CH06-0008",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Selectors",
    "subtopic": "Object selectors",
    "difficulty": "Medium",
    "question": "Which selector retrieves a field from an object?",
    "options": {
      "A": "payload[0]",
      "B": "payload.name",
      "C": "payload[\"name\"]",
      "D": "Both B and C"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Dot selector and bracket selector both retrieve object fields.",
      "incorrect": {
        "A": "This accesses an array index.",
        "B": "Correct but incomplete alone.",
        "C": "Correct but incomplete alone."
      }
    }
  },

  {
    "id": "CH06-0009",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Selectors",
    "subtopic": "Array selectors",
    "difficulty": "Easy",
    "question": "How do you access the first element of an array?",
    "options": {
      "A": "array.first()",
      "B": "array[1]",
      "C": "array[0]",
      "D": "array.get(0)"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Arrays are zero-indexed in DataWeave.",
      "incorrect": {
        "A": "This function does not exist.",
        "B": "Index 1 refers to the second element.",
        "D": "Not valid DataWeave syntax."
      }
    }
  },

  {
    "id": "CH06-0010",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Null Handling",
    "subtopic": "Null values",
    "difficulty": "Medium",
    "question": "What is the DataWeave literal for a null value?",
    "options": {
      "A": "undefined",
      "B": "NULL",
      "C": "nil",
      "D": "null"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "null represents the absence of a value in DataWeave.",
      "incorrect": {
        "A": "Not a DataWeave literal.",
        "B": "Case-sensitive and invalid.",
        "C": "Used in other languages, not DW."
      }
    }
  },
  {
    "id": "CH06-0011",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Data Types",
    "subtopic": "Array type",
    "difficulty": "Easy",
    "question": "Which DataWeave type represents an ordered collection of elements?",
    "options": {
      "A": "Object",
      "B": "Array",
      "C": "Set",
      "D": "Map"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Array represents an ordered list of values in DataWeave.",
      "incorrect": {
        "A": "Object represents key-value pairs.",
        "C": "Set is not a native DataWeave type.",
        "D": "Map is represented as Object."
      }
    }
  },
  {
    "id": "CH06-0012",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Data Types",
    "subtopic": "Object type",
    "difficulty": "Easy",
    "question": "How are key-value pairs represented in DataWeave?",
    "options": {
      "A": "As arrays",
      "B": "As objects",
      "C": "As tuples",
      "D": "As strings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Objects represent structured key-value data.",
      "incorrect": {
        "A": "Arrays are indexed collections.",
        "C": "Tuples are not used in DataWeave.",
        "D": "Strings are primitive values."
      }
    }
  },
  {
    "id": "CH06-0013",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Operators",
    "subtopic": "Concatenation",
    "difficulty": "Medium",
    "question": "Which operator is used to concatenate two strings in DataWeave?",
    "options": {
      "A": "+",
      "B": "&",
      "C": "++",
      "D": "::"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The ++ operator concatenates strings and arrays in DataWeave.",
      "incorrect": {
        "A": "+ is not used for string concatenation.",
        "B": "& is not a valid operator.",
        "D": ":: is used for module access."
      }
    }
  },
  {
    "id": "CH06-0014",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Operators",
    "subtopic": "Object merge",
    "difficulty": "Medium",
    "question": "What happens when two objects are merged using the ++ operator?",
    "options": {
      "A": "Objects are nested",
      "B": "Duplicate keys cause an error",
      "C": "Right-side values override left-side values",
      "D": "Only common keys are retained"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "When merging objects, keys on the right override earlier ones.",
      "incorrect": {
        "A": "Objects are not nested automatically.",
        "B": "No error is thrown.",
        "D": "All keys are retained."
      }
    }
  },
  {
    "id": "CH06-0015",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Expressions",
    "subtopic": "Literal expressions",
    "difficulty": "Easy",
    "question": "Which of the following is a valid numeric literal in DataWeave?",
    "options": {
      "A": "\"123\"",
      "B": "123",
      "C": "num(123)",
      "D": "'123'"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Numbers are written directly without quotes.",
      "incorrect": {
        "A": "This is a string.",
        "C": "This is not valid syntax.",
        "D": "This is also a string."
      }
    }
  },
  {
    "id": "CH06-0016",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Built-in functions",
    "difficulty": "Medium",
    "question": "Which function returns the number of elements in an array?",
    "options": {
      "A": "count()",
      "B": "sizeOf()",
      "C": "length()",
      "D": "elements()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf() returns the size of arrays, objects, or strings.",
      "incorrect": {
        "A": "Not a DataWeave function.",
        "C": "length() is not valid.",
        "D": "elements() does not exist."
      }
    }
  },
  {
    "id": "CH06-0017",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Type casting",
    "difficulty": "Medium",
    "question": "How do you explicitly cast a value to a String in DataWeave?",
    "options": {
      "A": "as String",
      "B": "toString()",
      "C": "string()",
      "D": "cast String"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The as operator is used for type coercion.",
      "incorrect": {
        "B": "Not valid DataWeave syntax.",
        "C": "This function does not exist.",
        "D": "Invalid syntax."
      }
    }
  },
  {
    "id": "CH06-0018",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditional Logic",
    "subtopic": "If-else",
    "difficulty": "Easy",
    "question": "Which syntax correctly represents conditional logic in DataWeave?",
    "options": {
      "A": "if (a) then b else c",
      "B": "if a then b else c",
      "C": "a ? b : c",
      "D": "choose a when b"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave uses if <condition> then <value> else <value>.",
      "incorrect": {
        "A": "Parentheses are not required.",
        "C": "Ternary syntax is not supported.",
        "D": "This is not valid syntax."
      }
    }
  },
  {
    "id": "CH06-0019",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Boolean Logic",
    "subtopic": "Logical operators",
    "difficulty": "Easy",
    "question": "Which operator represents logical AND in DataWeave?",
    "options": {
      "A": "&&",
      "B": "AND",
      "C": "and",
      "D": "&"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "and is the logical AND operator in DataWeave.",
      "incorrect": {
        "A": "&& is not used.",
        "B": "Uppercase AND is invalid.",
        "D": "This is not a logical operator."
      }
    }
  },
  {
    "id": "CH06-0020",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Boolean Logic",
    "subtopic": "Negation",
    "difficulty": "Easy",
    "question": "Which keyword is used for logical negation?",
    "options": {
      "A": "!",
      "B": "not",
      "C": "~",
      "D": "negate"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "not is the logical negation operator in DataWeave.",
      "incorrect": {
        "A": "Exclamation mark is not used.",
        "C": "Bitwise operators are not used this way.",
        "D": "Not a valid keyword."
      }
    }
  },
  {
    "id": "CH06-0021",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Iteration",
    "subtopic": "map function",
    "difficulty": "Medium",
    "question": "What does the map function return when applied to an array?",
    "options": {
      "A": "A single value",
      "B": "An object",
      "C": "A transformed array",
      "D": "A Boolean"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "map transforms each element and returns a new array.",
      "incorrect": {
        "A": "It does not reduce to a single value.",
        "B": "Objects require key-value logic.",
        "D": "Booleans are not returned by map."
      }
    }
  },
  {
    "id": "CH06-0022",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Iteration",
    "subtopic": "filter function",
    "difficulty": "Medium",
    "question": "What is the result of applying filter to an array?",
    "options": {
      "A": "A reduced numeric value",
      "B": "A subset of the original array",
      "C": "An object",
      "D": "A Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "filter returns elements that satisfy a condition.",
      "incorrect": {
        "A": "reduce performs aggregation.",
        "C": "Objects are not returned.",
        "D": "filter does not return a Boolean."
      }
    }
  },
  {
    "id": "CH06-0023",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Iteration",
    "subtopic": "reduce function",
    "difficulty": "Hard",
    "question": "What is the main purpose of the reduce function?",
    "options": {
      "A": "Transform each element",
      "B": "Remove elements",
      "C": "Aggregate elements into a single value",
      "D": "Sort elements"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "reduce combines elements into a single accumulated result.",
      "incorrect": {
        "A": "map handles transformation.",
        "B": "filter removes elements.",
        "D": "Sorting is separate."
      }
    }
  },
  {
    "id": "CH06-0024",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Scope",
    "subtopic": "Variables inside functions",
    "difficulty": "Medium",
    "question": "What is the scope of variables defined inside a DataWeave function?",
    "options": {
      "A": "Global",
      "B": "Flow-level",
      "C": "Local to the function",
      "D": "Session-level"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Variables inside functions are locally scoped.",
      "incorrect": {
        "A": "Globals must be defined outside.",
        "B": "Flow variables use vars.",
        "D": "Sessions are not supported."
      }
    }
  },
  {
    "id": "CH06-0025",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Object Handling",
    "subtopic": "Dynamic keys",
    "difficulty": "Hard",
    "question": "How are dynamic keys defined in a DataWeave object?",
    "options": {
      "A": "Using parentheses ()",
      "B": "Using square brackets []",
      "C": "Using curly braces {}",
      "D": "Using angle brackets <> "
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dynamic keys are defined using square brackets.",
      "incorrect": {
        "A": "Parentheses are for grouping.",
        "C": "Curly braces define objects.",
        "D": "Angle brackets are not used."
      }
    }
  },
  {
    "id": "CH06-0026",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Error Handling",
    "subtopic": "Type coercion",
    "difficulty": "Medium",
    "question": "What happens if type coercion using 'as' fails?",
    "options": {
      "A": "Null is returned",
      "B": "The value is ignored",
      "C": "An error is thrown",
      "D": "Default value is applied"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Invalid coercion results in a runtime error.",
      "incorrect": {
        "A": "Null is not returned automatically.",
        "B": "The value is not ignored.",
        "D": "Defaults require explicit handling."
      }
    }
  },
  {
    "id": "CH06-0027",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Interpolation",
    "difficulty": "Easy",
    "question": "Which syntax enables string interpolation in DataWeave?",
    "options": {
      "A": "\"Hello ${name}\"",
      "B": "\"Hello $(name)\"",
      "C": "\"Hello @{name}\"",
      "D": "\"Hello + name\""
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "String interpolation uses $(expression).",
      "incorrect": {
        "A": "This syntax is not supported.",
        "C": "Annotations are not used here.",
        "D": "Concatenation uses ++, not +."
      }
    }
  },
  {
    "id": "CH06-0028",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Multiline strings",
    "difficulty": "Medium",
    "question": "How are multiline strings defined in DataWeave?",
    "options": {
      "A": "Using triple quotes",
      "B": "Using backticks",
      "C": "Using single quotes",
      "D": "Using parentheses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backticks (`) define multiline strings.",
      "incorrect": {
        "A": "Triple quotes are not used.",
        "C": "Single quotes define single-line strings.",
        "D": "Parentheses do not define strings."
      }
    }
  },
  {
    "id": "CH06-0029",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Comparison",
    "subtopic": "Equality",
    "difficulty": "Easy",
    "question": "Which operator checks equality in DataWeave?",
    "options": {
      "A": "=",
      "B": "==",
      "C": "===",
      "D": "eq"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "== is the equality operator.",
      "incorrect": {
        "A": "Assignment is not allowed.",
        "C": "Strict equality is not used.",
        "D": "eq is not valid."
      }
    }
  },
  {
    "id": "CH06-0030",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Comparison",
    "subtopic": "Relational operators",
    "difficulty": "Easy",
    "question": "Which operator evaluates whether a value is greater than another?",
    "options": {
      "A": ">",
      "B": "gt",
      "C": "=>",
      "D": "greater"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "> is the standard greater-than operator.",
      "incorrect": {
        "B": "Not valid syntax.",
        "C": "Used for lambdas, not comparison.",
        "D": "Not a valid operator."
      }
    }
  },
  {
    "id": "CH06-0031",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Lambdas",
    "subtopic": "Anonymous functions",
    "difficulty": "Medium",
    "question": "Which symbol separates parameters and body in a lambda expression?",
    "options": {
      "A": "->",
      "B": "=>",
      "C": "::",
      "D": ":"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "=> separates lambda parameters from the body.",
      "incorrect": {
        "A": "Not used in DataWeave.",
        "C": "Used for module access.",
        "D": "Used in object definitions."
      }
    }
  },
  {
    "id": "CH06-0032",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Lambdas",
    "subtopic": "Implicit parameter",
    "difficulty": "Medium",
    "question": "What is the implicit parameter name in a single-argument lambda?",
    "options": {
      "A": "this",
      "B": "value",
      "C": "$",
      "D": "_"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "$ represents the current element implicitly.",
      "incorrect": {
        "A": "this is not used.",
        "B": "value is not implicit.",
        "D": "Underscore is not used."
      }
    }
  },
  {
    "id": "CH06-0033",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Object Iteration",
    "subtopic": "mapObject",
    "difficulty": "Medium",
    "question": "Which function is used to iterate over object key-value pairs?",
    "options": {
      "A": "map",
      "B": "forEach",
      "C": "mapObject",
      "D": "reduce"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "mapObject is designed for object iteration.",
      "incorrect": {
        "A": "map is for arrays.",
        "B": "forEach does not transform.",
        "D": "reduce aggregates."
      }
    }
  },
  {
    "id": "CH06-0034",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Object Iteration",
    "subtopic": "Key-value access",
    "difficulty": "Medium",
    "question": "What parameters does mapObject provide by default?",
    "options": {
      "A": "value only",
      "B": "key only",
      "C": "value and key",
      "D": "index and value"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "mapObject provides both value and key.",
      "incorrect": {
        "A": "Key is also available.",
        "B": "Value is also available.",
        "D": "Index is not used."
      }
    }
  },
  {
    "id": "CH06-0035",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Handling",
    "subtopic": "Pretty print",
    "difficulty": "Medium",
    "question": "How do you enable formatted JSON output?",
    "options": {
      "A": "output application/json",
      "B": "output application/json pretty",
      "C": "output application/json indent=true",
      "D": "output application/json {indent: true}"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Indent option enables pretty printing.",
      "incorrect": {
        "A": "Default output is compact.",
        "B": "Invalid syntax.",
        "C": "Not valid syntax."
      }
    }
  },
  {
    "id": "CH06-0036",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Comments",
    "subtopic": "Single-line comments",
    "difficulty": "Easy",
    "question": "Which symbol is used for single-line comments in DataWeave?",
    "options": {
      "A": "//",
      "B": "#",
      "C": "--",
      "D": "/* */"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "# is used for single-line comments.",
      "incorrect": {
        "A": "Not used in DataWeave.",
        "C": "Not supported.",
        "D": "Used for block comments."
      }
    }
  },
  {
    "id": "CH06-0037",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Comments",
    "subtopic": "Block comments",
    "difficulty": "Easy",
    "question": "Which syntax defines block comments in DataWeave?",
    "options": {
      "A": "// comment //",
      "B": "## comment ##",
      "C": "/* comment */",
      "D": "-- comment --"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Block comments use /* */.",
      "incorrect": {
        "A": "Single-line syntax is different.",
        "B": "Not supported.",
        "D": "Not valid."
      }
    }
  },
  {
    "id": "CH06-0038",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Evaluation",
    "subtopic": "Lazy evaluation",
    "difficulty": "Hard",
    "question": "How does DataWeave typically evaluate expressions?",
    "options": {
      "A": "Eagerly in sequence",
      "B": "Lazily when required",
      "C": "Asynchronously",
      "D": "In parallel always"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave uses lazy evaluation to optimize execution.",
      "incorrect": {
        "A": "Not strictly sequential.",
        "C": "Not asynchronous by default.",
        "D": "Parallelism is not guaranteed."
      }
    }
  },
  {
    "id": "CH06-0039",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Readability",
    "difficulty": "Medium",
    "question": "What improves DataWeave script readability?",
    "options": {
      "A": "Single-line expressions only",
      "B": "Meaningful variable names and formatting",
      "C": "Avoiding functions",
      "D": "Hardcoding values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readable code improves maintenance and debugging.",
      "incorrect": {
        "A": "Long lines reduce clarity.",
        "C": "Functions improve reuse.",
        "D": "Hardcoding reduces flexibility."
      }
    }
  },
  {
    "id": "CH06-0040",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Reusability",
    "difficulty": "Medium",
    "question": "What is the preferred way to reuse DataWeave logic?",
    "options": {
      "A": "Copy-paste scripts",
      "B": "Global variables",
      "C": "Custom functions and modules",
      "D": "Session variables"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Functions and modules promote reuse and maintainability.",
      "incorrect": {
        "A": "Copy-paste causes duplication.",
        "B": "Globals increase coupling.",
        "D": "Sessions are not supported."
      }
    }
  },
  {
    "id": "CH06-0041",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Selectors",
    "subtopic": "Safe navigation",
    "difficulty": "Medium",
    "question": "Which selector prevents errors when accessing a potentially missing field?",
    "options": {
      "A": ".?",
      "B": "?.",
      "C": "??",
      "D": "!"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The safe navigation operator ?. avoids errors when fields are missing.",
      "incorrect": {
        "A": "Invalid syntax.",
        "C": "This is the default operator.",
        "D": "Not a selector."
      }
    }
  },
  {
    "id": "CH06-0042",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Null Handling",
    "subtopic": "Default operator",
    "difficulty": "Easy",
    "question": "Which operator provides a default value when an expression evaluates to null?",
    "options": {
      "A": "?:",
      "B": "or",
      "C": "??",
      "D": "default"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The ?? operator supplies a fallback value.",
      "incorrect": {
        "A": "Not used in DataWeave.",
        "B": "Logical operator.",
        "D": "Not a valid keyword."
      }
    }
  },
  {
    "id": "CH06-0043",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Type System",
    "subtopic": "Strong typing",
    "difficulty": "Medium",
    "question": "How does DataWeave handle type safety?",
    "options": {
      "A": "Weakly typed at runtime",
      "B": "Strongly typed with runtime validation",
      "C": "Untyped",
      "D": "Compile-time only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave enforces strong typing with runtime checks.",
      "incorrect": {
        "A": "Weak typing is not used.",
        "C": "Types are enforced.",
        "D": "Evaluation occurs at runtime."
      }
    }
  },
  {
    "id": "CH06-0044",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Type Coercion",
    "subtopic": "Implicit casting",
    "difficulty": "Medium",
    "question": "When does DataWeave perform implicit type coercion?",
    "options": {
      "A": "Never",
      "B": "Only with the as operator",
      "C": "When context expects a compatible type",
      "D": "Only for numbers"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Implicit coercion occurs when context allows compatible conversion.",
      "incorrect": {
        "A": "Implicit coercion does occur.",
        "B": "as is explicit coercion.",
        "D": "Not limited to numbers."
      }
    }
  },
  {
    "id": "CH06-0045",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Flattening",
    "difficulty": "Medium",
    "question": "Which function converts a nested array into a single-level array?",
    "options": {
      "A": "merge()",
      "B": "collapse()",
      "C": "flatten()",
      "D": "reduce()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "flatten() removes nested array levels.",
      "incorrect": {
        "A": "merge is for objects.",
        "B": "Not a valid function.",
        "D": "reduce aggregates values."
      }
    }
  },
  {
    "id": "CH06-0046",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Distinct values",
    "difficulty": "Medium",
    "question": "Which function removes duplicate values from an array?",
    "options": {
      "A": "unique()",
      "B": "distinctBy()",
      "C": "removeDuplicates()",
      "D": "dedupe()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "distinctBy() removes duplicates using a selector.",
      "incorrect": {
        "A": "Not a DataWeave function.",
        "C": "Invalid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0047",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Sorting",
    "difficulty": "Medium",
    "question": "Which function sorts an array based on a custom condition?",
    "options": {
      "A": "orderBy()",
      "B": "sort()",
      "C": "sortBy()",
      "D": "arrange()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "sortBy() sorts arrays using an expression.",
      "incorrect": {
        "A": "Used for objects.",
        "B": "sort() is not valid.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0048",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Key extraction",
    "difficulty": "Easy",
    "question": "Which function returns all keys of an object?",
    "options": {
      "A": "keysOf()",
      "B": "keySet()",
      "C": "keys()",
      "D": "objectKeys()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "keys() extracts all object keys.",
      "incorrect": {
        "A": "Invalid function.",
        "B": "Not supported.",
        "D": "Not a valid function."
      }
    }
  },
  {
    "id": "CH06-0049",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Value extraction",
    "difficulty": "Easy",
    "question": "Which function returns all values of an object?",
    "options": {
      "A": "values()",
      "B": "vals()",
      "C": "getValues()",
      "D": "valueOf()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "values() extracts object values.",
      "incorrect": {
        "B": "Invalid function.",
        "C": "Not supported.",
        "D": "Incorrect usage."
      }
    }
  },
  {
    "id": "CH06-0050",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Entry conversion",
    "difficulty": "Medium",
    "question": "Which function converts an object into an array of key-value pairs?",
    "options": {
      "A": "entriesOf()",
      "B": "toArray()",
      "C": "entries()",
      "D": "pairs()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "entries() converts objects into key-value pair arrays.",
      "incorrect": {
        "A": "Invalid function.",
        "B": "Generic conversion, not specific.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0051",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Index access",
    "difficulty": "Easy",
    "question": "What happens if you access an array index that does not exist?",
    "options": {
      "A": "An error is thrown",
      "B": "Null is returned",
      "C": "Empty array is returned",
      "D": "Default value is used"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accessing a non-existing index returns null.",
      "incorrect": {
        "A": "No error is thrown for missing index.",
        "C": "Empty array is not returned.",
        "D": "Default requires explicit handling."
      }
    }
  },
  {
    "id": "CH06-0052",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Negative indexing",
    "difficulty": "Medium",
    "question": "What does array[-1] return in DataWeave?",
    "options": {
      "A": "First element",
      "B": "Null",
      "C": "Last element",
      "D": "Index error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Negative indexing retrieves elements from the end.",
      "incorrect": {
        "A": "Index 0 is the first element.",
        "B": "Valid index exists.",
        "D": "No error is thrown."
      }
    }
  },
  {
    "id": "CH06-0053",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Slicing",
    "difficulty": "Medium",
    "question": "Which syntax extracts a subarray from index 1 to 3?",
    "options": {
      "A": "array[1..3]",
      "B": "array[1,3]",
      "C": "array.slice(1,3)",
      "D": "array[1-3]"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Range operator .. is used for slicing.",
      "incorrect": {
        "B": "Invalid syntax.",
        "C": "slice() is not used this way.",
        "D": "Invalid operator."
      }
    }
  },
  {
    "id": "CH06-0054",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Missing keys",
    "difficulty": "Easy",
    "question": "What happens when accessing a non-existent object key?",
    "options": {
      "A": "Exception is thrown",
      "B": "Empty string is returned",
      "C": "Null is returned",
      "D": "Key is auto-created"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Missing object keys return null.",
      "incorrect": {
        "A": "No exception is thrown.",
        "B": "Empty string is not default.",
        "D": "Keys are not auto-created."
      }
    }
  },
  {
    "id": "CH06-0055",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Operators",
    "subtopic": "Range operator",
    "difficulty": "Easy",
    "question": "What does the range operator (..) produce?",
    "options": {
      "A": "Array of sequential values",
      "B": "Single numeric value",
      "C": "Boolean result",
      "D": "Object structure"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The range operator creates a sequence of values.",
      "incorrect": {
        "B": "Multiple values are produced.",
        "C": "Not a comparison operator.",
        "D": "Objects are not created."
      }
    }
  },
  {
    "id": "CH06-0056",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Operators",
    "subtopic": "Contains",
    "difficulty": "Medium",
    "question": "Which operator checks if a value exists within an array?",
    "options": {
      "A": "in",
      "B": "contains",
      "C": "exists",
      "D": "has"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The 'in' operator checks membership.",
      "incorrect": {
        "B": "Not a valid operator.",
        "C": "Not supported.",
        "D": "Invalid syntax."
      }
    }
  },
  {
    "id": "CH06-0057",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Case conversion",
    "difficulty": "Easy",
    "question": "Which function converts a string to uppercase?",
    "options": {
      "A": "upper()",
      "B": "toUpper()",
      "C": "uppercase()",
      "D": "toUpperCase()"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "toUpperCase() converts strings to uppercase.",
      "incorrect": {
        "A": "Not a valid function.",
        "B": "Invalid name.",
        "C": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0058",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Substring",
    "difficulty": "Medium",
    "question": "Which function extracts part of a string?",
    "options": {
      "A": "slice()",
      "B": "substring()",
      "C": "subString()",
      "D": "cut()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "substring() extracts a portion of a string.",
      "incorrect": {
        "A": "slice() is for arrays.",
        "C": "Incorrect casing.",
        "D": "Not a valid function."
      }
    }
  },
  {
    "id": "CH06-0059",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Date type",
    "difficulty": "Medium",
    "question": "Which DataWeave type represents a date without time?",
    "options": {
      "A": "DateTime",
      "B": "Time",
      "C": "LocalDate",
      "D": "Date"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "Date represents a date without time.",
      "incorrect": {
        "A": "Includes date and time.",
        "B": "Represents only time.",
        "C": "Not a DataWeave type."
      }
    }
  },
  {
    "id": "CH06-0060",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Current date",
    "difficulty": "Medium",
    "question": "Which expression retrieves the current date and time?",
    "options": {
      "A": "now()",
      "B": "currentDate()",
      "C": "systemTime()",
      "D": "today()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "now() returns the current DateTime.",
      "incorrect": {
        "B": "Not a valid function.",
        "C": "Invalid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0061",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Formatting",
    "difficulty": "Hard",
    "question": "Which operator is used to format dates?",
    "options": {
      "A": "format()",
      "B": "as",
      "C": "to",
      "D": "using"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The 'as' operator formats dates into strings.",
      "incorrect": {
        "A": "Not used for formatting.",
        "C": "Invalid syntax.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0062",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Error Handling",
    "subtopic": "Try expression",
    "difficulty": "Hard",
    "question": "Which construct allows handling errors within a DataWeave script?",
    "options": {
      "A": "catch",
      "B": "try",
      "C": "on-error",
      "D": "handle"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "try allows error handling in DataWeave.",
      "incorrect": {
        "A": "Not valid in DataWeave.",
        "C": "Used in Mule flows.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0063",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Error Handling",
    "subtopic": "Try result",
    "difficulty": "Hard",
    "question": "What does try(expression) return on failure?",
    "options": {
      "A": "Null",
      "B": "Original value",
      "C": "Error object",
      "D": "Boolean false"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "try returns an error object when evaluation fails.",
      "incorrect": {
        "A": "Null is not returned.",
        "B": "Original value is not preserved.",
        "D": "Boolean is not returned."
      }
    }
  },
  {
    "id": "CH06-0064",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Pattern Matching",
    "subtopic": "Match expression",
    "difficulty": "Hard",
    "question": "Which keyword enables pattern matching in DataWeave?",
    "options": {
      "A": "when",
      "B": "switch",
      "C": "match",
      "D": "case"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "match enables pattern matching expressions.",
      "incorrect": {
        "A": "Used inside match blocks.",
        "B": "Not supported.",
        "D": "Used within match."
      }
    }
  },
  {
    "id": "CH06-0065",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Pattern Matching",
    "subtopic": "Default case",
    "difficulty": "Medium",
    "question": "How is a default case defined in a match expression?",
    "options": {
      "A": "else",
      "B": "_",
      "C": "default",
      "D": "*"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The underscore (_) acts as a wildcard default.",
      "incorrect": {
        "A": "Not used in match.",
        "C": "Invalid keyword.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0066",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "Lazy execution",
    "difficulty": "Medium",
    "question": "Why does DataWeave use lazy evaluation?",
    "options": {
      "A": "To execute asynchronously",
      "B": "To reduce unnecessary computation",
      "C": "To avoid errors",
      "D": "To cache results"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lazy evaluation optimizes performance.",
      "incorrect": {
        "A": "Execution remains synchronous.",
        "C": "Errors can still occur.",
        "D": "Caching is not automatic."
      }
    }
  },
  {
    "id": "CH06-0067",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "Large payloads",
    "difficulty": "Hard",
    "question": "Which practice improves performance for large payload transformations?",
    "options": {
      "A": "Nested maps",
      "B": "Streaming where possible",
      "C": "Deep recursion",
      "D": "Multiple conversions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming avoids loading entire payloads into memory.",
      "incorrect": {
        "A": "Increases overhead.",
        "C": "Recursion impacts stack.",
        "D": "Extra conversions reduce performance."
      }
    }
  },
  {
    "id": "CH06-0068",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Modules",
    "subtopic": "Core module",
    "difficulty": "Easy",
    "question": "Which module is automatically available in DataWeave?",
    "options": {
      "A": "dw::core::Arrays",
      "B": "dw::core::Strings",
      "C": "dw::core",
      "D": "dw::util"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "dw::core is implicitly available.",
      "incorrect": {
        "A": "Requires import.",
        "B": "Requires import.",
        "D": "Not implicit."
      }
    }
  },
  {
    "id": "CH06-0069",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Modules",
    "subtopic": "Importing",
    "difficulty": "Medium",
    "question": "Which keyword is used to import a DataWeave module?",
    "options": {
      "A": "use",
      "B": "import",
      "C": "include",
      "D": "require"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "use imports modules in DataWeave.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Invalid keyword.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0070",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Custom Functions",
    "subtopic": "Function definition",
    "difficulty": "Medium",
    "question": "Which keyword defines a custom function?",
    "options": {
      "A": "function",
      "B": "def",
      "C": "fun",
      "D": "lambda"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "fun is used to define custom functions.",
      "incorrect": {
        "A": "Not valid in DataWeave.",
        "B": "Not supported.",
        "D": "Used for anonymous functions."
      }
    }
  },
  {
    "id": "CH06-0071",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Custom Functions",
    "subtopic": "Multiple parameters",
    "difficulty": "Medium",
    "question": "How are multiple parameters separated in a function definition?",
    "options": {
      "A": "Semicolon",
      "B": "Comma",
      "C": "Pipe",
      "D": "Colon"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parameters are comma-separated.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Invalid separator.",
        "D": "Used for typing."
      }
    }
  },
  {
    "id": "CH06-0072",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Scoping",
    "subtopic": "Let expression",
    "difficulty": "Medium",
    "question": "What is the purpose of the let expression?",
    "options": {
      "A": "Declare global variables",
      "B": "Define temporary scoped variables",
      "C": "Handle errors",
      "D": "Import modules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "let defines temporary variables within an expression.",
      "incorrect": {
        "A": "Globals are not declared this way.",
        "C": "Error handling uses try.",
        "D": "Modules use use."
      }
    }
  },
  {
    "id": "CH06-0073",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Scoping",
    "subtopic": "Let visibility",
    "difficulty": "Hard",
    "question": "What is the scope of variables defined using let?",
    "options": {
      "A": "Global",
      "B": "Flow-level",
      "C": "Limited to the expression block",
      "D": "Session-level"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "let variables exist only within the expression.",
      "incorrect": {
        "A": "Globals are defined outside.",
        "B": "Flow-level uses vars.",
        "D": "Sessions are not supported."
      }
    }
  },
  {
    "id": "CH06-0074",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "XML",
    "subtopic": "Attribute access",
    "difficulty": "Medium",
    "question": "How are XML attributes accessed in DataWeave?",
    "options": {
      "A": ".@",
      "B": "@@",
      "C": "@",
      "D": ".#"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The .@ selector accesses XML attributes.",
      "incorrect": {
        "B": "Invalid syntax.",
        "C": "Used incorrectly.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0075",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "XML",
    "subtopic": "Text node",
    "difficulty": "Medium",
    "question": "Which selector retrieves the text content of an XML element?",
    "options": {
      "A": ".text",
      "B": "#",
      "C": ".#text",
      "D": "$"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": ".#text accesses XML text nodes.",
      "incorrect": {
        "A": "Invalid selector.",
        "B": "Not sufficient.",
        "D": "Used in lambdas."
      }
    }
  },
  {
    "id": "CH06-0076",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "JSON",
    "subtopic": "Null suppression",
    "difficulty": "Hard",
    "question": "Which directive omits null values from JSON output?",
    "options": {
      "A": "skipNull=true",
      "B": "omitNulls",
      "C": "writeNull=false",
      "D": "skipNullOn=\"everywhere\""
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "skipNullOn controls null suppression.",
      "incorrect": {
        "A": "Invalid option.",
        "B": "Not supported.",
        "C": "Invalid directive."
      }
    }
  },
  {
    "id": "CH06-0077",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "JSON",
    "subtopic": "Dynamic fields",
    "difficulty": "Medium",
    "question": "How are conditional fields added to JSON output?",
    "options": {
      "A": "Using if outside object",
      "B": "Using when inside object",
      "C": "Using switch",
      "D": "Using let"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "when conditionally adds fields inside objects.",
      "incorrect": {
        "A": "Not correct placement.",
        "C": "Not used here.",
        "D": "let defines variables."
      }
    }
  },
  {
    "id": "CH06-0078",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output",
    "subtopic": "Java output",
    "difficulty": "Medium",
    "question": "Which output type produces Java Maps and Lists?",
    "options": {
      "A": "application/dw",
      "B": "application/java",
      "C": "application/json",
      "D": "application/xml"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "application/java outputs Java-native types.",
      "incorrect": {
        "A": "Internal representation.",
        "C": "Produces JSON.",
        "D": "Produces XML."
      }
    }
  },
  {
    "id": "CH06-0079",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Error prevention",
    "difficulty": "Medium",
    "question": "Which practice helps prevent runtime errors in DataWeave?",
    "options": {
      "A": "Ignoring nulls",
      "B": "Using safe navigation and defaults",
      "C": "Hardcoding values",
      "D": "Avoiding functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation and defaults reduce failures.",
      "incorrect": {
        "A": "Ignoring nulls causes errors.",
        "C": "Hardcoding reduces robustness.",
        "D": "Functions improve reliability."
      }
    }
  },
  {
    "id": "CH06-0080",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Maintainability",
    "difficulty": "Medium",
    "question": "What improves long-term maintainability of DataWeave scripts?",
    "options": {
      "A": "Deep nesting",
      "B": "Readable structure and modular logic",
      "C": "Inline everything",
      "D": "Avoid comments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear structure and modularity improve maintenance.",
      "incorrect": {
        "A": "Deep nesting reduces readability.",
        "C": "Inlining hurts reuse.",
        "D": "Comments help understanding."
      }
    }
  },
  {
    "id": "CH06-0081",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "zip function",
    "difficulty": "Medium",
    "question": "What does the zip function do when applied to two arrays?",
    "options": {
      "A": "Merges arrays into one flat array",
      "B": "Pairs elements at corresponding positions",
      "C": "Sorts both arrays together",
      "D": "Removes duplicates across arrays"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "zip pairs elements from both arrays based on index.",
      "incorrect": {
        "A": "Flattening is not performed.",
        "C": "Sorting is not involved.",
        "D": "Duplicates are not removed."
      }
    }
  },
  {
    "id": "CH06-0082",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "zip length",
    "difficulty": "Medium",
    "question": "How many elements does the result of zip contain when arrays have different lengths?",
    "options": {
      "A": "Length of the longer array",
      "B": "Length of the shorter array",
      "C": "Sum of both lengths",
      "D": "Always zero"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "zip stops at the shortest array length.",
      "incorrect": {
        "A": "Extra elements are ignored.",
        "C": "Elements are paired, not combined.",
        "D": "Result is not empty."
      }
    }
  },
  {
    "id": "CH06-0083",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "every function",
    "difficulty": "Medium",
    "question": "What does the every function return?",
    "options": {
      "A": "True if at least one element matches",
      "B": "True if all elements satisfy the condition",
      "C": "Array of matching elements",
      "D": "Count of matching elements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "every returns true only if all elements match.",
      "incorrect": {
        "A": "This describes some.",
        "C": "Filtering returns arrays.",
        "D": "Counting is different."
      }
    }
  },
  {
    "id": "CH06-0084",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "some function",
    "difficulty": "Easy",
    "question": "What does the some function evaluate?",
    "options": {
      "A": "Whether at least one element matches",
      "B": "Whether all elements match",
      "C": "Whether the array is empty",
      "D": "Whether values are unique"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "some returns true if any element matches the condition.",
      "incorrect": {
        "B": "That is evaluated by every.",
        "C": "Empty checks use isEmpty.",
        "D": "Uniqueness is checked differently."
      }
    }
  },
  {
    "id": "CH06-0085",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "find function",
    "difficulty": "Medium",
    "question": "What does the find function return when no element matches?",
    "options": {
      "A": "Empty array",
      "B": "Error",
      "C": "Null",
      "D": "False"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "find returns null when no match is found.",
      "incorrect": {
        "A": "Filtering returns arrays.",
        "B": "No error is thrown.",
        "D": "Boolean is not returned."
      }
    }
  },
  {
    "id": "CH06-0086",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object filtering",
    "difficulty": "Hard",
    "question": "Which function filters object entries based on a condition?",
    "options": {
      "A": "filter",
      "B": "mapObject",
      "C": "filterObject",
      "D": "select"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "filterObject applies conditions to object key-value pairs.",
      "incorrect": {
        "A": "filter is for arrays.",
        "B": "mapObject transforms objects.",
        "D": "Not a valid function."
      }
    }
  },
  {
    "id": "CH06-0087",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object mapping",
    "difficulty": "Medium",
    "question": "What does mapObject primarily return?",
    "options": {
      "A": "Array",
      "B": "Object",
      "C": "Boolean",
      "D": "String"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mapObject returns a transformed object.",
      "incorrect": {
        "A": "Arrays are returned by map.",
        "C": "Boolean is not returned.",
        "D": "Strings are not returned."
      }
    }
  },
  {
    "id": "CH06-0088",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object size",
    "difficulty": "Easy",
    "question": "Which function returns the number of entries in an object?",
    "options": {
      "A": "length()",
      "B": "count()",
      "C": "sizeOf()",
      "D": "entries()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "sizeOf() works for objects, arrays, and strings.",
      "incorrect": {
        "A": "Not valid.",
        "B": "Not supported.",
        "D": "Returns entries, not count."
      }
    }
  },
  {
    "id": "CH06-0089",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Division",
    "difficulty": "Medium",
    "question": "What is the result type of dividing two integers in DataWeave?",
    "options": {
      "A": "Integer",
      "B": "Decimal",
      "C": "String",
      "D": "Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Division results in a Decimal value.",
      "incorrect": {
        "A": "Integers are not preserved.",
        "C": "String conversion does not occur.",
        "D": "Boolean is invalid."
      }
    }
  },
  {
    "id": "CH06-0090",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Rounding",
    "difficulty": "Medium",
    "question": "Which function rounds a decimal to the nearest integer?",
    "options": {
      "A": "ceil()",
      "B": "round()",
      "C": "floor()",
      "D": "truncate()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "round() rounds to the nearest integer.",
      "incorrect": {
        "A": "ceil() always rounds up.",
        "C": "floor() always rounds down.",
        "D": "truncate removes decimals without rounding."
      }
    }
  },
  {
    "id": "CH06-0091",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Trim",
    "difficulty": "Easy",
    "question": "Which function removes whitespace from both ends of a string?",
    "options": {
      "A": "strip()",
      "B": "trim()",
      "C": "removeSpaces()",
      "D": "clean()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "trim() removes leading and trailing whitespace.",
      "incorrect": {
        "A": "Not valid.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0092",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Split",
    "difficulty": "Easy",
    "question": "Which function splits a string into an array?",
    "options": {
      "A": "divide()",
      "B": "split()",
      "C": "tokenize()",
      "D": "explode()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "split() breaks strings into arrays.",
      "incorrect": {
        "A": "Not valid.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0093",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Booleans",
    "subtopic": "Boolean literals",
    "difficulty": "Easy",
    "question": "Which are valid Boolean literals in DataWeave?",
    "options": {
      "A": "TRUE and FALSE",
      "B": "Yes and No",
      "C": "true and false",
      "D": "1 and 0"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Boolean literals are lowercase true and false.",
      "incorrect": {
        "A": "Uppercase is invalid.",
        "B": "Not Boolean literals.",
        "D": "Numeric values are not Booleans."
      }
    }
  },
  {
    "id": "CH06-0094",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Booleans",
    "subtopic": "Short-circuiting",
    "difficulty": "Hard",
    "question": "How does DataWeave evaluate boolean expressions with 'and'?",
    "options": {
      "A": "Evaluates both operands always",
      "B": "Evaluates right operand only if needed",
      "C": "Evaluates randomly",
      "D": "Evaluates asynchronously"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Logical operators use short-circuit evaluation.",
      "incorrect": {
        "A": "This would reduce performance.",
        "C": "Evaluation is deterministic.",
        "D": "Execution is synchronous."
      }
    }
  },
  {
    "id": "CH06-0095",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Null Handling",
    "subtopic": "isNull function",
    "difficulty": "Easy",
    "question": "Which function checks whether a value is null?",
    "options": {
      "A": "isEmpty()",
      "B": "isNull()",
      "C": "exists()",
      "D": "hasValue()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "isNull() checks explicitly for null values.",
      "incorrect": {
        "A": "Checks emptiness, not null.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0096",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Null Handling",
    "subtopic": "Empty checks",
    "difficulty": "Medium",
    "question": "Which function checks whether an array or string is empty?",
    "options": {
      "A": "isBlank()",
      "B": "isNull()",
      "C": "isEmpty()",
      "D": "sizeOf()"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "isEmpty() checks empty arrays, strings, and objects.",
      "incorrect": {
        "A": "Not valid.",
        "B": "Checks null only.",
        "D": "Returns size, not Boolean."
      }
    }
  },
  {
    "id": "CH06-0097",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Casting",
    "subtopic": "String to Number",
    "difficulty": "Medium",
    "question": "How do you convert a string to a number explicitly?",
    "options": {
      "A": "as Number",
      "B": "toNumber()",
      "C": "Number()",
      "D": "parseInt()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The 'as Number' syntax performs explicit casting.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Invalid syntax.",
        "D": "Not a DataWeave function."
      }
    }
  },
  {
    "id": "CH06-0098",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Casting",
    "subtopic": "Failed coercion",
    "difficulty": "Hard",
    "question": "What happens when a string that cannot be converted to a number is cast?",
    "options": {
      "A": "Returns null",
      "B": "Returns zero",
      "C": "Throws a runtime error",
      "D": "Returns NaN"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Invalid coercion results in a runtime error.",
      "incorrect": {
        "A": "Null is not returned.",
        "B": "Zero is not assumed.",
        "D": "NaN is not used."
      }
    }
  },
  {
    "id": "CH06-0099",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Evaluation",
    "subtopic": "Order of execution",
    "difficulty": "Hard",
    "question": "In which order does DataWeave evaluate expressions?",
    "options": {
      "A": "Top to bottom strictly",
      "B": "Left to right always",
      "C": "Based on dependency graph",
      "D": "Randomly"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Evaluation occurs based on dependencies due to lazy execution.",
      "incorrect": {
        "A": "Not strictly sequential.",
        "B": "Not guaranteed.",
        "D": "Execution is deterministic."
      }
    }
  },
  {
    "id": "CH06-0100",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Transformation clarity",
    "difficulty": "Medium",
    "question": "What best improves clarity of complex DataWeave transformations?",
    "options": {
      "A": "Inline nested expressions",
      "B": "Breaking logic into smaller functions",
      "C": "Avoiding variables",
      "D": "Hardcoding values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller functions improve readability and reuse.",
      "incorrect": {
        "A": "Deep nesting reduces clarity.",
        "C": "Variables help structure logic.",
        "D": "Hardcoding reduces flexibility."
      }
    }
  },
  {
    "id": "CH06-0101",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Testing",
    "difficulty": "Medium",
    "question": "Why should DataWeave transformations be unit tested?",
    "options": {
      "A": "To improve runtime speed",
      "B": "To ensure correctness across edge cases",
      "C": "To avoid type casting",
      "D": "To reduce code size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Unit tests validate transformation logic.",
      "incorrect": {
        "A": "Testing does not increase speed.",
        "C": "Casting is unrelated.",
        "D": "Code size is not the focus."
      }
    }
  },
  {
    "id": "CH06-0102",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Payload immutability",
    "difficulty": "Hard",
    "question": "How does DataWeave treat input payloads?",
    "options": {
      "A": "Mutable by default",
      "B": "Immutable during transformation",
      "C": "Overwritten automatically",
      "D": "Modified in place"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave treats input data as immutable.",
      "incorrect": {
        "A": "Mutations are not allowed.",
        "C": "Original payload remains unchanged.",
        "D": "No in-place modification."
      }
    }
  },
  {
    "id": "CH06-0103",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Side effects",
    "difficulty": "Hard",
    "question": "Which characteristic of DataWeave prevents side effects?",
    "options": {
      "A": "Imperative syntax",
      "B": "Functional programming model",
      "C": "Global variables",
      "D": "Mutable state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functional programming avoids side effects.",
      "incorrect": {
        "A": "Imperative code allows side effects.",
        "C": "Globals increase risk.",
        "D": "State mutation causes side effects."
      }
    }
  },
  {
    "id": "CH06-0104",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Determinism",
    "difficulty": "Medium",
    "question": "Why are DataWeave transformations deterministic?",
    "options": {
      "A": "They depend on system time",
      "B": "Same input always produces same output",
      "C": "They are asynchronous",
      "D": "They modify state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deterministic behavior ensures predictable output.",
      "incorrect": {
        "A": "Time-dependent functions break determinism.",
        "C": "Asynchronicity is unrelated.",
        "D": "State modification does not occur."
      }
    }
  },
  {
    "id": "CH06-0105",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "Mime types",
    "difficulty": "Easy",
    "question": "Where is the output MIME type defined in DataWeave?",
    "options": {
      "A": "Inside the body",
      "B": "In the header section",
      "C": "As a comment",
      "D": "Inside a function"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The output directive is defined in the header.",
      "incorrect": {
        "A": "Body contains expressions.",
        "C": "Comments are ignored.",
        "D": "Functions do not define MIME types."
      }
    }
  },
  {
    "id": "CH06-0106",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "Multiple outputs",
    "difficulty": "Hard",
    "question": "How many output directives can a DataWeave script have?",
    "options": {
      "A": "Zero",
      "B": "One",
      "C": "Two",
      "D": "Unlimited"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only one output directive is allowed per script.",
      "incorrect": {
        "A": "At least one is required.",
        "C": "Multiple outputs are not supported.",
        "D": "Unlimited is invalid."
      }
    }
  },
  {
    "id": "CH06-0107",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "Preview",
    "difficulty": "Easy",
    "question": "Which tool helps preview DataWeave output during development?",
    "options": {
      "A": "Runtime Manager",
      "B": "Anypoint Studio preview",
      "C": "API Manager",
      "D": "Exchange"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Studio provides real-time DataWeave preview.",
      "incorrect": {
        "A": "Used for deployment.",
        "C": "Used for API governance.",
        "D": "Used for asset sharing."
      }
    }
  },
  {
    "id": "CH06-0108",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "Common issues",
    "difficulty": "Medium",
    "question": "What is a common cause of DataWeave runtime errors?",
    "options": {
      "A": "Whitespace",
      "B": "Type mismatches",
      "C": "Comments",
      "D": "Indentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Type mismatches often cause runtime failures.",
      "incorrect": {
        "A": "Whitespace is ignored.",
        "C": "Comments do not execute.",
        "D": "Indentation is flexible."
      }
    }
  },
  {
    "id": "CH06-0109",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "Error messages",
    "difficulty": "Medium",
    "question": "Why should DataWeave error messages be carefully analyzed?",
    "options": {
      "A": "They slow execution",
      "B": "They often indicate exact failure location",
      "C": "They are random",
      "D": "They hide root causes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error messages usually point to the failing expression.",
      "incorrect": {
        "A": "Messages do not affect speed.",
        "C": "Errors are deterministic.",
        "D": "They reveal root causes."
      }
    }
  },
  {
    "id": "CH06-0110",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Functional purity",
    "difficulty": "Hard",
    "question": "What does functional purity mean in DataWeave?",
    "options": {
      "A": "Functions modify external state",
      "B": "Functions depend only on inputs",
      "C": "Functions run asynchronously",
      "D": "Functions use global variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pure functions rely solely on input parameters.",
      "incorrect": {
        "A": "State modification breaks purity.",
        "C": "Asynchronicity is unrelated.",
        "D": "Globals break purity."
      }
    }
  },
  {
    "id": "CH06-0111",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Referential transparency",
    "difficulty": "Hard",
    "question": "Why is referential transparency important in DataWeave?",
    "options": {
      "A": "Improves UI rendering",
      "B": "Simplifies reasoning and testing",
      "C": "Enables multithreading",
      "D": "Reduces payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable behavior simplifies reasoning and testing.",
      "incorrect": {
        "A": "UI is unrelated.",
        "C": "Threading is not directly affected.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH06-0112",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Immutability",
    "difficulty": "Medium",
    "question": "What is the benefit of immutability in DataWeave?",
    "options": {
      "A": "Allows in-place updates",
      "B": "Prevents unintended side effects",
      "C": "Improves syntax flexibility",
      "D": "Increases payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures predictable transformations.",
      "incorrect": {
        "A": "In-place updates are not allowed.",
        "C": "Syntax is unaffected.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH06-0113",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Composition",
    "difficulty": "Medium",
    "question": "What does function composition encourage?",
    "options": {
      "A": "Large monolithic functions",
      "B": "Small reusable functions",
      "C": "Hardcoded logic",
      "D": "Stateful operations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composition promotes reuse and clarity.",
      "incorrect": {
        "A": "Monoliths reduce maintainability.",
        "C": "Hardcoding reduces flexibility.",
        "D": "Stateful logic is avoided."
      }
    }
  },
  {
    "id": "CH06-0114",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Pipelines",
    "difficulty": "Medium",
    "question": "Which operator is commonly used to create transformation pipelines?",
    "options": {
      "A": "=>",
      "B": "|>",
      "C": "::",
      "D": "++"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The pipe operator passes output between functions.",
      "incorrect": {
        "A": "Used in lambdas.",
        "C": "Used for module access.",
        "D": "Used for concatenation."
      }
    }
  },
  {
    "id": "CH06-0115",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Readability",
    "difficulty": "Medium",
    "question": "Why is the pipe operator beneficial for readability?",
    "options": {
      "A": "It hides logic",
      "B": "It expresses transformations step-by-step",
      "C": "It improves performance",
      "D": "It reduces memory usage"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pipes show clear transformation flow.",
      "incorrect": {
        "A": "Logic remains visible.",
        "C": "Performance is not guaranteed.",
        "D": "Memory usage is unaffected."
      }
    }
  },
  {
    "id": "CH06-0116",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Empty arrays",
    "difficulty": "Medium",
    "question": "What does reduce return when applied to an empty array without an initial value?",
    "options": {
      "A": "Null",
      "B": "Zero",
      "C": "Error",
      "D": "Empty array"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "reduce requires an initial value for empty arrays.",
      "incorrect": {
        "A": "Null is not returned.",
        "B": "Zero is not assumed.",
        "D": "An array is not returned."
      }
    }
  },
  {
    "id": "CH06-0117",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Null collections",
    "difficulty": "Hard",
    "question": "What happens when map is applied to null?",
    "options": {
      "A": "Returns empty array",
      "B": "Returns null",
      "C": "Throws an error",
      "D": "Skips execution"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "map expects an iterable and fails on null.",
      "incorrect": {
        "A": "Empty array is not assumed.",
        "B": "Null is not propagated.",
        "D": "Execution does not silently skip."
      }
    }
  },
  {
    "id": "CH06-0118",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Default handling",
    "difficulty": "Medium",
    "question": "Which operator should be used to safely apply map when the input may be null?",
    "options": {
      "A": "and",
      "B": "??",
      "C": "or",
      "D": "as"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The default operator provides a safe fallback.",
      "incorrect": {
        "A": "Logical operator.",
        "C": "Logical operator.",
        "D": "Type coercion."
      }
    }
  },
  {
    "id": "CH06-0119",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Optional fields",
    "difficulty": "Medium",
    "question": "Which combination best handles optional object fields?",
    "options": {
      "A": "Direct access only",
      "B": "Safe navigation with default values",
      "C": "Hardcoded checks",
      "D": "Type casting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation and defaults avoid runtime errors.",
      "incorrect": {
        "A": "Direct access may fail.",
        "C": "Hardcoding is brittle.",
        "D": "Casting does not handle absence."
      }
    }
  },
  {
    "id": "CH06-0120",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Production readiness",
    "difficulty": "Medium",
    "question": "Which practice best prepares DataWeave scripts for production?",
    "options": {
      "A": "Minimal error handling",
      "B": "Clear structure, tests, and null safety",
      "C": "Inline complex logic",
      "D": "Avoiding functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Well-structured, tested, and safe scripts are production-ready.",
      "incorrect": {
        "A": "Minimal handling increases risk.",
        "C": "Inline logic reduces clarity.",
        "D": "Functions improve reuse."
      }
    }
  },
  {
    "id": "CH06-0121",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "groupBy",
    "difficulty": "Medium",
    "question": "What does the groupBy function return when applied to an array?",
    "options": {
      "A": "An array of unique values",
      "B": "An object keyed by the grouping expression",
      "C": "A sorted array",
      "D": "A Boolean result"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "groupBy produces an object whose keys are derived from the grouping logic.",
      "incorrect": {
        "A": "Uniqueness is handled by distinctBy.",
        "C": "Sorting is not performed.",
        "D": "groupBy does not return Boolean."
      }
    }
  },
  {
    "id": "CH06-0122",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "groupBy values",
    "difficulty": "Medium",
    "question": "What type of values does groupBy assign to each generated key?",
    "options": {
      "A": "Single element",
      "B": "Array of matching elements",
      "C": "Object",
      "D": "Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each key maps to an array of elements that satisfy the grouping condition.",
      "incorrect": {
        "A": "Multiple elements can match.",
        "C": "Values are arrays, not objects.",
        "D": "No Boolean values are produced."
      }
    }
  },
  {
    "id": "CH06-0123",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "order of operations",
    "difficulty": "Hard",
    "question": "Why should filter usually be applied before map in large arrays?",
    "options": {
      "A": "It changes output structure",
      "B": "It improves performance by reducing elements early",
      "C": "It enforces type safety",
      "D": "It avoids null values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering early reduces the number of elements processed downstream.",
      "incorrect": {
        "A": "Structure is not changed by order.",
        "C": "Type safety is unrelated.",
        "D": "Null handling is separate."
      }
    }
  },
  {
    "id": "CH06-0124",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "index access in map",
    "difficulty": "Medium",
    "question": "How can the index be accessed inside a map operation?",
    "options": {
      "A": "Using index() function",
      "B": "Using the second lambda parameter",
      "C": "Using $index",
      "D": "Using array.indexOf()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "map provides value and index as parameters.",
      "incorrect": {
        "A": "No such function exists.",
        "C": "This variable is not defined.",
        "D": "This is not valid DataWeave syntax."
      }
    }
  },
  {
    "id": "CH06-0125",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "remove keys",
    "difficulty": "Medium",
    "question": "Which operator removes keys from an object?",
    "options": {
      "A": "--",
      "B": "++",
      "C": "remove()",
      "D": "exclude()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The -- operator removes specified keys from an object.",
      "incorrect": {
        "B": "++ merges objects.",
        "C": "Not a valid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0126",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "key overwrite",
    "difficulty": "Medium",
    "question": "When merging objects, how are duplicate keys handled?",
    "options": {
      "A": "An error is thrown",
      "B": "The first value is retained",
      "C": "The last value overrides earlier ones",
      "D": "Keys are merged into arrays"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Later values override earlier ones when keys conflict.",
      "incorrect": {
        "A": "No error is thrown.",
        "B": "First value is overridden.",
        "D": "Arrays are not created automatically."
      }
    }
  },
  {
    "id": "CH06-0127",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "conditional keys",
    "difficulty": "Hard",
    "question": "How can an object key be conditionally included?",
    "options": {
      "A": "Using if outside the object",
      "B": "Using when inside the object definition",
      "C": "Using switch",
      "D": "Using try"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "when allows conditional inclusion of fields inside objects.",
      "incorrect": {
        "A": "This breaks object structure.",
        "C": "switch is not used for keys.",
        "D": "try handles errors."
      }
    }
  },
  {
    "id": "CH06-0128",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Precision",
    "difficulty": "Medium",
    "question": "How does DataWeave handle numeric precision?",
    "options": {
      "A": "Fixed to integer precision",
      "B": "Uses arbitrary precision decimals",
      "C": "Rounds automatically",
      "D": "Uses floating-point only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave uses arbitrary precision decimals to avoid rounding errors.",
      "incorrect": {
        "A": "Integers are not forced.",
        "C": "No automatic rounding occurs.",
        "D": "Floating-point only is incorrect."
      }
    }
  },
  {
    "id": "CH06-0129",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Modulo",
    "difficulty": "Easy",
    "question": "Which operator calculates the remainder of a division?",
    "options": {
      "A": "%",
      "B": "/",
      "C": "mod",
      "D": "rem"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The % operator computes the remainder.",
      "incorrect": {
        "B": "This performs division.",
        "C": "Not valid syntax.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0130",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "contains",
    "difficulty": "Easy",
    "question": "Which function checks if a string contains a substring?",
    "options": {
      "A": "has()",
      "B": "contains()",
      "C": "exists()",
      "D": "in"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "contains() checks substring presence.",
      "incorrect": {
        "A": "Not valid.",
        "C": "Not supported.",
        "D": "Used for arrays."
      }
    }
  },
  {
    "id": "CH06-0131",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Replace",
    "difficulty": "Medium",
    "question": "Which function replaces parts of a string?",
    "options": {
      "A": "swap()",
      "B": "replace()",
      "C": "update()",
      "D": "change()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "replace() substitutes matching substrings.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Invalid function.",
        "D": "Not valid."
      }
    }
  },
  {
    "id": "CH06-0132",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "DateTime parsing",
    "difficulty": "Hard",
    "question": "How is a string parsed into a DateTime?",
    "options": {
      "A": "Using parse()",
      "B": "Using as DateTime with a format",
      "C": "Using toDateTime()",
      "D": "Using cast()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The as operator with a format converts strings to DateTime.",
      "incorrect": {
        "A": "Not a valid function.",
        "C": "Not supported.",
        "D": "Invalid syntax."
      }
    }
  },
  {
    "id": "CH06-0133",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Timezone",
    "difficulty": "Medium",
    "question": "How does DataWeave handle timezones in DateTime?",
    "options": {
      "A": "Ignores timezone",
      "B": "Stores timezone as part of DateTime",
      "C": "Converts all times to UTC only",
      "D": "Drops offset information"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timezone information is retained within DateTime values.",
      "incorrect": {
        "A": "Timezone is not ignored.",
        "C": "UTC conversion is not forced.",
        "D": "Offsets are preserved."
      }
    }
  },
  {
    "id": "CH06-0134",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Arithmetic",
    "difficulty": "Medium",
    "question": "How can days be added to a Date?",
    "options": {
      "A": "Using + with a Period",
      "B": "Using plusDays()",
      "C": "Using add()",
      "D": "Using increment()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Date arithmetic uses Period values with operators.",
      "incorrect": {
        "B": "Not a DataWeave function.",
        "C": "Invalid syntax.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0135",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "Nested if",
    "difficulty": "Medium",
    "question": "What is a drawback of deeply nested if expressions?",
    "options": {
      "A": "Reduced performance",
      "B": "Reduced readability",
      "C": "Type mismatch errors",
      "D": "Loss of determinism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting makes logic harder to read and maintain.",
      "incorrect": {
        "A": "Performance impact is minimal.",
        "C": "Type issues are unrelated.",
        "D": "Determinism remains."
      }
    }
  },
  {
    "id": "CH06-0136",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "Match vs if",
    "difficulty": "Hard",
    "question": "When is match preferred over if-else chains?",
    "options": {
      "A": "Single Boolean condition",
      "B": "Multiple pattern-based conditions",
      "C": "Numeric comparison only",
      "D": "Error handling scenarios"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "match simplifies multiple pattern-based conditions.",
      "incorrect": {
        "A": "Simple if is enough.",
        "C": "Not limited to numbers.",
        "D": "Error handling uses try."
      }
    }
  },
  {
    "id": "CH06-0137",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Default arguments",
    "difficulty": "Hard",
    "question": "How are default values for function parameters defined?",
    "options": {
      "A": "Using = inside parameters",
      "B": "Using ?? inside function body",
      "C": "Using let before function",
      "D": "Default parameters are not supported"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "DataWeave does not support default function parameters.",
      "incorrect": {
        "A": "Invalid syntax.",
        "B": "This handles nulls, not defaults.",
        "C": "Not applicable."
      }
    }
  },
  {
    "id": "CH06-0138",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Higher-order functions",
    "difficulty": "Medium",
    "question": "What defines a higher-order function in DataWeave?",
    "options": {
      "A": "Returns a Boolean",
      "B": "Accepts or returns functions",
      "C": "Has many parameters",
      "D": "Uses recursion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Higher-order functions work with other functions.",
      "incorrect": {
        "A": "Return type is unrelated.",
        "C": "Parameter count is irrelevant.",
        "D": "Recursion is optional."
      }
    }
  },
  {
    "id": "CH06-0139",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Recursion",
    "subtopic": "Usage",
    "difficulty": "Hard",
    "question": "Why should recursion be used cautiously in DataWeave?",
    "options": {
      "A": "It is not supported",
      "B": "It can cause stack overflows",
      "C": "It breaks immutability",
      "D": "It disables lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep recursion can exhaust the call stack.",
      "incorrect": {
        "A": "Recursion is supported.",
        "C": "Immutability remains.",
        "D": "Lazy evaluation still applies."
      }
    }
  },
  {
    "id": "CH06-0140",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Transformation design",
    "difficulty": "Medium",
    "question": "What is the recommended approach to complex DataWeave transformations?",
    "options": {
      "A": "Single large expression",
      "B": "Stepwise composition using functions",
      "C": "Heavy nesting",
      "D": "Inline hardcoded values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Composable functions improve clarity and reuse.",
      "incorrect": {
        "A": "Large expressions reduce readability.",
        "C": "Deep nesting is discouraged.",
        "D": "Hardcoding limits flexibility."
      }
    }
  },
  {
    "id": "CH06-0141",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "Boolean chaining",
    "difficulty": "Medium",
    "question": "How does DataWeave evaluate chained boolean expressions?",
    "options": {
      "A": "From right to left always",
      "B": "Using short-circuit evaluation",
      "C": "By evaluating all operands first",
      "D": "Randomly based on optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Boolean expressions use short-circuit evaluation.",
      "incorrect": {
        "A": "Order is not strictly right to left.",
        "C": "Not all operands are evaluated.",
        "D": "Evaluation is deterministic."
      }
    }
  },
  {
    "id": "CH06-0142",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "Operator precedence",
    "difficulty": "Hard",
    "question": "Which operator has higher precedence in DataWeave?",
    "options": {
      "A": "and",
      "B": "or",
      "C": "not",
      "D": "=="
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "not has higher precedence than and/or.",
      "incorrect": {
        "A": "Lower precedence than not.",
        "B": "Lower precedence than not.",
        "D": "Comparison occurs after not."
      }
    }
  },
  {
    "id": "CH06-0143",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Key existence",
    "difficulty": "Medium",
    "question": "Which function checks whether a key exists in an object?",
    "options": {
      "A": "containsKey()",
      "B": "hasKey()",
      "C": "isEmpty()",
      "D": "in"
    },
    "correctAnswer": "D",
    "explanation": {
      "correct": "The 'in' operator checks key existence in objects.",
      "incorrect": {
        "A": "Not a DataWeave function.",
        "B": "Not supported.",
        "C": "Checks emptiness, not existence."
      }
    }
  },
  {
    "id": "CH06-0144",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object comparison",
    "difficulty": "Hard",
    "question": "How does DataWeave compare two objects for equality?",
    "options": {
      "A": "Order of keys matters",
      "B": "Reference comparison",
      "C": "Key-value pairs regardless of order",
      "D": "Only compares keys"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Objects are compared by key-value pairs irrespective of order.",
      "incorrect": {
        "A": "Order does not matter.",
        "B": "Reference comparison is not used.",
        "D": "Values are also compared."
      }
    }
  },
  {
    "id": "CH06-0145",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object immutability",
    "difficulty": "Medium",
    "question": "What happens when an object is modified in DataWeave?",
    "options": {
      "A": "Original object changes",
      "B": "A new object is created",
      "C": "Runtime error occurs",
      "D": "Modification is ignored"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave creates new objects due to immutability.",
      "incorrect": {
        "A": "Original data remains unchanged.",
        "C": "No error occurs.",
        "D": "Modification logic is applied."
      }
    }
  },
  {
    "id": "CH06-0146",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Array equality",
    "difficulty": "Medium",
    "question": "How are two arrays compared for equality?",
    "options": {
      "A": "Elements and order must match",
      "B": "Only size must match",
      "C": "Only values regardless of order",
      "D": "Reference equality"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Arrays require same elements in the same order.",
      "incorrect": {
        "B": "Size alone is insufficient.",
        "C": "Order matters for arrays.",
        "D": "Reference equality is not used."
      }
    }
  },
  {
    "id": "CH06-0147",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Array difference",
    "difficulty": "Medium",
    "question": "Which operator computes the difference between two arrays?",
    "options": {
      "A": "--",
      "B": "++",
      "C": "-",
      "D": "diff()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The -- operator removes elements of the right array from the left.",
      "incorrect": {
        "B": "Used for concatenation.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0148",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Array intersection",
    "difficulty": "Hard",
    "question": "How can common elements between two arrays be obtained?",
    "options": {
      "A": "Using intersect()",
      "B": "Using filter with in operator",
      "C": "Using zip()",
      "D": "Using groupBy()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering one array using 'in' against another yields intersection.",
      "incorrect": {
        "A": "No intersect() function exists.",
        "C": "zip pairs by index.",
        "D": "groupBy groups values."
      }
    }
  },
  {
    "id": "CH06-0149",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Regex match",
    "difficulty": "Hard",
    "question": "Which operator checks if a string matches a regular expression?",
    "options": {
      "A": "matches",
      "B": "=~",
      "C": "regex()",
      "D": "like"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The =~ operator evaluates regex matches.",
      "incorrect": {
        "A": "Not valid syntax.",
        "C": "No such function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0150",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Regex replace",
    "difficulty": "Hard",
    "question": "Which function replaces text using a regular expression?",
    "options": {
      "A": "replace()",
      "B": "replaceAll()",
      "C": "regexReplace()",
      "D": "substitute()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "replaceAll() supports regex-based replacements.",
      "incorrect": {
        "A": "Basic replacement only.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0151",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Type System",
    "subtopic": "Union types",
    "difficulty": "Hard",
    "question": "What does a union type represent in DataWeave?",
    "options": {
      "A": "Intersection of types",
      "B": "One of multiple possible types",
      "C": "Only primitive types",
      "D": "Generic object type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Union types allow a value to be one of several types.",
      "incorrect": {
        "A": "Intersection is different.",
        "C": "Not limited to primitives.",
        "D": "Union is more specific."
      }
    }
  },
  {
    "id": "CH06-0152",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Type System",
    "subtopic": "Type inference",
    "difficulty": "Medium",
    "question": "How does DataWeave determine the type of an expression?",
    "options": {
      "A": "Manual annotation only",
      "B": "Static compilation",
      "C": "Type inference at runtime",
      "D": "Random selection"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "DataWeave infers types dynamically at runtime.",
      "incorrect": {
        "A": "Annotations are optional.",
        "B": "Not statically compiled.",
        "D": "Deterministic inference is used."
      }
    }
  },
  {
    "id": "CH06-0153",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Type System",
    "subtopic": "Type annotations",
    "difficulty": "Medium",
    "question": "Why would you explicitly annotate a type in DataWeave?",
    "options": {
      "A": "To improve execution speed",
      "B": "To clarify intent and catch errors early",
      "C": "To enable recursion",
      "D": "To allow mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Type annotations improve clarity and error detection.",
      "incorrect": {
        "A": "Speed impact is minimal.",
        "C": "Recursion is unrelated.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0154",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Modules",
    "subtopic": "Module aliasing",
    "difficulty": "Medium",
    "question": "Why use an alias when importing a DataWeave module?",
    "options": {
      "A": "To improve performance",
      "B": "To avoid naming conflicts",
      "C": "To enable lazy loading",
      "D": "To shorten execution time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Aliases prevent naming conflicts and improve readability.",
      "incorrect": {
        "A": "No performance gain.",
        "C": "Lazy loading is unrelated.",
        "D": "Execution time is unaffected."
      }
    }
  },
  {
    "id": "CH06-0155",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Modules",
    "subtopic": "Custom modules",
    "difficulty": "Hard",
    "question": "What is the primary benefit of creating custom DataWeave modules?",
    "options": {
      "A": "Faster execution",
      "B": "Code reuse across projects",
      "C": "Automatic testing",
      "D": "Runtime configuration"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom modules promote reuse and standardization.",
      "incorrect": {
        "A": "Performance is not the main benefit.",
        "C": "Testing is separate.",
        "D": "Configuration is not handled."
      }
    }
  },
  {
    "id": "CH06-0156",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Error Handling",
    "subtopic": "try result fields",
    "difficulty": "Hard",
    "question": "Which field indicates success in the result of try()?",
    "options": {
      "A": "success",
      "B": "value",
      "C": "error",
      "D": "status"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "On success, try() returns the value field.",
      "incorrect": {
        "A": "No such field exists.",
        "C": "Present only on failure.",
        "D": "Not used."
      }
    }
  },
  {
    "id": "CH06-0157",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Error Handling",
    "subtopic": "Error inspection",
    "difficulty": "Hard",
    "question": "How can details of a try() error be accessed?",
    "options": {
      "A": "Direct field access on error object",
      "B": "Using catch block",
      "C": "Using on-error scope",
      "D": "Through log statements only"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Error details are available on the error object.",
      "incorrect": {
        "B": "catch is not used in DataWeave.",
        "C": "Flow-level error handling.",
        "D": "Not required."
      }
    }
  },
  {
    "id": "CH06-0158",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "Expression reuse",
    "difficulty": "Medium",
    "question": "Why should repeated expressions be assigned to variables?",
    "options": {
      "A": "To change output type",
      "B": "To improve readability and performance",
      "C": "To allow mutation",
      "D": "To avoid lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusing expressions improves clarity and avoids recomputation.",
      "incorrect": {
        "A": "Output type is unchanged.",
        "C": "Mutation is not allowed.",
        "D": "Lazy evaluation still applies."
      }
    }
  },
  {
    "id": "CH06-0159",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "Memory usage",
    "difficulty": "Hard",
    "question": "Which approach minimizes memory usage in large transformations?",
    "options": {
      "A": "Eager evaluation",
      "B": "Streaming and filtering early",
      "C": "Nested object creation",
      "D": "Full payload materialization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming and early filtering reduce memory footprint.",
      "incorrect": {
        "A": "Eager evaluation increases memory usage.",
        "C": "Nested objects consume more memory.",
        "D": "Materialization increases memory use."
      }
    }
  },
  {
    "id": "CH06-0160",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Production scripts",
    "difficulty": "Medium",
    "question": "What is a key characteristic of production-ready DataWeave scripts?",
    "options": {
      "A": "Minimal validation",
      "B": "Clear structure and defensive null handling",
      "C": "Heavy recursion",
      "D": "Hardcoded assumptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defensive handling and clarity are essential for production.",
      "incorrect": {
        "A": "Minimal validation increases risk.",
        "C": "Recursion can cause issues.",
        "D": "Hardcoding reduces robustness."
      }
    }
  },
  {
    "id": "CH06-0161",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reduce function",
    "difficulty": "Medium",
    "question": "What is the primary purpose of the reduce function in DataWeave?",
    "options": {
      "A": "Transform each element independently",
      "B": "Accumulate array elements into a single value",
      "C": "Filter elements based on a condition",
      "D": "Sort array elements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "reduce aggregates elements into a single accumulated result.",
      "incorrect": {
        "A": "map performs independent transformations.",
        "C": "filter removes elements.",
        "D": "Sorting is not aggregation."
      }
    }
  },
  {
    "id": "CH06-0162",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reduce initial value",
    "difficulty": "Hard",
    "question": "Why is an initial value important when using reduce?",
    "options": {
      "A": "It enforces type casting",
      "B": "It avoids errors on empty arrays",
      "C": "It improves performance",
      "D": "It enables recursion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Without an initial value, reduce fails on empty arrays.",
      "incorrect": {
        "A": "Type casting is unrelated.",
        "C": "Performance is not the main reason.",
        "D": "Recursion is unrelated."
      }
    }
  },
  {
    "id": "CH06-0163",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reduce accumulator",
    "difficulty": "Medium",
    "question": "What does the accumulator represent in reduce?",
    "options": {
      "A": "Current array index",
      "B": "Running aggregated result",
      "C": "Original array",
      "D": "Boolean flag"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The accumulator holds the intermediate aggregated value.",
      "incorrect": {
        "A": "Index is separate.",
        "C": "Original array remains unchanged.",
        "D": "No Boolean flag is involved."
      }
    }
  },
  {
    "id": "CH06-0164",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "Index awareness",
    "difficulty": "Medium",
    "question": "Which array function provides access to both value and index?",
    "options": {
      "A": "map",
      "B": "filter",
      "C": "groupBy",
      "D": "distinctBy"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "map provides value and index as parameters.",
      "incorrect": {
        "B": "filter also provides index, but map is primary for transformation.",
        "C": "groupBy groups elements.",
        "D": "distinctBy removes duplicates."
      }
    }
  },
  {
    "id": "CH06-0165",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object concatenation",
    "difficulty": "Easy",
    "question": "Which operator concatenates two objects?",
    "options": {
      "A": "--",
      "B": "++",
      "C": "+",
      "D": "::"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "++ merges objects into a single object.",
      "incorrect": {
        "A": "Used for removal.",
        "C": "Not supported for objects.",
        "D": "Used for module access."
      }
    }
  },
  {
    "id": "CH06-0166",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Dynamic keys",
    "difficulty": "Hard",
    "question": "How are dynamic keys defined in DataWeave objects?",
    "options": {
      "A": "Using ${ } syntax",
      "B": "Using parentheses around expressions",
      "C": "Using brackets []",
      "D": "Dynamic keys are not supported"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parentheses allow expressions to define dynamic keys.",
      "incorrect": {
        "A": "Template syntax is not used.",
        "C": "Brackets are for selectors.",
        "D": "Dynamic keys are supported."
      }
    }
  },
  {
    "id": "CH06-0167",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "Object ordering",
    "difficulty": "Hard",
    "question": "Does DataWeave preserve the order of object keys?",
    "options": {
      "A": "Always preserves insertion order",
      "B": "Order is not guaranteed",
      "C": "Keys are always sorted alphabetically",
      "D": "Order depends on runtime"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Object key order is not guaranteed.",
      "incorrect": {
        "A": "Insertion order is not preserved.",
        "C": "Alphabetical sorting is not automatic.",
        "D": "Runtime does not guarantee order."
      }
    }
  },
  {
    "id": "CH06-0168",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "String interpolation",
    "difficulty": "Easy",
    "question": "How is string interpolation achieved in DataWeave?",
    "options": {
      "A": "Using + operator only",
      "B": "Using ${} inside strings",
      "C": "Using format()",
      "D": "Using concat()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "String interpolation uses ${expression} syntax.",
      "incorrect": {
        "A": "Concatenation is different.",
        "C": "format() is not used.",
        "D": "concat() is not valid."
      }
    }
  },
  {
    "id": "CH06-0169",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "Multiline strings",
    "difficulty": "Medium",
    "question": "Which delimiter is used for multiline strings in DataWeave?",
    "options": {
      "A": "'''",
      "B": "\"\"\"",
      "C": "~~~",
      "D": "###"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Triple double-quotes define multiline strings.",
      "incorrect": {
        "A": "Single quotes are not multiline.",
        "C": "Not supported.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0170",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Type conversion",
    "difficulty": "Medium",
    "question": "Which conversion converts a number to a string?",
    "options": {
      "A": "as String",
      "B": "toString()",
      "C": "String()",
      "D": "cast()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The as operator performs explicit conversion.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Invalid syntax.",
        "D": "Not a DataWeave function."
      }
    }
  },
  {
    "id": "CH06-0171",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "Infinity handling",
    "difficulty": "Hard",
    "question": "What happens when dividing a number by zero in DataWeave?",
    "options": {
      "A": "Returns Infinity",
      "B": "Returns null",
      "C": "Throws a runtime error",
      "D": "Returns zero"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Division by zero results in a runtime error.",
      "incorrect": {
        "A": "Infinity is not returned.",
        "B": "Null is not returned.",
        "D": "Zero is not assumed."
      }
    }
  },
  {
    "id": "CH06-0172",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Date vs DateTime",
    "difficulty": "Medium",
    "question": "What is the key difference between Date and DateTime?",
    "options": {
      "A": "Date includes timezone",
      "B": "DateTime includes time information",
      "C": "Date supports arithmetic, DateTime does not",
      "D": "They are identical"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DateTime includes both date and time components.",
      "incorrect": {
        "A": "Date does not include timezone.",
        "C": "Both support arithmetic.",
        "D": "They are different types."
      }
    }
  },
  {
    "id": "CH06-0173",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "Period type",
    "difficulty": "Hard",
    "question": "What does a Period represent in DataWeave?",
    "options": {
      "A": "Fixed timestamp",
      "B": "Duration between two dates",
      "C": "Timezone offset",
      "D": "Date format"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Period represents a duration used in date arithmetic.",
      "incorrect": {
        "A": "Not a timestamp.",
        "C": "Not a timezone.",
        "D": "Not a format."
      }
    }
  },
  {
    "id": "CH06-0174",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "if expression result",
    "difficulty": "Easy",
    "question": "What does an if expression return?",
    "options": {
      "A": "Boolean only",
      "B": "Value of executed branch",
      "C": "Null always",
      "D": "Error on false condition"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "if returns the value of the evaluated branch.",
      "incorrect": {
        "A": "Return type is not limited to Boolean.",
        "C": "Null is not mandatory.",
        "D": "False condition is handled."
      }
    }
  },
  {
    "id": "CH06-0175",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "Nested conditionals",
    "difficulty": "Medium",
    "question": "Which alternative improves readability over nested if expressions?",
    "options": {
      "A": "Multiple maps",
      "B": "match expression",
      "C": "Recursive calls",
      "D": "Hardcoded flags"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "match expressions simplify complex conditional logic.",
      "incorrect": {
        "A": "Mapping does not replace conditionals.",
        "C": "Recursion increases complexity.",
        "D": "Hardcoding reduces clarity."
      }
    }
  },
  {
    "id": "CH06-0176",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Anonymous functions",
    "difficulty": "Medium",
    "question": "What symbol represents the parameter of an anonymous function?",
    "options": {
      "A": "$",
      "B": "#",
      "C": "@",
      "D": "%"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "$ represents the current element in lambdas.",
      "incorrect": {
        "B": "Used in XML selectors.",
        "C": "Not used for lambdas.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0177",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Multiple parameters",
    "difficulty": "Medium",
    "question": "How are multiple parameters represented in an anonymous function?",
    "options": {
      "A": "$ and $$",
      "B": "$1 and $2",
      "C": "$ and index",
      "D": "$ and #"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "$ represents value and $$ represents index.",
      "incorrect": {
        "B": "Not supported.",
        "C": "index is not implicit.",
        "D": "Invalid syntax."
      }
    }
  },
  {
    "id": "CH06-0178",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "Function purity",
    "difficulty": "Hard",
    "question": "Why are pure functions preferred in DataWeave?",
    "options": {
      "A": "They execute faster",
      "B": "They avoid side effects",
      "C": "They allow state mutation",
      "D": "They enable dynamic typing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pure functions ensure predictable behavior.",
      "incorrect": {
        "A": "Speed is not guaranteed.",
        "C": "Mutation is avoided.",
        "D": "Typing is independent."
      }
    }
  },
  {
    "id": "CH06-0179",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "Computation reuse",
    "difficulty": "Medium",
    "question": "Which feature helps avoid recomputing expensive expressions?",
    "options": {
      "A": "Global variables",
      "B": "let bindings",
      "C": "Recursive calls",
      "D": "Inline expressions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "let bindings reuse computed values efficiently.",
      "incorrect": {
        "A": "Globals are not allowed.",
        "C": "Recursion may increase cost.",
        "D": "Inlining causes recomputation."
      }
    }
  },
  {
    "id": "CH06-0180",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Complex transformations",
    "difficulty": "Medium",
    "question": "What is the recommended strategy for very complex transformations?",
    "options": {
      "A": "Single large script",
      "B": "Break logic into reusable functions",
      "C": "Hardcode intermediate values",
      "D": "Avoid modules"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modular functions improve clarity and reuse.",
      "incorrect": {
        "A": "Large scripts are hard to maintain.",
        "C": "Hardcoding reduces flexibility.",
        "D": "Modules improve organization."
      }
    }
  },
  {
    "id": "CH06-0181",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Side effects",
    "difficulty": "Hard",
    "question": "Which characteristic of DataWeave prevents unintended side effects?",
    "options": {
      "A": "Lazy evaluation",
      "B": "Immutability of data",
      "C": "Dynamic typing",
      "D": "Runtime execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures data is not modified unexpectedly.",
      "incorrect": {
        "A": "Lazy evaluation is for performance.",
        "C": "Typing does not prevent side effects.",
        "D": "Runtime execution is unrelated."
      }
    }
  },
  {
    "id": "CH06-0182",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Deterministic output",
    "difficulty": "Medium",
    "question": "Why do DataWeave transformations produce deterministic output?",
    "options": {
      "A": "They use global state",
      "B": "Same input yields same output",
      "C": "They run asynchronously",
      "D": "They depend on environment variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Determinism ensures predictability for integrations.",
      "incorrect": {
        "A": "Global state is avoided.",
        "C": "Asynchronicity is unrelated.",
        "D": "Environment variables are not implicit."
      }
    }
  },
  {
    "id": "CH06-0183",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "Preview limitations",
    "difficulty": "Medium",
    "question": "Why might the DataWeave preview differ from runtime output?",
    "options": {
      "A": "Preview ignores functions",
      "B": "Input data or context differs",
      "C": "Preview uses different syntax",
      "D": "Preview disables type checking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Differences in payload or variables affect output.",
      "incorrect": {
        "A": "Functions are evaluated.",
        "C": "Same syntax is used.",
        "D": "Type checking is not disabled."
      }
    }
  },
  {
    "id": "CH06-0184",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "Error location",
    "difficulty": "Medium",
    "question": "What information do DataWeave error messages usually provide?",
    "options": {
      "A": "Only error code",
      "B": "Exact failing expression and location",
      "C": "General runtime failure",
      "D": "Stack trace only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error messages typically indicate the failing expression.",
      "incorrect": {
        "A": "More detail is provided.",
        "C": "Errors are specific.",
        "D": "Stack trace alone is insufficient."
      }
    }
  },
  {
    "id": "CH06-0185",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Null safety",
    "difficulty": "Medium",
    "question": "Which combination best ensures null safety?",
    "options": {
      "A": "Direct access and casting",
      "B": "Safe navigation and default operator",
      "C": "Hardcoded checks",
      "D": "Avoiding optional fields"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation and defaults prevent null errors.",
      "incorrect": {
        "A": "Direct access may fail.",
        "C": "Hardcoding is brittle.",
        "D": "Avoidance is unrealistic."
      }
    }
  },
  {
    "id": "CH06-0186",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Code readability",
    "difficulty": "Easy",
    "question": "Which practice improves readability of DataWeave scripts?",
    "options": {
      "A": "Long single-line expressions",
      "B": "Consistent formatting and naming",
      "C": "Removing whitespace",
      "D": "Inlining all logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readable formatting improves maintainability.",
      "incorrect": {
        "A": "Long lines reduce clarity.",
        "C": "Whitespace aids readability.",
        "D": "Inlining reduces reuse."
      }
    }
  },
  {
    "id": "CH06-0187",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "Testing strategy",
    "difficulty": "Medium",
    "question": "What should unit tests for DataWeave focus on?",
    "options": {
      "A": "UI rendering",
      "B": "Transformation logic and edge cases",
      "C": "Deployment configuration",
      "D": "Thread management"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tests validate logic and edge cases.",
      "incorrect": {
        "A": "UI is unrelated.",
        "C": "Deployment is separate.",
        "D": "Threading is not relevant."
      }
    }
  },
  {
    "id": "CH06-0188",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Lazy evaluation benefit",
    "difficulty": "Medium",
    "question": "What is a key benefit of lazy evaluation?",
    "options": {
      "A": "Immediate execution",
      "B": "Avoids unnecessary computation",
      "C": "Disables errors",
      "D": "Forces parallelism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lazy evaluation computes values only when needed.",
      "incorrect": {
        "A": "Execution is deferred.",
        "C": "Errors can still occur.",
        "D": "Parallelism is not guaranteed."
      }
    }
  },
  {
    "id": "CH06-0189",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Pipeline readability",
    "difficulty": "Medium",
    "question": "Why are pipelines preferred over nested function calls?",
    "options": {
      "A": "They reduce memory usage",
      "B": "They express transformation flow clearly",
      "C": "They execute faster",
      "D": "They allow mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pipelines show step-by-step data flow.",
      "incorrect": {
        "A": "Memory usage is similar.",
        "C": "Speed is not guaranteed.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0190",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Composition benefit",
    "difficulty": "Medium",
    "question": "What does function composition primarily improve?",
    "options": {
      "A": "Code reuse",
      "B": "Runtime speed",
      "C": "Memory allocation",
      "D": "Syntax complexity"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Composition encourages reuse of small functions.",
      "incorrect": {
        "B": "Speed is not the main goal.",
        "C": "Memory is unaffected.",
        "D": "Complexity is reduced."
      }
    }
  },
  {
    "id": "CH06-0191",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "Referential transparency",
    "difficulty": "Hard",
    "question": "What does referential transparency guarantee?",
    "options": {
      "A": "Faster execution",
      "B": "Same result for same input",
      "C": "Parallel execution",
      "D": "Mutable state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expressions can be replaced with their values safely.",
      "incorrect": {
        "A": "Speed is not guaranteed.",
        "C": "Parallelism is not implied.",
        "D": "State is immutable."
      }
    }
  },
  {
    "id": "CH06-0192",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Empty object handling",
    "difficulty": "Medium",
    "question": "What does isEmpty() return for an empty object?",
    "options": {
      "A": "Null",
      "B": "False",
      "C": "True",
      "D": "Error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "isEmpty() returns true for empty objects.",
      "incorrect": {
        "A": "Null is not returned.",
        "B": "False indicates non-empty.",
        "D": "No error occurs."
      }
    }
  },
  {
    "id": "CH06-0193",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Null propagation",
    "difficulty": "Hard",
    "question": "What happens when safe navigation is used on null?",
    "options": {
      "A": "Throws error",
      "B": "Returns null",
      "C": "Returns empty object",
      "D": "Returns default value"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation propagates null safely.",
      "incorrect": {
        "A": "Errors are avoided.",
        "C": "Empty object is not assumed.",
        "D": "Defaults require ?? operator."
      }
    }
  },
  {
    "id": "CH06-0194",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "Null vs empty",
    "difficulty": "Medium",
    "question": "What is the key difference between null and empty collections?",
    "options": {
      "A": "They are identical",
      "B": "Null represents absence, empty represents no elements",
      "C": "Empty collections cause errors",
      "D": "Null has size zero"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Null means no value, empty means value with no elements.",
      "incorrect": {
        "A": "They are different.",
        "C": "Empty collections are valid.",
        "D": "Null has no size."
      }
    }
  },
  {
    "id": "CH06-0195",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "Conditional output",
    "difficulty": "Medium",
    "question": "How can output fields be conditionally excluded?",
    "options": {
      "A": "Using if outside output",
      "B": "Using when inside object",
      "C": "Using try",
      "D": "Using filter"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "when controls conditional field inclusion.",
      "incorrect": {
        "A": "Invalid placement.",
        "C": "Error handling is different.",
        "D": "filter is for arrays."
      }
    }
  },
  {
    "id": "CH06-0196",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "Skip nulls",
    "difficulty": "Medium",
    "question": "Which configuration helps omit null values from output?",
    "options": {
      "A": "ignoreNulls",
      "B": "skipNullOn",
      "C": "removeNull",
      "D": "nullSafe"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "skipNullOn controls null omission in output.",
      "incorrect": {
        "A": "Not valid.",
        "C": "Not supported.",
        "D": "Invalid option."
      }
    }
  },
  {
    "id": "CH06-0197",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Event immutability",
    "difficulty": "Hard",
    "question": "Why is the Mule event immutable during DataWeave execution?",
    "options": {
      "A": "To improve performance",
      "B": "To ensure thread safety",
      "C": "To simplify syntax",
      "D": "To allow mutation later"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures safe concurrent processing.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Syntax is unaffected.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0198",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "Thread safety",
    "difficulty": "Medium",
    "question": "Which DataWeave feature supports thread safety?",
    "options": {
      "A": "Global variables",
      "B": "Immutability",
      "C": "Side effects",
      "D": "Runtime mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutable data prevents race conditions.",
      "incorrect": {
        "A": "Globals are not allowed.",
        "C": "Side effects are avoided.",
        "D": "Mutation breaks safety."
      }
    }
  },
  {
    "id": "CH06-0199",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "Transformation philosophy",
    "difficulty": "Medium",
    "question": "What is the core philosophy behind DataWeave transformations?",
    "options": {
      "A": "Imperative data manipulation",
      "B": "Functional, declarative data transformation",
      "C": "Stateful processing",
      "D": "Object-oriented programming"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave follows a functional, declarative model.",
      "incorrect": {
        "A": "Imperative style is avoided.",
        "C": "State is immutable.",
        "D": "It is not object-oriented."
      }
    }
  },
  {
    "id": "CH06-0200",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "Production mindset",
    "difficulty": "Medium",
    "question": "Which mindset best aligns with DataWeave usage in production?",
    "options": {
      "A": "Quick hacks",
      "B": "Declarative, safe, and testable transformations",
      "C": "Hardcoded assumptions",
      "D": "Minimal validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Production-grade DataWeave emphasizes safety and clarity.",
      "incorrect": {
        "A": "Hacks reduce reliability.",
        "C": "Hardcoding limits reuse.",
        "D": "Validation is essential."
      }
    }
  },
  {
    "id": "CH06-0201",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "chunking",
    "difficulty": "Hard",
    "question": "Which function splits an array into smaller arrays of a given size?",
    "options": {
      "A": "partition()",
      "B": "chunk()",
      "C": "groupOf()",
      "D": "window()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "chunk() divides an array into subarrays of a specified size.",
      "incorrect": {
        "A": "partition() is not a DataWeave function.",
        "C": "groupOf() is invalid.",
        "D": "window() is not supported."
      }
    }
  },
  {
    "id": "CH06-0202",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "chunk remainder",
    "difficulty": "Medium",
    "question": "What happens if array length is not divisible by chunk size?",
    "options": {
      "A": "Last elements are dropped",
      "B": "An error is thrown",
      "C": "Last chunk contains remaining elements",
      "D": "Array is padded with nulls"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The final chunk contains the remaining elements.",
      "incorrect": {
        "A": "Elements are not dropped.",
        "B": "No error occurs.",
        "D": "Padding does not occur."
      }
    }
  },
  {
    "id": "CH06-0203",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "distinctBy selector",
    "difficulty": "Hard",
    "question": "What does distinctBy require to determine uniqueness?",
    "options": {
      "A": "Comparator function",
      "B": "Selector expression",
      "C": "Boolean predicate",
      "D": "Index reference"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "distinctBy uses a selector expression to identify uniqueness.",
      "incorrect": {
        "A": "Comparators are not used.",
        "C": "Predicates are for filter.",
        "D": "Index is not required."
      }
    }
  },
  {
    "id": "CH06-0204",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "zip structure",
    "difficulty": "Medium",
    "question": "What is the structure of elements produced by zip?",
    "options": {
      "A": "Single flattened values",
      "B": "Arrays containing paired elements",
      "C": "Objects with named keys",
      "D": "Concatenated strings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "zip produces arrays of paired elements by index.",
      "incorrect": {
        "A": "Flattening is not done.",
        "C": "Objects are not created.",
        "D": "Strings are not produced."
      }
    }
  },
  {
    "id": "CH06-0205",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object flattening",
    "difficulty": "Hard",
    "question": "How can a nested object be flattened into key-path entries?",
    "options": {
      "A": "Using flatten() directly",
      "B": "Using recursion with mapObject",
      "C": "Using groupBy()",
      "D": "Using zip()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Flattening nested objects requires recursive traversal with mapObject.",
      "incorrect": {
        "A": "flatten() applies to arrays.",
        "C": "groupBy groups values.",
        "D": "zip pairs arrays."
      }
    }
  },
  {
    "id": "CH06-0206",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object default merge",
    "difficulty": "Medium",
    "question": "Which operator can be used to merge objects while providing defaults?",
    "options": {
      "A": "++ with ??",
      "B": "-- with ??",
      "C": "+ with default",
      "D": ":: with as"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Objects can be merged using ++ and defaults supplied with ??.",
      "incorrect": {
        "B": "The -- operator removes keys.",
        "C": "The + operator is invalid for objects.",
        "D": "Module access is unrelated."
      }
    }
  },
  {
    "id": "CH06-0207",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "mapObject index",
    "difficulty": "Medium",
    "question": "Which parameters are available in mapObject?",
    "options": {
      "A": "value only",
      "B": "key and value",
      "C": "value and index",
      "D": "key, value, and index"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mapObject provides key and value parameters.",
      "incorrect": {
        "A": "Key is also provided.",
        "C": "Index is not provided.",
        "D": "Index is not available."
      }
    }
  },
  {
    "id": "CH06-0208",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "regex groups",
    "difficulty": "Hard",
    "question": "How are regex capture groups accessed after a match?",
    "options": {
      "A": "By numeric index in result array",
      "B": "By named properties automatically",
      "C": "Using getGroup()",
      "D": "Capture groups are not accessible"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Capture groups are accessed by index from the match result.",
      "incorrect": {
        "B": "Automatic naming is not provided.",
        "C": "No such function exists.",
        "D": "Groups are accessible."
      }
    }
  },
  {
    "id": "CH06-0209",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "string length",
    "difficulty": "Easy",
    "question": "Which function returns the length of a string?",
    "options": {
      "A": "length()",
      "B": "sizeOf()",
      "C": "count()",
      "D": "strlen()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf() returns the size of strings, arrays, and objects.",
      "incorrect": {
        "A": "length() is not valid.",
        "C": "count() is not supported.",
        "D": "strlen() does not exist."
      }
    }
  },
  {
    "id": "CH06-0210",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "absolute value",
    "difficulty": "Easy",
    "question": "Which function returns the absolute value of a number?",
    "options": {
      "A": "abs()",
      "B": "absolute()",
      "C": "magnitude()",
      "D": "pos()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "abs() returns the absolute value.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Invalid function.",
        "D": "Not valid."
      }
    }
  },
  {
    "id": "CH06-0211",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "numeric comparison",
    "difficulty": "Easy",
    "question": "Which operator checks if one number is greater than another?",
    "options": {
      "A": "=>",
      "B": ">",
      "C": ">>",
      "D": "gt"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The > operator checks numeric greater-than comparison.",
      "incorrect": {
        "A": "=> is used in lambdas.",
        "C": "Not a comparison operator.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0212",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "DateTime formatting",
    "difficulty": "Hard",
    "question": "How is a DateTime formatted into a string?",
    "options": {
      "A": "Using toString()",
      "B": "Using as String with a format",
      "C": "Using formatDate()",
      "D": "Using stringify()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Formatting is done using the as operator with a format pattern.",
      "incorrect": {
        "A": "Default formatting may not match requirements.",
        "C": "Not a valid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0213",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "LocalTime",
    "difficulty": "Medium",
    "question": "What does the LocalTime type represent?",
    "options": {
      "A": "Date with timezone",
      "B": "Time without date",
      "C": "DateTime without timezone",
      "D": "Full timestamp"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "LocalTime represents time without date information.",
      "incorrect": {
        "A": "Timezone is not included.",
        "C": "Date is not included.",
        "D": "Full timestamp is different."
      }
    }
  },
  {
    "id": "CH06-0214",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "ternary equivalent",
    "difficulty": "Medium",
    "question": "How is conditional selection expressed without a ternary operator?",
    "options": {
      "A": "Using if-else expressions",
      "B": "Using match only",
      "C": "Using when outside objects",
      "D": "Using ?? operator"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "if-else expressions replace ternary behavior.",
      "incorrect": {
        "B": "match is not always required.",
        "C": "when is field-specific.",
        "D": "?? provides defaults only."
      }
    }
  },
  {
    "id": "CH06-0215",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "truthy values",
    "difficulty": "Hard",
    "question": "How does DataWeave treat non-Boolean values in conditions?",
    "options": {
      "A": "Automatically coerces to Boolean",
      "B": "Treats non-null as true",
      "C": "Requires explicit Boolean expressions",
      "D": "Allows numbers only"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Conditions must evaluate to Boolean explicitly.",
      "incorrect": {
        "A": "Automatic coercion is not applied.",
        "B": "Truthy evaluation is not used.",
        "D": "Numbers are not implicitly allowed."
      }
    }
  },
  {
    "id": "CH06-0216",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "function return",
    "difficulty": "Easy",
    "question": "What determines the return value of a DataWeave function?",
    "options": {
      "A": "Explicit return keyword",
      "B": "Last evaluated expression",
      "C": "Function name",
      "D": "Parameter types"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functions return the value of the last expression.",
      "incorrect": {
        "A": "No return keyword exists.",
        "C": "Name does not affect return.",
        "D": "Types do not determine return value."
      }
    }
  },
  {
    "id": "CH06-0217",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "function scope",
    "difficulty": "Medium",
    "question": "Where can custom functions be defined?",
    "options": {
      "A": "Only inside modules",
      "B": "At top-level of the script",
      "C": "Only inside objects",
      "D": "Only inside let blocks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom functions are defined at the script's top level.",
      "incorrect": {
        "A": "Modules are optional.",
        "C": "Objects cannot define functions.",
        "D": "let blocks define variables."
      }
    }
  },
  {
    "id": "CH06-0218",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "expression ordering",
    "difficulty": "Hard",
    "question": "Why does expression order sometimes not affect performance?",
    "options": {
      "A": "Because of eager evaluation",
      "B": "Because of lazy evaluation",
      "C": "Because of parallel execution",
      "D": "Because of compilation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lazy evaluation computes expressions only when needed.",
      "incorrect": {
        "A": "Evaluation is not eager.",
        "C": "Parallelism is not guaranteed.",
        "D": "Compilation is not the cause."
      }
    }
  },
  {
    "id": "CH06-0219",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "avoid recomputation",
    "difficulty": "Medium",
    "question": "Which construct avoids recomputing the same expression multiple times?",
    "options": {
      "A": "map",
      "B": "let",
      "C": "filter",
      "D": "reduce"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "let binds a computed value for reuse.",
      "incorrect": {
        "A": "map recomputes per element.",
        "C": "filter evaluates predicates repeatedly.",
        "D": "reduce aggregates values."
      }
    }
  },
  {
    "id": "CH06-0220",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "payload immutability",
    "difficulty": "Medium",
    "question": "What happens if you attempt to modify the input payload directly?",
    "options": {
      "A": "Payload is updated",
      "B": "Compilation error occurs",
      "C": "A new transformed value is produced",
      "D": "Runtime exception is thrown"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Transformations produce new values; input remains unchanged.",
      "incorrect": {
        "A": "Direct modification is not allowed.",
        "B": "Compilation succeeds.",
        "D": "No exception is required."
      }
    }
  },
  {
    "id": "CH06-0221",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "attributes access",
    "difficulty": "Easy",
    "question": "Which keyword accesses Mule event attributes in DataWeave?",
    "options": {
      "A": "props",
      "B": "attributes",
      "C": "metadata",
      "D": "headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "attributes exposes Mule event metadata.",
      "incorrect": {
        "A": "props is not used in Mule 4.",
        "C": "metadata is not a keyword.",
        "D": "headers are accessed via attributes."
      }
    }
  },
  {
    "id": "CH06-0222",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "query params",
    "difficulty": "Medium",
    "question": "Where are HTTP query parameters found in DataWeave?",
    "options": {
      "A": "payload",
      "B": "vars",
      "C": "attributes.queryParams",
      "D": "attributes.headers"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Query parameters are accessed via attributes.queryParams.",
      "incorrect": {
        "A": "Payload contains the body.",
        "B": "vars are flow variables.",
        "D": "Headers are separate."
      }
    }
  },
  {
    "id": "CH06-0223",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "log values",
    "difficulty": "Medium",
    "question": "What is a common approach to inspect intermediate values during development?",
    "options": {
      "A": "Use println()",
      "B": "Preview with sample input",
      "C": "Modify payload directly",
      "D": "Disable lazy evaluation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Previewing with sample inputs helps inspect transformations.",
      "incorrect": {
        "A": "println() is not available.",
        "C": "Direct modification is not allowed.",
        "D": "Lazy evaluation cannot be disabled."
      }
    }
  },
  {
    "id": "CH06-0224",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "error root cause",
    "difficulty": "Medium",
    "question": "What usually helps identify the root cause of a DataWeave error?",
    "options": {
      "A": "Ignoring stack traces",
      "B": "Reading the failing expression location",
      "C": "Retrying execution",
      "D": "Changing output format"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error messages usually indicate the failing expression.",
      "incorrect": {
        "A": "Stack traces provide useful context.",
        "C": "Retrying does not fix logic errors.",
        "D": "Output format is unrelated."
      }
    }
  },
  {
    "id": "CH06-0225",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "null defaults",
    "difficulty": "Easy",
    "question": "Which operator provides a fallback value when an expression is null?",
    "options": {
      "A": "or",
      "B": "??",
      "C": "and",
      "D": "as"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The ?? operator supplies default values.",
      "incorrect": {
        "A": "Logical operator.",
        "C": "Logical operator.",
        "D": "Type coercion."
      }
    }
  },
  {
    "id": "CH06-0226",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "safe selectors",
    "difficulty": "Medium",
    "question": "Which operator avoids errors when accessing optional fields?",
    "options": {
      "A": "!",
      "B": "?.",
      "C": "::",
      "D": "#"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The safe navigation operator ?. prevents null access errors.",
      "incorrect": {
        "A": "Not a selector.",
        "C": "Used for modules.",
        "D": "Not applicable."
      }
    }
  },
  {
    "id": "CH06-0227",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "functional style",
    "difficulty": "Medium",
    "question": "Which feature best characterizes DataWeave's functional style?",
    "options": {
      "A": "Mutable variables",
      "B": "Pure functions and immutability",
      "C": "Stateful objects",
      "D": "Imperative loops"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability and pure functions define the functional approach.",
      "incorrect": {
        "A": "Variables are immutable.",
        "C": "Stateful logic is avoided.",
        "D": "Imperative loops are not primary."
      }
    }
  },
  {
    "id": "CH06-0228",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "side effects",
    "difficulty": "Hard",
    "question": "Why are side effects discouraged in DataWeave?",
    "options": {
      "A": "They reduce performance",
      "B": "They break predictability",
      "C": "They increase syntax complexity",
      "D": "They are unsupported"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Side effects make transformations unpredictable.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Syntax complexity is unrelated.",
        "D": "Side effects are avoided by design."
      }
    }
  },
  {
    "id": "CH06-0229",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "determinism",
    "difficulty": "Medium",
    "question": "Which property ensures the same input always produces the same output?",
    "options": {
      "A": "Idempotence",
      "B": "Determinism",
      "C": "Concurrency",
      "D": "Asynchronicity"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Determinism guarantees consistent results.",
      "incorrect": {
        "A": "Idempotence is different.",
        "C": "Concurrency is unrelated.",
        "D": "Asynchronicity is unrelated."
      }
    }
  },
  {
    "id": "CH06-0230",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "idempotence",
    "difficulty": "Hard",
    "question": "What does idempotence mean in the context of transformations?",
    "options": {
      "A": "Faster execution",
      "B": "Repeated application yields same result",
      "C": "Parallel execution",
      "D": "State mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent transformations produce the same result when reapplied.",
      "incorrect": {
        "A": "Speed is not implied.",
        "C": "Parallelism is unrelated.",
        "D": "Mutation is avoided."
      }
    }
  },
  {
    "id": "CH06-0231",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "null map",
    "difficulty": "Hard",
    "question": "What happens when map is applied to a null value?",
    "options": {
      "A": "Returns empty array",
      "B": "Returns null",
      "C": "Throws a runtime error",
      "D": "Skips evaluation"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "map expects an iterable and fails on null.",
      "incorrect": {
        "A": "Empty array is not assumed.",
        "B": "Null is not propagated.",
        "D": "Execution does not skip silently."
      }
    }
  },
  {
    "id": "CH06-0232",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "safe map",
    "difficulty": "Medium",
    "question": "How can map be safely applied when input may be null?",
    "options": {
      "A": "Using try",
      "B": "Using ?? with an empty array",
      "C": "Using match",
      "D": "Using as Array"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Providing a default empty array avoids errors.",
      "incorrect": {
        "A": "try is not necessary here.",
        "C": "match is unrelated.",
        "D": "Casting does not fix null."
      }
    }
  },
  {
    "id": "CH06-0233",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Edge Cases",
    "subtopic": "empty reduce",
    "difficulty": "Hard",
    "question": "Why does reduce without an initial value fail on empty arrays?",
    "options": {
      "A": "No elements to infer type",
      "B": "Accumulator cannot be initialized",
      "C": "Index is missing",
      "D": "Lazy evaluation stops"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The accumulator has no starting value.",
      "incorrect": {
        "A": "Type inference is not the issue.",
        "C": "Index is unrelated.",
        "D": "Lazy evaluation still applies."
      }
    }
  },
  {
    "id": "CH06-0234",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "output types",
    "difficulty": "Easy",
    "question": "Which output type produces Java-native Maps and Lists?",
    "options": {
      "A": "application/json",
      "B": "application/java",
      "C": "application/xml",
      "D": "application/dw"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "application/java outputs Java-native structures.",
      "incorrect": {
        "A": "JSON text is produced.",
        "C": "XML is produced.",
        "D": "Internal representation only."
      }
    }
  },
  {
    "id": "CH06-0235",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Output Control",
    "subtopic": "single output",
    "difficulty": "Easy",
    "question": "How many output directives can a DataWeave script contain?",
    "options": {
      "A": "Zero",
      "B": "One",
      "C": "Two",
      "D": "Unlimited"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Only one output directive is allowed.",
      "incorrect": {
        "A": "An output is required.",
        "C": "Multiple outputs are not supported.",
        "D": "Unlimited is invalid."
      }
    }
  },
  {
    "id": "CH06-0236",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "script structure",
    "difficulty": "Medium",
    "question": "Which structure improves readability of large DataWeave scripts?",
    "options": {
      "A": "Single expression body",
      "B": "Clear separation of functions and main logic",
      "C": "Deep nesting",
      "D": "Hardcoded constants inline"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Separating concerns improves clarity and maintenance.",
      "incorrect": {
        "A": "Single expressions reduce clarity.",
        "C": "Deep nesting is discouraged.",
        "D": "Hardcoding reduces reuse."
      }
    }
  },
  {
    "id": "CH06-0237",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "reuse logic",
    "difficulty": "Medium",
    "question": "What is the preferred way to reuse transformation logic?",
    "options": {
      "A": "Copy-paste expressions",
      "B": "Create reusable functions or modules",
      "C": "Inline logic everywhere",
      "D": "Hardcode values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functions and modules promote reuse and consistency.",
      "incorrect": {
        "A": "Copy-paste causes duplication.",
        "C": "Inlining reduces reuse.",
        "D": "Hardcoding reduces flexibility."
      }
    }
  },
  {
    "id": "CH06-0238",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "data safety",
    "difficulty": "Medium",
    "question": "Which feature most contributes to data safety in DataWeave?",
    "options": {
      "A": "Immutability",
      "B": "Dynamic typing",
      "C": "Asynchronous execution",
      "D": "Implicit coercion"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Immutability prevents unintended data changes.",
      "incorrect": {
        "B": "Typing does not ensure safety.",
        "C": "Asynchronicity is unrelated.",
        "D": "Coercion can introduce errors."
      }
    }
  },
  {
    "id": "CH06-0239",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "design goal",
    "difficulty": "Medium",
    "question": "What is the primary design goal of DataWeave?",
    "options": {
      "A": "UI rendering",
      "B": "Declarative data transformation",
      "C": "State management",
      "D": "Thread control"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave is designed for declarative data transformations.",
      "incorrect": {
        "A": "UI is unrelated.",
        "C": "State is immutable.",
        "D": "Threading is handled by runtime."
      }
    }
  },
  {
    "id": "CH06-0240",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "production readiness",
    "difficulty": "Medium",
    "question": "Which combination best indicates production-ready DataWeave code?",
    "options": {
      "A": "Minimal validation and quick fixes",
      "B": "Clear structure, null safety, and tests",
      "C": "Hardcoded assumptions",
      "D": "Deeply nested expressions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Production readiness requires clarity, safety, and testing.",
      "incorrect": {
        "A": "Minimal validation increases risk.",
        "C": "Hardcoding limits adaptability.",
        "D": "Deep nesting reduces maintainability."
      }
    }
  },
  {
    "id": "CH06-0241",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "take function",
    "difficulty": "Easy",
    "question": "What does the take function do when applied to an array?",
    "options": {
      "A": "Removes the last N elements",
      "B": "Returns the first N elements",
      "C": "Filters elements by index",
      "D": "Splits array into chunks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "take returns the first N elements of an array.",
      "incorrect": {
        "A": "drop removes elements.",
        "C": "Index-based filtering is different.",
        "D": "chunk splits arrays."
      }
    }
  },
  {
    "id": "CH06-0242",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "drop function",
    "difficulty": "Easy",
    "question": "What is the effect of the drop function on an array?",
    "options": {
      "A": "Keeps only matching elements",
      "B": "Removes the first N elements",
      "C": "Removes null values",
      "D": "Sorts the array"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "drop removes the first specified number of elements.",
      "incorrect": {
        "A": "Filtering is different.",
        "C": "Null removal uses other approaches.",
        "D": "Sorting is unrelated."
      }
    }
  },
  {
    "id": "CH06-0243",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "slice behavior",
    "difficulty": "Medium",
    "question": "How does slice behave when the end index exceeds array length?",
    "options": {
      "A": "Throws an error",
      "B": "Returns null",
      "C": "Returns elements until the end of the array",
      "D": "Pads with nulls"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "slice safely returns available elements up to the array end.",
      "incorrect": {
        "A": "No error is thrown.",
        "B": "Null is not returned.",
        "D": "Padding does not occur."
      }
    }
  },
  {
    "id": "CH06-0244",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "contains usage",
    "difficulty": "Medium",
    "question": "How can you check if an array contains a specific value?",
    "options": {
      "A": "Using in operator",
      "B": "Using has()",
      "C": "Using exists()",
      "D": "Using find()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The in operator checks value membership in arrays.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Not valid.",
        "D": "find returns elements."
      }
    }
  },
  {
    "id": "CH06-0245",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "find vs filter",
    "difficulty": "Medium",
    "question": "What is the key difference between find and filter?",
    "options": {
      "A": "find returns a single element or null",
      "B": "filter is faster",
      "C": "find returns an array",
      "D": "filter stops after first match"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "find returns the first matching element or null.",
      "incorrect": {
        "B": "Performance depends on use case.",
        "C": "filter returns arrays.",
        "D": "filter evaluates all elements."
      }
    }
  },
  {
    "id": "CH06-0246",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "pluck function",
    "difficulty": "Medium",
    "question": "What does the pluck function return when applied to an object?",
    "options": {
      "A": "Object with same structure",
      "B": "Array derived from key-value pairs",
      "C": "Flattened object",
      "D": "Boolean value"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "pluck transforms objects into arrays using key-value logic.",
      "incorrect": {
        "A": "Structure is changed.",
        "C": "Flattening is different.",
        "D": "No Boolean result."
      }
    }
  },
  {
    "id": "CH06-0247",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "pluck parameters",
    "difficulty": "Hard",
    "question": "Which parameters are available inside a pluck expression?",
    "options": {
      "A": "value only",
      "B": "key and value",
      "C": "value and index",
      "D": "key, value, and index"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "pluck provides key and value to the lambda.",
      "incorrect": {
        "A": "Key is also available.",
        "C": "Index is not provided.",
        "D": "Index is not supported."
      }
    }
  },
  {
    "id": "CH06-0248",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "mapObject vs pluck",
    "difficulty": "Hard",
    "question": "When should pluck be preferred over mapObject?",
    "options": {
      "A": "When output should be an array",
      "B": "When output must remain an object",
      "C": "When filtering is required",
      "D": "When sorting keys"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "pluck is used when an array output is desired.",
      "incorrect": {
        "B": "mapObject retains object structure.",
        "C": "Filtering is separate.",
        "D": "Sorting is unrelated."
      }
    }
  },
  {
    "id": "CH06-0249",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "trim function",
    "difficulty": "Easy",
    "question": "Which function removes leading and trailing whitespace from a string?",
    "options": {
      "A": "strip()",
      "B": "trim()",
      "C": "clean()",
      "D": "chomp()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "trim removes whitespace from both ends of a string.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Invalid function.",
        "D": "Not available."
      }
    }
  },
  {
    "id": "CH06-0250",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "upper lower",
    "difficulty": "Easy",
    "question": "Which function converts a string to uppercase?",
    "options": {
      "A": "upper()",
      "B": "toUpper()",
      "C": "capitalize()",
      "D": "caseUpper()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "toUpper converts all characters to uppercase.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Capitalizes only first letter.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0251",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "split behavior",
    "difficulty": "Medium",
    "question": "What does split return when the delimiter is not found?",
    "options": {
      "A": "Null",
      "B": "Empty array",
      "C": "Array with original string",
      "D": "Runtime error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "split returns an array containing the original string.",
      "incorrect": {
        "A": "Null is not returned.",
        "B": "Empty array is incorrect.",
        "D": "No error occurs."
      }
    }
  },
  {
    "id": "CH06-0252",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "rounding",
    "difficulty": "Medium",
    "question": "Which function rounds a number to the nearest integer?",
    "options": {
      "A": "ceil()",
      "B": "round()",
      "C": "floor()",
      "D": "fix()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "round rounds to the nearest integer.",
      "incorrect": {
        "A": "ceil rounds up.",
        "C": "floor rounds down.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0253",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "floor behavior",
    "difficulty": "Easy",
    "question": "What does floor(3.9) return?",
    "options": {
      "A": "3",
      "B": "4",
      "C": "3.9",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "floor returns the largest integer less than or equal to the number.",
      "incorrect": {
        "B": "ceil would return 4.",
        "C": "Original value is not preserved.",
        "D": "No error occurs."
      }
    }
  },
  {
    "id": "CH06-0254",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "now function",
    "difficulty": "Easy",
    "question": "What does the now() function return?",
    "options": {
      "A": "Current Date",
      "B": "Current DateTime",
      "C": "Current Time only",
      "D": "Timestamp as string"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "now() returns the current DateTime.",
      "incorrect": {
        "A": "Date only is insufficient.",
        "C": "Time only is different.",
        "D": "String conversion is not default."
      }
    }
  },
  {
    "id": "CH06-0255",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "timezone conversion",
    "difficulty": "Hard",
    "question": "How can a DateTime be converted to another timezone?",
    "options": {
      "A": "Using withTimeZone()",
      "B": "Using as DateTime with timezone",
      "C": "Using convertTZ()",
      "D": "Timezone conversion is automatic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Timezone conversion is done via as DateTime with timezone.",
      "incorrect": {
        "A": "Not a valid function.",
        "C": "Not supported.",
        "D": "Conversion is explicit."
      }
    }
  },
  {
    "id": "CH06-0256",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "logical not",
    "difficulty": "Easy",
    "question": "Which operator negates a Boolean expression?",
    "options": {
      "A": "!",
      "B": "not",
      "C": "~",
      "D": "neg"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "not negates Boolean expressions.",
      "incorrect": {
        "A": "Not used in DataWeave.",
        "C": "Not supported.",
        "D": "Invalid operator."
      }
    }
  },
  {
    "id": "CH06-0257",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "logical precedence",
    "difficulty": "Medium",
    "question": "Which logical operator has the lowest precedence?",
    "options": {
      "A": "not",
      "B": "and",
      "C": "or",
      "D": "=="
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "or has lower precedence than and and not.",
      "incorrect": {
        "A": "not has highest precedence.",
        "B": "and has higher precedence than or.",
        "D": "Comparison precedence differs."
      }
    }
  },
  {
    "id": "CH06-0258",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "function visibility",
    "difficulty": "Medium",
    "question": "How can a function be made reusable across scripts?",
    "options": {
      "A": "Define it inside let",
      "B": "Place it in a custom module",
      "C": "Inline it in output",
      "D": "Declare it inside an object"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modules allow reuse across scripts.",
      "incorrect": {
        "A": "let scopes locally.",
        "C": "Inline logic is not reusable.",
        "D": "Objects do not expose functions."
      }
    }
  },
  {
    "id": "CH06-0259",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "lambda shorthand",
    "difficulty": "Easy",
    "question": "What does the $ symbol represent inside a lambda?",
    "options": {
      "A": "Index",
      "B": "Current value",
      "C": "Key",
      "D": "Accumulator"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "$ represents the current element value.",
      "incorrect": {
        "A": "$$ represents index.",
        "C": "Key applies to objects.",
        "D": "Accumulator applies to reduce."
      }
    }
  },
  {
    "id": "CH06-0260",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "double lambda",
    "difficulty": "Medium",
    "question": "What does $$ represent inside a lambda?",
    "options": {
      "A": "Value",
      "B": "Index",
      "C": "Key",
      "D": "Result"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "$$ represents the index of the current element.",
      "incorrect": {
        "A": "Value is $.",
        "C": "Key applies to objects.",
        "D": "Result is not implicit."
      }
    }
  },
  {
    "id": "CH06-0261",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "filter ordering",
    "difficulty": "Medium",
    "question": "Why is filtering early in pipelines recommended?",
    "options": {
      "A": "To change output type",
      "B": "To reduce downstream processing",
      "C": "To enable mutation",
      "D": "To enforce typing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early filtering reduces the number of elements processed later.",
      "incorrect": {
        "A": "Type is unaffected.",
        "C": "Mutation is not allowed.",
        "D": "Typing is unrelated."
      }
    }
  },
  {
    "id": "CH06-0262",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "lazy benefit",
    "difficulty": "Medium",
    "question": "Which scenario benefits most from lazy evaluation?",
    "options": {
      "A": "Small arrays",
      "B": "Large datasets with early termination",
      "C": "Simple arithmetic",
      "D": "Static strings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lazy evaluation avoids unnecessary processing on large datasets.",
      "incorrect": {
        "A": "Benefits are minimal.",
        "C": "Arithmetic is eager.",
        "D": "Strings are static."
      }
    }
  },
  {
    "id": "CH06-0263",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "vars access",
    "difficulty": "Easy",
    "question": "Which keyword accesses flow variables in DataWeave?",
    "options": {
      "A": "props",
      "B": "vars",
      "C": "attributes",
      "D": "context"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "vars provides access to flow variables.",
      "incorrect": {
        "A": "props is deprecated.",
        "C": "attributes are metadata.",
        "D": "context is not used."
      }
    }
  },
  {
    "id": "CH06-0264",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "payload keyword",
    "difficulty": "Easy",
    "question": "Which keyword represents the message payload?",
    "options": {
      "A": "body",
      "B": "payload",
      "C": "content",
      "D": "message"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "payload refers to the message body.",
      "incorrect": {
        "A": "Not used in Mule 4.",
        "C": "Invalid keyword.",
        "D": "Not a DataWeave keyword."
      }
    }
  },
  {
    "id": "CH06-0265",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "preview usage",
    "difficulty": "Easy",
    "question": "What is the primary purpose of the DataWeave preview?",
    "options": {
      "A": "Deploy code",
      "B": "Validate transformations with sample data",
      "C": "Optimize performance",
      "D": "Generate documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Preview allows testing transformations with sample input.",
      "incorrect": {
        "A": "Deployment is separate.",
        "C": "Performance tuning is manual.",
        "D": "Documentation is not generated."
      }
    }
  },
  {
    "id": "CH06-0266",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "common error",
    "difficulty": "Medium",
    "question": "Which mistake commonly causes runtime errors in DataWeave?",
    "options": {
      "A": "Explicit typing",
      "B": "Accessing null without safe navigation",
      "C": "Using let bindings",
      "D": "Using functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Direct access on null causes runtime errors.",
      "incorrect": {
        "A": "Typing improves safety.",
        "C": "let improves reuse.",
        "D": "Functions are safe."
      }
    }
  },
  {
    "id": "CH06-0267",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "null handling",
    "difficulty": "Medium",
    "question": "Which combination best handles optional fields safely?",
    "options": {
      "A": "Direct access only",
      "B": "Safe navigation and default values",
      "C": "Hardcoded checks",
      "D": "Ignoring nulls"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation with defaults prevents null errors.",
      "incorrect": {
        "A": "Direct access may fail.",
        "C": "Hardcoding is brittle.",
        "D": "Ignoring nulls is unsafe."
      }
    }
  },
  {
    "id": "CH06-0268",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "script size",
    "difficulty": "Medium",
    "question": "How should very large DataWeave scripts be managed?",
    "options": {
      "A": "Keep as one file",
      "B": "Split into functions and modules",
      "C": "Inline all logic",
      "D": "Avoid comments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Breaking logic improves maintainability.",
      "incorrect": {
        "A": "Large files are hard to maintain.",
        "C": "Inlining reduces reuse.",
        "D": "Comments aid clarity."
      }
    }
  },
  {
    "id": "CH06-0269",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "transformation flow",
    "difficulty": "Medium",
    "question": "What best describes the flow of a DataWeave transformation?",
    "options": {
      "A": "Imperative step-by-step mutation",
      "B": "Declarative mapping from input to output",
      "C": "Stateful processing pipeline",
      "D": "Event-driven execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave declaratively maps input data to output.",
      "incorrect": {
        "A": "Mutation is avoided.",
        "C": "State is immutable.",
        "D": "Execution is deterministic."
      }
    }
  },
  {
    "id": "CH06-0270",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "key strength",
    "difficulty": "Easy",
    "question": "What is one of DataWeave's strongest advantages?",
    "options": {
      "A": "Mutable data handling",
      "B": "Clear and expressive data transformations",
      "C": "Low-level memory control",
      "D": "Thread management"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave excels at clear data transformations.",
      "incorrect": {
        "A": "Data is immutable.",
        "C": "Memory control is abstracted.",
        "D": "Threading is managed by runtime."
      }
    }
  },
  {
    "id": "CH06-0271",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "design principle",
    "difficulty": "Medium",
    "question": "Which principle underpins DataWeave's design?",
    "options": {
      "A": "Imperative control flow",
      "B": "Functional and immutable data processing",
      "C": "Stateful transformations",
      "D": "Object-oriented modeling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functional immutability is core to DataWeave.",
      "incorrect": {
        "A": "Imperative style is avoided.",
        "C": "State is immutable.",
        "D": "Not object-oriented."
      }
    }
  },
  {
    "id": "CH06-0272",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "learning curve",
    "difficulty": "Medium",
    "question": "What helps reduce the learning curve of DataWeave?",
    "options": {
      "A": "Avoiding functions",
      "B": "Understanding functional concepts",
      "C": "Using imperative thinking",
      "D": "Ignoring types"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functional concepts align closely with DataWeave.",
      "incorrect": {
        "A": "Functions are essential.",
        "C": "Imperative thinking conflicts.",
        "D": "Types aid understanding."
      }
    }
  },
  {
    "id": "CH06-0273",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "immutability benefit",
    "difficulty": "Medium",
    "question": "What is a key benefit of immutability in DataWeave?",
    "options": {
      "A": "Faster arithmetic",
      "B": "Predictable transformations",
      "C": "Dynamic mutation",
      "D": "Reduced syntax"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures predictable behavior.",
      "incorrect": {
        "A": "Arithmetic speed is unaffected.",
        "C": "Mutation is not allowed.",
        "D": "Syntax is unchanged."
      }
    }
  },
  {
    "id": "CH06-0274",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "error prevention",
    "difficulty": "Medium",
    "question": "Which feature helps prevent runtime errors most effectively?",
    "options": {
      "A": "Explicit null handling",
      "B": "Lazy evaluation",
      "C": "Dynamic typing",
      "D": "Hardcoding values"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Explicit null handling avoids common runtime failures.",
      "incorrect": {
        "B": "Lazy evaluation improves performance.",
        "C": "Typing alone is insufficient.",
        "D": "Hardcoding increases risk."
      }
    }
  },
  {
    "id": "CH06-0275",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "transformation safety",
    "difficulty": "Medium",
    "question": "Why are transformations considered safe in DataWeave?",
    "options": {
      "A": "They mutate data in place",
      "B": "They are immutable and side-effect free",
      "C": "They use global state",
      "D": "They rely on runtime flags"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability and purity ensure safety.",
      "incorrect": {
        "A": "Mutation is not allowed.",
        "C": "Global state is avoided.",
        "D": "Runtime flags are unrelated."
      }
    }
  },
  {
    "id": "CH06-0276",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "maintainability",
    "difficulty": "Medium",
    "question": "Which approach most improves maintainability of DataWeave code?",
    "options": {
      "A": "Monolithic expressions",
      "B": "Modular functions and clear naming",
      "C": "Hardcoded logic",
      "D": "Minimal formatting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modularity and naming aid maintenance.",
      "incorrect": {
        "A": "Monoliths are hard to maintain.",
        "C": "Hardcoding limits flexibility.",
        "D": "Formatting aids readability."
      }
    }
  },
  {
    "id": "CH06-0277",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "testing focus",
    "difficulty": "Medium",
    "question": "What should be the main focus when testing DataWeave scripts?",
    "options": {
      "A": "Deployment speed",
      "B": "Correctness of transformation logic",
      "C": "Thread behavior",
      "D": "Memory allocation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Testing ensures correct transformation outcomes.",
      "incorrect": {
        "A": "Deployment is separate.",
        "C": "Threading is runtime-managed.",
        "D": "Memory is abstracted."
      }
    }
  },
  {
    "id": "CH06-0278",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "scalability",
    "difficulty": "Medium",
    "question": "Which DataWeave characteristic supports scalability?",
    "options": {
      "A": "Stateful execution",
      "B": "Immutability and statelessness",
      "C": "Global variables",
      "D": "Inline mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless immutable processing scales safely.",
      "incorrect": {
        "A": "State reduces scalability.",
        "C": "Globals cause contention.",
        "D": "Mutation breaks safety."
      }
    }
  },
  {
    "id": "CH06-0279",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "overall goal",
    "difficulty": "Easy",
    "question": "What is the overall goal of DataWeave in Mule applications?",
    "options": {
      "A": "Control threads",
      "B": "Transform data reliably and clearly",
      "C": "Manage persistence",
      "D": "Render UI components"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave focuses on reliable data transformation.",
      "incorrect": {
        "A": "Threading is runtime-managed.",
        "C": "Persistence is external.",
        "D": "UI rendering is unrelated."
      }
    }
  },
  {
    "id": "CH06-0280",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "developer mindset",
    "difficulty": "Easy",
    "question": "Which mindset best suits effective DataWeave development?",
    "options": {
      "A": "Imperative and stateful",
      "B": "Declarative and functional",
      "C": "Object-oriented",
      "D": "Procedural scripting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "A declarative functional mindset aligns with DataWeave.",
      "incorrect": {
        "A": "Stateful logic is avoided.",
        "C": "Object orientation is not primary.",
        "D": "Procedural style is discouraged."
      }
    }
  },
  {
    "id": "CH06-0281",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reverse",
    "difficulty": "Easy",
    "question": "Which function reverses the order of elements in an array?",
    "options": {
      "A": "invert()",
      "B": "reverse()",
      "C": "flip()",
      "D": "swap()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "reverse() returns a new array with elements in reverse order.",
      "incorrect": {
        "A": "Not a DataWeave function.",
        "C": "Invalid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0282",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "join",
    "difficulty": "Medium",
    "question": "What does the join function do when applied to an array of strings?",
    "options": {
      "A": "Splits strings",
      "B": "Concatenates elements using a delimiter",
      "C": "Removes duplicates",
      "D": "Sorts alphabetically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "join concatenates array elements into a single string.",
      "incorrect": {
        "A": "split performs the opposite.",
        "C": "Distinct logic is different.",
        "D": "Sorting is not performed."
      }
    }
  },
  {
    "id": "CH06-0283",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "join delimiter",
    "difficulty": "Easy",
    "question": "What happens if no delimiter is provided to join?",
    "options": {
      "A": "Null is returned",
      "B": "An empty string is used",
      "C": "Comma is used by default",
      "D": "Runtime error occurs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "join defaults to an empty string as delimiter.",
      "incorrect": {
        "A": "Null is not returned.",
        "C": "Comma is not implicit.",
        "D": "No error occurs."
      }
    }
  },
  {
    "id": "CH06-0284",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "any function",
    "difficulty": "Medium",
    "question": "What does the any function return?",
    "options": {
      "A": "Array of matches",
      "B": "True if at least one element matches condition",
      "C": "True only if all elements match",
      "D": "First matching element"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "any returns true if any element satisfies the predicate.",
      "incorrect": {
        "A": "filter returns arrays.",
        "C": "all checks all elements.",
        "D": "find returns elements."
      }
    }
  },
  {
    "id": "CH06-0285",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "all function",
    "difficulty": "Medium",
    "question": "When does the all function return true?",
    "options": {
      "A": "If array is empty",
      "B": "If every element satisfies the predicate",
      "C": "If at least one matches",
      "D": "Never returns true"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "all returns true only if all elements satisfy the condition.",
      "incorrect": {
        "A": "Empty array behavior differs.",
        "C": "That describes any.",
        "D": "It can return true."
      }
    }
  },
  {
    "id": "CH06-0286",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object size",
    "difficulty": "Easy",
    "question": "Which function returns the number of key-value pairs in an object?",
    "options": {
      "A": "length()",
      "B": "sizeOf()",
      "C": "count()",
      "D": "keys()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "sizeOf returns the size of objects, arrays, or strings.",
      "incorrect": {
        "A": "length is not valid.",
        "C": "count is unsupported.",
        "D": "keys returns an array."
      }
    }
  },
  {
    "id": "CH06-0287",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object to json",
    "difficulty": "Medium",
    "question": "Which output format serializes objects as JSON text?",
    "options": {
      "A": "application/java",
      "B": "application/xml",
      "C": "application/json",
      "D": "application/dw"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "application/json serializes data into JSON text.",
      "incorrect": {
        "A": "Produces Java objects.",
        "B": "Produces XML.",
        "D": "Internal representation."
      }
    }
  },
  {
    "id": "CH06-0288",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "key removal",
    "difficulty": "Medium",
    "question": "How can multiple keys be removed from an object?",
    "options": {
      "A": "Using -- with a list of keys",
      "B": "Using removeAll()",
      "C": "Using filter()",
      "D": "Using drop()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "The -- operator can remove multiple keys.",
      "incorrect": {
        "B": "Not supported.",
        "C": "filter applies to arrays.",
        "D": "drop applies to arrays."
      }
    }
  },
  {
    "id": "CH06-0289",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "substring",
    "difficulty": "Medium",
    "question": "Which function extracts a portion of a string?",
    "options": {
      "A": "slice()",
      "B": "substring()",
      "C": "cut()",
      "D": "extract()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "substring extracts part of a string by index.",
      "incorrect": {
        "A": "slice is for arrays.",
        "C": "Not supported.",
        "D": "Invalid function."
      }
    }
  },
  {
    "id": "CH06-0290",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "startsWith",
    "difficulty": "Easy",
    "question": "Which function checks if a string starts with a given value?",
    "options": {
      "A": "prefix()",
      "B": "startsWith()",
      "C": "begins()",
      "D": "hasPrefix()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "startsWith checks the beginning of a string.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Invalid function.",
        "D": "Not valid."
      }
    }
  },
  {
    "id": "CH06-0291",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "endsWith",
    "difficulty": "Easy",
    "question": "Which function checks if a string ends with a given value?",
    "options": {
      "A": "endsWith()",
      "B": "suffix()",
      "C": "tail()",
      "D": "finish()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "endsWith verifies the string ending.",
      "incorrect": {
        "B": "Not supported.",
        "C": "Invalid.",
        "D": "Not valid."
      }
    }
  },
  {
    "id": "CH06-0292",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "power",
    "difficulty": "Medium",
    "question": "How is exponentiation expressed in DataWeave?",
    "options": {
      "A": "^",
      "B": "**",
      "C": "pow()",
      "D": "exp()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "** performs exponentiation.",
      "incorrect": {
        "A": "Not used for power.",
        "C": "Function not required.",
        "D": "Invalid usage."
      }
    }
  },
  {
    "id": "CH06-0293",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "min max",
    "difficulty": "Easy",
    "question": "Which function returns the smallest value from an array of numbers?",
    "options": {
      "A": "least()",
      "B": "min()",
      "C": "smallest()",
      "D": "low()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "min returns the smallest numeric value.",
      "incorrect": {
        "A": "Not supported.",
        "C": "Invalid function.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0294",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "today",
    "difficulty": "Easy",
    "question": "Which function returns the current date without time?",
    "options": {
      "A": "now()",
      "B": "today()",
      "C": "currentDate()",
      "D": "date()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "today returns the current Date.",
      "incorrect": {
        "A": "Includes time.",
        "C": "Not supported.",
        "D": "Invalid."
      }
    }
  },
  {
    "id": "CH06-0295",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "date comparison",
    "difficulty": "Medium",
    "question": "How are Date values compared in DataWeave?",
    "options": {
      "A": "Lexicographically",
      "B": "Chronologically",
      "C": "As strings",
      "D": "Only equality allowed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dates are compared chronologically.",
      "incorrect": {
        "A": "Not string-based.",
        "C": "Not treated as strings.",
        "D": "Relational comparisons are allowed."
      }
    }
  },
  {
    "id": "CH06-0296",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "match default",
    "difficulty": "Medium",
    "question": "How is a default case defined in a match expression?",
    "options": {
      "A": "else",
      "B": "default",
      "C": "_",
      "D": "*"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "The underscore (_) defines the default case.",
      "incorrect": {
        "A": "Not used in match.",
        "B": "Invalid keyword.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0297",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "guard conditions",
    "difficulty": "Hard",
    "question": "What is the purpose of guards in match expressions?",
    "options": {
      "A": "Improve performance",
      "B": "Add additional conditional logic",
      "C": "Define return type",
      "D": "Handle errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Guards add extra conditional checks to patterns.",
      "incorrect": {
        "A": "Performance is secondary.",
        "C": "Types are unrelated.",
        "D": "Error handling is separate."
      }
    }
  },
  {
    "id": "CH06-0298",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "recursive use",
    "difficulty": "Hard",
    "question": "What is a necessary condition for safe recursion?",
    "options": {
      "A": "Multiple parameters",
      "B": "A termination condition",
      "C": "Lazy evaluation",
      "D": "Mutable state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Termination prevents infinite recursion.",
      "incorrect": {
        "A": "Parameter count is irrelevant.",
        "C": "Lazy evaluation does not guarantee safety.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0299",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "partial application",
    "difficulty": "Hard",
    "question": "What does partial application mean in functional programming?",
    "options": {
      "A": "Applying all arguments at once",
      "B": "Fixing some arguments to create a new function",
      "C": "Calling a function recursively",
      "D": "Inlining function logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Partial application creates new functions with preset arguments.",
      "incorrect": {
        "A": "That is full application.",
        "C": "Recursion is different.",
        "D": "Inlining is unrelated."
      }
    }
  },
  {
    "id": "CH06-0300",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "avoid nesting",
    "difficulty": "Medium",
    "question": "Why should excessive nesting be avoided?",
    "options": {
      "A": "It breaks compilation",
      "B": "It reduces readability and maintainability",
      "C": "It disables lazy evaluation",
      "D": "It causes memory leaks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting makes code harder to understand and maintain.",
      "incorrect": {
        "A": "Compilation still works.",
        "C": "Lazy evaluation still applies.",
        "D": "Memory leaks are not typical."
      }
    }
  },
  {
    "id": "CH06-0301",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "function reuse",
    "difficulty": "Medium",
    "question": "How does function reuse affect performance?",
    "options": {
      "A": "Always slows execution",
      "B": "Improves clarity and may reduce duplication",
      "C": "Forces eager evaluation",
      "D": "Prevents optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable functions reduce duplication and improve clarity.",
      "incorrect": {
        "A": "Not necessarily slower.",
        "C": "Evaluation strategy is unchanged.",
        "D": "Optimization is not prevented."
      }
    }
  },
  {
    "id": "CH06-0302",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "flow variables",
    "difficulty": "Medium",
    "question": "What is the scope of vars in a Mule flow?",
    "options": {
      "A": "Global across application",
      "B": "Limited to the current flow execution",
      "C": "Persisted across restarts",
      "D": "Shared across threads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "vars are scoped to a single flow execution.",
      "incorrect": {
        "A": "They are not global.",
        "C": "They are not persisted.",
        "D": "They are not shared."
      }
    }
  },
  {
    "id": "CH06-0303",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "attributes immutability",
    "difficulty": "Medium",
    "question": "Why are attributes immutable in DataWeave?",
    "options": {
      "A": "To reduce memory usage",
      "B": "To ensure safe concurrent processing",
      "C": "To simplify syntax",
      "D": "To allow mutation later"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability ensures thread safety.",
      "incorrect": {
        "A": "Memory usage is secondary.",
        "C": "Syntax is unaffected.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0304",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "common pitfall",
    "difficulty": "Medium",
    "question": "Which is a common pitfall when working with arrays?",
    "options": {
      "A": "Using map",
      "B": "Assuming non-null input",
      "C": "Using filter",
      "D": "Using reduce"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Assuming arrays are never null often causes errors.",
      "incorrect": {
        "A": "map is safe with valid input.",
        "C": "filter is common.",
        "D": "reduce is safe with initial value."
      }
    }
  },
  {
    "id": "CH06-0305",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "preview mismatch",
    "difficulty": "Medium",
    "question": "Why might preview output differ from runtime output?",
    "options": {
      "A": "Different DataWeave versions",
      "B": "Different input or context values",
      "C": "Preview disables functions",
      "D": "Preview ignores attributes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Differences in input or context affect results.",
      "incorrect": {
        "A": "Same engine is used.",
        "C": "Functions are executed.",
        "D": "Attributes are available."
      }
    }
  },
  {
    "id": "CH06-0306",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "naming conventions",
    "difficulty": "Easy",
    "question": "Why are consistent naming conventions important?",
    "options": {
      "A": "They improve execution speed",
      "B": "They enhance readability and maintenance",
      "C": "They reduce memory usage",
      "D": "They enforce typing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent names make code easier to understand.",
      "incorrect": {
        "A": "Speed is unaffected.",
        "C": "Memory is unaffected.",
        "D": "Typing is separate."
      }
    }
  },
  {
    "id": "CH06-0307",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "comments usage",
    "difficulty": "Easy",
    "question": "When should comments be used in DataWeave scripts?",
    "options": {
      "A": "To replace clear code",
      "B": "To explain complex logic",
      "C": "To disable execution",
      "D": "To improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Comments help explain non-obvious logic.",
      "incorrect": {
        "A": "Clear code is preferred.",
        "C": "Comments do not disable code.",
        "D": "Performance is unaffected."
      }
    }
  },
  {
    "id": "CH06-0308",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "data philosophy",
    "difficulty": "Medium",
    "question": "Which philosophy best describes DataWeave?",
    "options": {
      "A": "Imperative and mutable",
      "B": "Declarative and functional",
      "C": "Procedural",
      "D": "Object-oriented"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave is declarative and functional.",
      "incorrect": {
        "A": "Mutation is avoided.",
        "C": "Procedural style is discouraged.",
        "D": "Object orientation is not primary."
      }
    }
  },
  {
    "id": "CH06-0309",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "key advantage",
    "difficulty": "Easy",
    "question": "Which advantage makes DataWeave suitable for integrations?",
    "options": {
      "A": "Stateful processing",
      "B": "Clear data transformation semantics",
      "C": "Manual memory control",
      "D": "Thread-level APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear semantics simplify integration transformations.",
      "incorrect": {
        "A": "State is immutable.",
        "C": "Memory is abstracted.",
        "D": "Threads are runtime-managed."
      }
    }
  },
  {
    "id": "CH06-0310",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "developer focus",
    "difficulty": "Easy",
    "question": "What should developers primarily focus on when writing DataWeave?",
    "options": {
      "A": "Low-level optimization",
      "B": "Correctness and clarity of transformations",
      "C": "Thread management",
      "D": "Memory allocation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct and clear transformations are the main goal.",
      "incorrect": {
        "A": "Optimization is secondary.",
        "C": "Threads are managed by runtime.",
        "D": "Memory is abstracted."
      }
    }
  },
  {
    "id": "CH06-0311",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "learning strategy",
    "difficulty": "Medium",
    "question": "What is an effective strategy for mastering DataWeave?",
    "options": {
      "A": "Memorizing syntax only",
      "B": "Practicing transformations with real data",
      "C": "Avoiding functional concepts",
      "D": "Ignoring edge cases"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hands-on practice builds real understanding.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "Functional concepts are core.",
        "D": "Edge cases are important."
      }
    }
  },
  {
    "id": "CH06-0312",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "safety guarantee",
    "difficulty": "Medium",
    "question": "Which guarantee does DataWeave provide by design?",
    "options": {
      "A": "Mutable shared state",
      "B": "Side-effect free transformations",
      "C": "Manual memory management",
      "D": "Asynchronous execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transformations avoid side effects by design.",
      "incorrect": {
        "A": "State is immutable.",
        "C": "Memory is managed by runtime.",
        "D": "Execution model is separate."
      }
    }
  },
  {
    "id": "CH06-0313",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "maintainable code",
    "difficulty": "Medium",
    "question": "Which factor most contributes to long-term maintainability?",
    "options": {
      "A": "Short scripts",
      "B": "Readable structure and reuse",
      "C": "Hardcoded constants",
      "D": "Minimal whitespace"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readable, reusable code lasts longer.",
      "incorrect": {
        "A": "Length alone is not decisive.",
        "C": "Hardcoding limits change.",
        "D": "Whitespace alone is insufficient."
      }
    }
  },
  {
    "id": "CH06-0314",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "error reduction",
    "difficulty": "Medium",
    "question": "Which practice reduces DataWeave runtime errors most effectively?",
    "options": {
      "A": "Ignoring null checks",
      "B": "Defensive null handling",
      "C": "Inlining expressions",
      "D": "Avoiding functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Handling nulls defensively avoids common failures.",
      "incorrect": {
        "A": "Ignoring nulls causes errors.",
        "C": "Inlining reduces clarity.",
        "D": "Functions improve structure."
      }
    }
  },
  {
    "id": "CH06-0315",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "scalable mindset",
    "difficulty": "Easy",
    "question": "Which mindset supports scalable DataWeave solutions?",
    "options": {
      "A": "Stateful logic",
      "B": "Stateless functional design",
      "C": "Imperative mutation",
      "D": "Global variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless functional design scales safely.",
      "incorrect": {
        "A": "State limits scalability.",
        "C": "Mutation breaks safety.",
        "D": "Globals cause contention."
      }
    }
  },
  {
    "id": "CH06-0316",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "integration role",
    "difficulty": "Easy",
    "question": "What role does DataWeave play in Mule integrations?",
    "options": {
      "A": "Protocol handling",
      "B": "Data transformation engine",
      "C": "Thread scheduling",
      "D": "Persistence management"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave is responsible for transforming data.",
      "incorrect": {
        "A": "Protocols are handled by connectors.",
        "C": "Threads are runtime-managed.",
        "D": "Persistence is external."
      }
    }
  },
  {
    "id": "CH06-0317",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "final takeaway",
    "difficulty": "Easy",
    "question": "What is the most important takeaway for using DataWeave effectively?",
    "options": {
      "A": "Write shortest possible scripts",
      "B": "Think in terms of data transformation",
      "C": "Avoid functions",
      "D": "Focus on syntax tricks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Thinking in transformations aligns with DataWeave's strengths.",
      "incorrect": {
        "A": "Shortness is secondary.",
        "C": "Functions are essential.",
        "D": "Syntax tricks are not primary."
      }
    }
  },
  {
    "id": "CH06-0318",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "quality indicator",
    "difficulty": "Easy",
    "question": "Which indicator suggests high-quality DataWeave code?",
    "options": {
      "A": "Hardcoded values",
      "B": "Clear logic and predictable output",
      "C": "Minimal comments",
      "D": "Deep nesting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clarity and predictability indicate quality.",
      "incorrect": {
        "A": "Hardcoding reduces quality.",
        "C": "Comments help clarity.",
        "D": "Deep nesting reduces readability."
      }
    }
  },
  {
    "id": "CH06-0319",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "robust transformations",
    "difficulty": "Medium",
    "question": "What makes a transformation robust?",
    "options": {
      "A": "Assuming valid input",
      "B": "Handling edge cases and nulls",
      "C": "Inlining logic",
      "D": "Avoiding tests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Robust code handles edge cases safely.",
      "incorrect": {
        "A": "Assumptions cause failures.",
        "C": "Inlining reduces clarity.",
        "D": "Tests improve robustness."
      }
    }
  },
  {
    "id": "CH06-0320",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "final principle",
    "difficulty": "Easy",
    "question": "Which principle best summarizes DataWeave usage?",
    "options": {
      "A": "Mutate data carefully",
      "B": "Declare what output should look like",
      "C": "Control execution flow",
      "D": "Optimize prematurely"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave focuses on declaring the desired output.",
      "incorrect": {
        "A": "Mutation is avoided.",
        "C": "Flow control is minimal.",
        "D": "Premature optimization is discouraged."
      }
    }
  },
  {
    "id": "CH06-0321",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "indexOf",
    "difficulty": "Medium",
    "question": "What does indexOf return when a value is not found in an array?",
    "options": {
      "A": "null",
      "B": "-1",
      "C": "0",
      "D": "An error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "indexOf returns -1 when the searched value does not exist in the array.",
      "incorrect": {
        "A": "null is not returned by indexOf.",
        "C": "0 indicates the first position.",
        "D": "No error is thrown."
      }
    }
  },
  {
    "id": "CH06-0322",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "lastIndexOf",
    "difficulty": "Medium",
    "question": "What is the purpose of lastIndexOf on an array?",
    "options": {
      "A": "Returns the first index of a value",
      "B": "Returns the last matching index",
      "C": "Returns all matching indices",
      "D": "Returns a Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "lastIndexOf returns the index of the last occurrence of a value.",
      "incorrect": {
        "A": "indexOf returns the first occurrence.",
        "C": "An array is not returned.",
        "D": "The return type is numeric."
      }
    }
  },
  {
    "id": "CH06-0323",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "every empty",
    "difficulty": "Hard",
    "question": "What is the result of applying all to an empty array?",
    "options": {
      "A": "false",
      "B": "null",
      "C": "true",
      "D": "Runtime error"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "all returns true for an empty array because no element violates the predicate.",
      "incorrect": {
        "A": "False would imply a failing element.",
        "B": "Null is not returned.",
        "D": "No error is thrown."
      }
    }
  },
  {
    "id": "CH06-0324",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "any empty",
    "difficulty": "Hard",
    "question": "What does any return when applied to an empty array?",
    "options": {
      "A": "true",
      "B": "false",
      "C": "null",
      "D": "Error"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "any returns false because no element satisfies the predicate.",
      "incorrect": {
        "A": "There is no matching element.",
        "C": "Null is not returned.",
        "D": "No runtime error occurs."
      }
    }
  },
  {
    "id": "CH06-0325",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object equality",
    "difficulty": "Medium",
    "question": "How does DataWeave evaluate equality between two objects?",
    "options": {
      "A": "By reference",
      "B": "By key order only",
      "C": "By deep structural comparison",
      "D": "By memory address"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Objects are compared structurally by keys and values.",
      "incorrect": {
        "A": "Reference equality is not used.",
        "B": "Key order does not matter.",
        "D": "Memory address is irrelevant."
      }
    }
  },
  {
    "id": "CH06-0326",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "key order",
    "difficulty": "Medium",
    "question": "Does key order affect object equality in DataWeave?",
    "options": {
      "A": "Yes, always",
      "B": "Only for JSON output",
      "C": "No, order is ignored",
      "D": "Only when comparing strings"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Object equality ignores key order.",
      "incorrect": {
        "A": "Order does not affect equality.",
        "B": "Output format is irrelevant.",
        "D": "String comparison is unrelated."
      }
    }
  },
  {
    "id": "CH06-0327",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "replace regex",
    "difficulty": "Medium",
    "question": "What capability does replace provide when used with regular expressions?",
    "options": {
      "A": "Only literal replacement",
      "B": "Pattern-based substitution",
      "C": "String splitting",
      "D": "Character encoding"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "replace supports regex-based pattern substitution.",
      "incorrect": {
        "A": "It is not limited to literals.",
        "C": "Splitting uses split.",
        "D": "Encoding is unrelated."
      }
    }
  },
  {
    "id": "CH06-0328",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "matches",
    "difficulty": "Medium",
    "question": "What does the matches operator return when a regex matches a string?",
    "options": {
      "A": "Matched substring",
      "B": "Boolean value",
      "C": "Array of matches",
      "D": "Index of match"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "matches returns true or false based on pattern matching.",
      "incorrect": {
        "A": "Substring is not returned.",
        "C": "An array is not returned.",
        "D": "Index is not returned."
      }
    }
  },
  {
    "id": "CH06-0329",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "division",
    "difficulty": "Medium",
    "question": "What is the result type of dividing two integers in DataWeave?",
    "options": {
      "A": "Integer",
      "B": "Decimal",
      "C": "String",
      "D": "Boolean"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Division produces a decimal result.",
      "incorrect": {
        "A": "Integer division is not enforced.",
        "C": "Strings are not produced.",
        "D": "Booleans are not involved."
      }
    }
  },
  {
    "id": "CH06-0330",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "modulo",
    "difficulty": "Easy",
    "question": "Which operator calculates the remainder of a division?",
    "options": {
      "A": "/",
      "B": "%",
      "C": "**",
      "D": "//"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The % operator returns the remainder.",
      "incorrect": {
        "A": "Division returns a quotient.",
        "C": "Exponentiation operator.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0331",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "date arithmetic",
    "difficulty": "Hard",
    "question": "How is date arithmetic such as adding days performed?",
    "options": {
      "A": "Using + with numbers directly",
      "B": "Using Period values",
      "C": "Using string concatenation",
      "D": "Using math functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Date arithmetic uses Period values like |P1D|.",
      "incorrect": {
        "A": "Direct numeric addition is invalid.",
        "C": "Strings cannot modify dates.",
        "D": "Math functions are not date-aware."
      }
    }
  },
  {
    "id": "CH06-0332",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "timezone default",
    "difficulty": "Medium",
    "question": "Which timezone is used if none is specified for DateTime?",
    "options": {
      "A": "UTC",
      "B": "System default timezone",
      "C": "GMT",
      "D": "IST"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The system default timezone is used.",
      "incorrect": {
        "A": "UTC is not forced by default.",
        "C": "GMT is not assumed.",
        "D": "Not region-specific."
      }
    }
  },
  {
    "id": "CH06-0333",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "if expression",
    "difficulty": "Easy",
    "question": "What does an if expression return in DataWeave?",
    "options": {
      "A": "Always Boolean",
      "B": "Void",
      "C": "A value from either branch",
      "D": "Only true or false"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "if expressions return the evaluated branch value.",
      "incorrect": {
        "A": "Return type is not restricted to Boolean.",
        "B": "Void is not returned.",
        "D": "Non-Boolean values can be returned."
      }
    }
  },
  {
    "id": "CH06-0334",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "short-circuit",
    "difficulty": "Medium",
    "question": "Which logical operator supports short-circuit evaluation?",
    "options": {
      "A": "and",
      "B": "or",
      "C": "Both and and or",
      "D": "not"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Both and and or short-circuit evaluation.",
      "incorrect": {
        "A": "Incomplete answer.",
        "B": "Incomplete answer.",
        "D": "Unary operator."
      }
    }
  },
  {
    "id": "CH06-0335",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "default arguments",
    "difficulty": "Hard",
    "question": "How are default values for function parameters handled?",
    "options": {
      "A": "Not supported",
      "B": "Using ?? inside function body",
      "C": "Declared in function signature",
      "D": "Using global variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defaults are handled using ?? within the function body.",
      "incorrect": {
        "A": "Defaults can be implemented.",
        "C": "Signatures do not support defaults.",
        "D": "Globals are discouraged."
      }
    }
  },
  {
    "id": "CH06-0336",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "higher-order",
    "difficulty": "Hard",
    "question": "What qualifies a function as higher-order?",
    "options": {
      "A": "Returns a Boolean",
      "B": "Accepts or returns another function",
      "C": "Uses recursion",
      "D": "Uses reduce"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Higher-order functions work with other functions.",
      "incorrect": {
        "A": "Return type does not define higher-order.",
        "C": "Recursion is unrelated.",
        "D": "reduce usage is not required."
      }
    }
  },
  {
    "id": "CH06-0337",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "constant expressions",
    "difficulty": "Medium",
    "question": "Why should constant expressions be extracted into let bindings?",
    "options": {
      "A": "To force eager evaluation",
      "B": "To avoid repeated computation",
      "C": "To change scope",
      "D": "To enable mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "let avoids recalculating the same expression.",
      "incorrect": {
        "A": "Evaluation strategy remains lazy.",
        "C": "Scope change is secondary.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0338",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "memory usage",
    "difficulty": "Medium",
    "question": "Which approach helps reduce memory usage during transformations?",
    "options": {
      "A": "Creating large intermediate arrays",
      "B": "Filtering early",
      "C": "Deep nesting",
      "D": "Duplicating objects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering early reduces intermediate data size.",
      "incorrect": {
        "A": "Large intermediates increase memory usage.",
        "C": "Nesting increases complexity.",
        "D": "Duplication wastes memory."
      }
    }
  },
  {
    "id": "CH06-0339",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "payload typing",
    "difficulty": "Medium",
    "question": "How is the payload type determined in DataWeave?",
    "options": {
      "A": "Always String",
      "B": "From input metadata",
      "C": "By output directive",
      "D": "Manually by developer"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Payload type is inferred from input metadata.",
      "incorrect": {
        "A": "Payload is not always String.",
        "C": "Output does not define input type.",
        "D": "Manual typing is not required."
      }
    }
  },
  {
    "id": "CH06-0340",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "attribute absence",
    "difficulty": "Hard",
    "question": "What happens when accessing a non-existent attribute without safe navigation?",
    "options": {
      "A": "null is returned",
      "B": "Empty object is returned",
      "C": "Runtime error occurs",
      "D": "Default value is applied"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Direct access to missing attributes causes a runtime error.",
      "incorrect": {
        "A": "Null is not returned automatically.",
        "B": "Empty objects are not assumed.",
        "D": "Defaults must be explicitly defined."
      }
    }
  },
  {
    "id": "CH06-0341",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "error messages",
    "difficulty": "Medium",
    "question": "What information do DataWeave error messages typically provide?",
    "options": {
      "A": "Only error code",
      "B": "Failing expression location",
      "C": "Stack trace only",
      "D": "No details"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error messages usually indicate where evaluation failed.",
      "incorrect": {
        "A": "More detail is provided.",
        "C": "Not limited to stack trace.",
        "D": "Details are included."
      }
    }
  },
  {
    "id": "CH06-0342",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "preview limits",
    "difficulty": "Medium",
    "question": "What is a limitation of the DataWeave preview?",
    "options": {
      "A": "Cannot execute functions",
      "B": "Uses static sample context",
      "C": "Does not support JSON",
      "D": "Cannot show output"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Preview depends on provided sample data and context.",
      "incorrect": {
        "A": "Functions are executed.",
        "C": "JSON is supported.",
        "D": "Output is shown."
      }
    }
  },
  {
    "id": "CH06-0343",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "explicit typing",
    "difficulty": "Medium",
    "question": "When is explicit type coercion recommended?",
    "options": {
      "A": "Always",
      "B": "When implicit coercion is ambiguous",
      "C": "Never",
      "D": "Only for strings"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit coercion avoids ambiguity and errors.",
      "incorrect": {
        "A": "Not always required.",
        "C": "Sometimes necessary.",
        "D": "Applies to many types."
      }
    }
  },
  {
    "id": "CH06-0344",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "function size",
    "difficulty": "Medium",
    "question": "What is a recommended characteristic of DataWeave functions?",
    "options": {
      "A": "Very large and complex",
      "B": "Small and focused",
      "C": "Deeply nested",
      "D": "Stateful"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Small focused functions improve clarity and reuse.",
      "incorrect": {
        "A": "Large functions are harder to maintain.",
        "C": "Deep nesting reduces readability.",
        "D": "State is immutable."
      }
    }
  },
  {
    "id": "CH06-0345",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "referential transparency",
    "difficulty": "Hard",
    "question": "What does referential transparency imply?",
    "options": {
      "A": "Same input always yields same output",
      "B": "Functions modify global state",
      "C": "Evaluation order matters",
      "D": "Side effects are required"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Referential transparency ensures consistent output for given input.",
      "incorrect": {
        "B": "Global state is avoided.",
        "C": "Order does not change result.",
        "D": "Side effects are avoided."
      }
    }
  },
  {
    "id": "CH06-0346",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "purity",
    "difficulty": "Medium",
    "question": "Why are pure functions preferred in DataWeave?",
    "options": {
      "A": "They are faster",
      "B": "They are easier to reason about",
      "C": "They use less memory",
      "D": "They allow mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Pure functions are predictable and easier to test.",
      "incorrect": {
        "A": "Speed is not guaranteed.",
        "C": "Memory usage varies.",
        "D": "Mutation is avoided."
      }
    }
  },
  {
    "id": "CH06-0347",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "deterministic output",
    "difficulty": "Medium",
    "question": "What ensures deterministic output in DataWeave?",
    "options": {
      "A": "Global variables",
      "B": "Immutable data and pure functions",
      "C": "Thread-local state",
      "D": "Randomized execution"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability and purity ensure deterministic behavior.",
      "incorrect": {
        "A": "Globals break determinism.",
        "C": "State introduces variability.",
        "D": "Randomization breaks determinism."
      }
    }
  },
  {
    "id": "CH06-0348",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "transformation safety",
    "difficulty": "Medium",
    "question": "Which property makes DataWeave transformations safe for concurrency?",
    "options": {
      "A": "Lazy evaluation",
      "B": "Immutability",
      "C": "Dynamic typing",
      "D": "Recursion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability prevents shared-state issues.",
      "incorrect": {
        "A": "Lazy evaluation is not sufficient.",
        "C": "Typing does not ensure safety.",
        "D": "Recursion is unrelated."
      }
    }
  },
  {
    "id": "CH06-0349",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "integration value",
    "difficulty": "Easy",
    "question": "Why is DataWeave central to Mule applications?",
    "options": {
      "A": "It manages connectors",
      "B": "It handles data transformation consistently",
      "C": "It controls message routing",
      "D": "It persists data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave provides consistent transformation logic.",
      "incorrect": {
        "A": "Connectors are separate.",
        "C": "Routing is flow-based.",
        "D": "Persistence is external."
      }
    }
  },
  {
    "id": "CH06-0350",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "developer approach",
    "difficulty": "Easy",
    "question": "What approach leads to effective DataWeave solutions?",
    "options": {
      "A": "Imperative step-by-step logic",
      "B": "Declarative description of desired output",
      "C": "Heavy use of global variables",
      "D": "Manual state tracking"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Declarative thinking aligns with DataWeave design.",
      "incorrect": {
        "A": "Imperative style is discouraged.",
        "C": "Globals are unsafe.",
        "D": "State tracking is unnecessary."
      }
    }
  },
  {
    "id": "CH06-0351",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "error avoidance",
    "difficulty": "Medium",
    "question": "Which practice best avoids unexpected runtime errors?",
    "options": {
      "A": "Assuming correct input",
      "B": "Explicit null checks and safe navigation",
      "C": "Inlining all expressions",
      "D": "Avoiding functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit null handling prevents common failures.",
      "incorrect": {
        "A": "Assumptions cause errors.",
        "C": "Inlining reduces clarity.",
        "D": "Functions improve structure."
      }
    }
  },
  {
    "id": "CH06-0352",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "maintainability",
    "difficulty": "Easy",
    "question": "What most improves long-term maintainability of DataWeave code?",
    "options": {
      "A": "Complex expressions",
      "B": "Clear structure and reuse",
      "C": "Minimal whitespace",
      "D": "Hardcoded logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clarity and reuse make code maintainable.",
      "incorrect": {
        "A": "Complexity hinders maintenance.",
        "C": "Whitespace alone is insufficient.",
        "D": "Hardcoding reduces flexibility."
      }
    }
  },
  {
    "id": "CH06-0353",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "scalable design",
    "difficulty": "Easy",
    "question": "Which design choice supports scalable integrations?",
    "options": {
      "A": "Stateful transformations",
      "B": "Stateless functional transformations",
      "C": "Global variables",
      "D": "Shared mutable data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless functional design scales safely.",
      "incorrect": {
        "A": "State reduces scalability.",
        "C": "Globals cause contention.",
        "D": "Mutable data breaks safety."
      }
    }
  },
  {
    "id": "CH06-0354",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "testing focus",
    "difficulty": "Easy",
    "question": "What should DataWeave tests primarily validate?",
    "options": {
      "A": "Thread behavior",
      "B": "Correct transformation output",
      "C": "Memory usage",
      "D": "Deployment speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tests validate correctness of transformations.",
      "incorrect": {
        "A": "Threading is runtime-managed.",
        "C": "Memory is abstracted.",
        "D": "Deployment is separate."
      }
    }
  },
  {
    "id": "CH06-0355",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "learning focus",
    "difficulty": "Easy",
    "question": "What accelerates learning DataWeave most effectively?",
    "options": {
      "A": "Memorizing syntax",
      "B": "Practicing real transformations",
      "C": "Avoiding complex cases",
      "D": "Ignoring functional concepts"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hands-on practice builds true understanding.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "Complex cases are important.",
        "D": "Functional concepts are essential."
      }
    }
  },
  {
    "id": "CH06-0356",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "core strength",
    "difficulty": "Easy",
    "question": "What is the core strength of DataWeave?",
    "options": {
      "A": "Thread management",
      "B": "Declarative data transformation",
      "C": "Persistence handling",
      "D": "UI rendering"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave excels at declarative transformations.",
      "incorrect": {
        "A": "Threads are runtime-managed.",
        "C": "Persistence is external.",
        "D": "UI rendering is unrelated."
      }
    }
  },
  {
    "id": "CH06-0357",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "best mindset",
    "difficulty": "Easy",
    "question": "Which mindset best suits DataWeave development?",
    "options": {
      "A": "Imperative",
      "B": "Declarative",
      "C": "Procedural",
      "D": "Stateful"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Declarative thinking aligns with DataWeave philosophy.",
      "incorrect": {
        "A": "Imperative style is discouraged.",
        "C": "Procedural style is not primary.",
        "D": "State is immutable."
      }
    }
  },
  {
    "id": "CH06-0358",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "code quality",
    "difficulty": "Easy",
    "question": "Which attribute indicates high-quality DataWeave code?",
    "options": {
      "A": "Complex expressions",
      "B": "Predictable and readable logic",
      "C": "Minimal comments",
      "D": "Heavy nesting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable readable logic indicates quality.",
      "incorrect": {
        "A": "Complexity reduces quality.",
        "C": "Comments help understanding.",
        "D": "Nesting reduces clarity."
      }
    }
  },
  {
    "id": "CH06-0359",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "robustness",
    "difficulty": "Easy",
    "question": "What makes a DataWeave transformation robust?",
    "options": {
      "A": "Ignoring edge cases",
      "B": "Explicit handling of nulls and types",
      "C": "Assuming perfect input",
      "D": "Inlining logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit handling prevents unexpected failures.",
      "incorrect": {
        "A": "Edge cases must be handled.",
        "C": "Assumptions are risky.",
        "D": "Inlining reduces clarity."
      }
    }
  },
  {
    "id": "CH06-0360",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "guiding principle",
    "difficulty": "Easy",
    "question": "Which principle best summarizes effective DataWeave usage?",
    "options": {
      "A": "Control execution flow",
      "B": "Describe the desired output clearly",
      "C": "Optimize prematurely",
      "D": "Track mutable state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave focuses on clearly describing the target output.",
      "incorrect": {
        "A": "Flow control is minimal.",
        "C": "Premature optimization is discouraged.",
        "D": "State mutation is avoided."
      }
    }
  },
  {
    "id": "CH06-0361",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "windowed processing",
    "difficulty": "Hard",
    "question": "What is the primary use of the window function when processing arrays?",
    "options": {
      "A": "Remove duplicates",
      "B": "Create sliding subarrays",
      "C": "Flatten nested arrays",
      "D": "Sort elements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "window creates overlapping or sliding subarrays for sequential analysis.",
      "incorrect": {
        "A": "Duplicate removal uses distinct functions.",
        "C": "Flattening is done with flatten.",
        "D": "Sorting uses sortBy."
      }
    }
  },
  {
    "id": "CH06-0362",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "zip length mismatch",
    "difficulty": "Medium",
    "question": "What happens when zipping arrays of unequal length?",
    "options": {
      "A": "An error is thrown",
      "B": "Shorter array is padded",
      "C": "Extra elements are ignored",
      "D": "Arrays are concatenated"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "zip pairs elements up to the shortest array length.",
      "incorrect": {
        "A": "No error occurs.",
        "B": "Padding does not occur.",
        "D": "Concatenation is different."
      }
    }
  },
  {
    "id": "CH06-0363",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reduce accumulator",
    "difficulty": "Hard",
    "question": "What role does the accumulator play in reduce?",
    "options": {
      "A": "Tracks index",
      "B": "Stores intermediate aggregation",
      "C": "Filters elements",
      "D": "Defines output type"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "The accumulator holds the running aggregation result.",
      "incorrect": {
        "A": "Index is separate.",
        "C": "Filtering is not aggregation.",
        "D": "Type inference is implicit."
      }
    }
  },
  {
    "id": "CH06-0364",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "reduce initial value",
    "difficulty": "Medium",
    "question": "Why is an initial value recommended for reduce?",
    "options": {
      "A": "Improves sorting",
      "B": "Avoids errors on empty arrays",
      "C": "Forces eager evaluation",
      "D": "Changes output format"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "An initial value prevents failures when reducing empty arrays.",
      "incorrect": {
        "A": "Sorting is unrelated.",
        "C": "Evaluation strategy is unchanged.",
        "D": "Format is unaffected."
      }
    }
  },
  {
    "id": "CH06-0365",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "deep merge",
    "difficulty": "Hard",
    "question": "How can nested objects be merged recursively?",
    "options": {
      "A": "Using ++ only",
      "B": "Using recursive functions",
      "C": "Using keys()",
      "D": "Using flatten()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep merges require recursion to traverse nested structures.",
      "incorrect": {
        "A": "++ performs shallow merge.",
        "C": "keys() only lists keys.",
        "D": "flatten applies to arrays."
      }
    }
  },
  {
    "id": "CH06-0366",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "object comprehension",
    "difficulty": "Medium",
    "question": "Which construct is used to build objects dynamically?",
    "options": {
      "A": "map",
      "B": "mapObject",
      "C": "reduce",
      "D": "filter"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "mapObject creates objects by transforming key-value pairs.",
      "incorrect": {
        "A": "map produces arrays.",
        "C": "reduce aggregates values.",
        "D": "filter selects elements."
      }
    }
  },
  {
    "id": "CH06-0367",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "dynamic keys",
    "difficulty": "Medium",
    "question": "How are dynamic keys defined in object literals?",
    "options": {
      "A": "Using quotes only",
      "B": "Using parentheses around expressions",
      "C": "Using brackets []",
      "D": "Using backticks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Parentheses allow expressions to compute object keys.",
      "incorrect": {
        "A": "Quotes define static keys.",
        "C": "Brackets are not used.",
        "D": "Backticks are invalid."
      }
    }
  },
  {
    "id": "CH06-0368",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "formatting",
    "difficulty": "Medium",
    "question": "Which approach is used to interpolate expressions into strings?",
    "options": {
      "A": "Concatenation only",
      "B": "String templates with $( )",
      "C": "Regex replace",
      "D": "as String coercion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "String templates allow expression interpolation using $( ).",
      "incorrect": {
        "A": "Concatenation is optional.",
        "C": "Regex is not interpolation.",
        "D": "Coercion does not interpolate."
      }
    }
  },
  {
    "id": "CH06-0369",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "encoding",
    "difficulty": "Hard",
    "question": "How is URL encoding applied to strings?",
    "options": {
      "A": "encodeUrl()",
      "B": "urlEncode()",
      "C": "as URL",
      "D": "encode()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "urlEncode converts strings to URL-safe encoding.",
      "incorrect": {
        "A": "Not a valid function.",
        "C": "Invalid coercion.",
        "D": "Too generic."
      }
    }
  },
  {
    "id": "CH06-0370",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "precision",
    "difficulty": "Medium",
    "question": "How can numeric precision be controlled?",
    "options": {
      "A": "Using round with scale",
      "B": "Using format only",
      "C": "Using as Integer",
      "D": "Using ceil"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "round with a scale controls decimal precision.",
      "incorrect": {
        "B": "Formatting does not change value.",
        "C": "Casting truncates.",
        "D": "ceil rounds up."
      }
    }
  },
  {
    "id": "CH06-0371",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "nan handling",
    "difficulty": "Hard",
    "question": "How does DataWeave represent invalid numeric operations?",
    "options": {
      "A": "null",
      "B": "NaN",
      "C": "0",
      "D": "Error only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Invalid numeric operations may result in NaN.",
      "incorrect": {
        "A": "null is not automatic.",
        "C": "Zero is not assumed.",
        "D": "Not always an error."
      }
    }
  },
  {
    "id": "CH06-0372",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "parsing",
    "difficulty": "Medium",
    "question": "How are date strings parsed into Date types?",
    "options": {
      "A": "Using parseDate()",
      "B": "Using as Date with format",
      "C": "Using toDate()",
      "D": "Automatic parsing always"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "as Date with a specified format parses strings correctly.",
      "incorrect": {
        "A": "Not a valid function.",
        "C": "Not supported.",
        "D": "Automatic parsing is not guaranteed."
      }
    }
  },
  {
    "id": "CH06-0373",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "period literal",
    "difficulty": "Hard",
    "question": "Which literal denotes a period of time?",
    "options": {
      "A": "#P1D",
      "B": "|P1D|",
      "C": "P1D",
      "D": "{P1D}"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Period literals are enclosed with vertical bars.",
      "incorrect": {
        "A": "Invalid syntax.",
        "C": "Missing delimiters.",
        "D": "Invalid structure."
      }
    }
  },
  {
    "id": "CH06-0374",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "when in objects",
    "difficulty": "Medium",
    "question": "What is the purpose of when in object fields?",
    "options": {
      "A": "Type coercion",
      "B": "Conditional field inclusion",
      "C": "Sorting keys",
      "D": "Error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "when conditionally includes object fields.",
      "incorrect": {
        "A": "Not type-related.",
        "C": "Sorting is unrelated.",
        "D": "Errors are not handled."
      }
    }
  },
  {
    "id": "CH06-0375",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "match ordering",
    "difficulty": "Hard",
    "question": "How are match cases evaluated?",
    "options": {
      "A": "Random order",
      "B": "From last to first",
      "C": "Top to bottom",
      "D": "By specificity only"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Cases are evaluated sequentially from top to bottom.",
      "incorrect": {
        "A": "Order is deterministic.",
        "B": "Not reversed.",
        "D": "Specificity does not reorder."
      }
    }
  },
  {
    "id": "CH06-0376",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "closures",
    "difficulty": "Hard",
    "question": "What does a closure capture in DataWeave?",
    "options": {
      "A": "Only parameters",
      "B": "Surrounding scope variables",
      "C": "Global state",
      "D": "Runtime context"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Closures capture variables from their lexical scope.",
      "incorrect": {
        "A": "More than parameters are captured.",
        "C": "Global state is discouraged.",
        "D": "Context is not captured."
      }
    }
  },
  {
    "id": "CH06-0377",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "currying",
    "difficulty": "Hard",
    "question": "What is currying in functional programming?",
    "options": {
      "A": "Executing functions in parallel",
      "B": "Transforming a function to accept arguments one at a time",
      "C": "Inlining function calls",
      "D": "Memoizing results"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Currying converts multi-argument functions into chained single-argument functions.",
      "incorrect": {
        "A": "Parallelism is unrelated.",
        "C": "Inlining is different.",
        "D": "Memoization is separate."
      }
    }
  },
  {
    "id": "CH06-0378",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "short-circuit benefit",
    "difficulty": "Medium",
    "question": "How does short-circuiting improve performance?",
    "options": {
      "A": "By caching results",
      "B": "By skipping unnecessary evaluations",
      "C": "By parallel execution",
      "D": "By type coercion"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Short-circuiting avoids evaluating expressions once outcome is known.",
      "incorrect": {
        "A": "Caching is different.",
        "C": "Parallelism is not implied.",
        "D": "Type coercion is unrelated."
      }
    }
  },
  {
    "id": "CH06-0379",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "streaming",
    "difficulty": "Hard",
    "question": "When is streaming most beneficial?",
    "options": {
      "A": "Small payloads",
      "B": "Large payloads processed incrementally",
      "C": "Static data",
      "D": "Simple arithmetic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Streaming reduces memory usage for large payloads.",
      "incorrect": {
        "A": "Benefits are minimal.",
        "C": "Static data gains little.",
        "D": "Arithmetic is not streamed."
      }
    }
  },
  {
    "id": "CH06-0380",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "headers access",
    "difficulty": "Easy",
    "question": "How are HTTP headers accessed in DataWeave?",
    "options": {
      "A": "payload.headers",
      "B": "attributes.headers",
      "C": "vars.headers",
      "D": "context.headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP headers are available under attributes.headers.",
      "incorrect": {
        "A": "Payload contains body.",
        "C": "vars are flow variables.",
        "D": "context is invalid."
      }
    }
  },
  {
    "id": "CH06-0381",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "uri params",
    "difficulty": "Medium",
    "question": "Where are URI parameters accessed?",
    "options": {
      "A": "attributes.uriParams",
      "B": "attributes.queryParams",
      "C": "vars.uri",
      "D": "payload.params"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "URI parameters are available via attributes.uriParams.",
      "incorrect": {
        "B": "Query params are different.",
        "C": "vars are flow-scoped.",
        "D": "Payload is body."
      }
    }
  },
  {
    "id": "CH06-0382",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "type mismatch",
    "difficulty": "Medium",
    "question": "What commonly causes type mismatch errors?",
    "options": {
      "A": "Explicit casting",
      "B": "Assuming input structure",
      "C": "Using let",
      "D": "Using functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Incorrect assumptions about input lead to type mismatches.",
      "incorrect": {
        "A": "Explicit casting clarifies types.",
        "C": "let improves clarity.",
        "D": "Functions are type-safe."
      }
    }
  },
  {
    "id": "CH06-0383",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "preview accuracy",
    "difficulty": "Medium",
    "question": "What ensures preview accuracy?",
    "options": {
      "A": "Using default samples",
      "B": "Providing realistic sample input and metadata",
      "C": "Ignoring attributes",
      "D": "Disabling functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accurate samples produce reliable preview results.",
      "incorrect": {
        "A": "Defaults may mislead.",
        "C": "Attributes affect output.",
        "D": "Functions are needed."
      }
    }
  },
  {
    "id": "CH06-0384",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "defensive coding",
    "difficulty": "Medium",
    "question": "What defines defensive DataWeave coding?",
    "options": {
      "A": "Assuming valid inputs",
      "B": "Handling nulls and unexpected shapes",
      "C": "Inlining logic",
      "D": "Avoiding tests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defensive coding anticipates and handles irregular inputs.",
      "incorrect": {
        "A": "Assumptions are risky.",
        "C": "Inlining reduces clarity.",
        "D": "Tests are important."
      }
    }
  },
  {
    "id": "CH06-0385",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "module usage",
    "difficulty": "Medium",
    "question": "Why use custom modules?",
    "options": {
      "A": "To increase file size",
      "B": "To reuse and organize logic",
      "C": "To force eager evaluation",
      "D": "To access globals"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Modules promote reuse and organization.",
      "incorrect": {
        "A": "Size is irrelevant.",
        "C": "Evaluation is unchanged.",
        "D": "Globals are discouraged."
      }
    }
  },
  {
    "id": "CH06-0386",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "idempotent transformations",
    "difficulty": "Hard",
    "question": "What characterizes an idempotent transformation?",
    "options": {
      "A": "Produces different outputs each run",
      "B": "Produces same output when reapplied",
      "C": "Requires mutable state",
      "D": "Depends on time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Idempotent transformations yield the same result on repeated application.",
      "incorrect": {
        "A": "Determinism is required.",
        "C": "State is immutable.",
        "D": "Time dependence breaks idempotence."
      }
    }
  },
  {
    "id": "CH06-0387",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "lazy pitfalls",
    "difficulty": "Hard",
    "question": "What is a potential pitfall of lazy evaluation?",
    "options": {
      "A": "Higher memory usage always",
      "B": "Errors surfacing later than expected",
      "C": "Forced eager execution",
      "D": "Loss of determinism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors may appear only when values are consumed.",
      "incorrect": {
        "A": "Memory usage may be lower.",
        "C": "Lazy does not force eager.",
        "D": "Determinism remains."
      }
    }
  },
  {
    "id": "CH06-0388",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "referential use",
    "difficulty": "Medium",
    "question": "Why is referential transparency valuable?",
    "options": {
      "A": "Improves UI rendering",
      "B": "Simplifies reasoning and testing",
      "C": "Enables mutation",
      "D": "Controls threads"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable behavior simplifies reasoning and tests.",
      "incorrect": {
        "A": "UI is unrelated.",
        "C": "Mutation is avoided.",
        "D": "Thread control is separate."
      }
    }
  },
  {
    "id": "CH06-0389",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "integration reliability",
    "difficulty": "Medium",
    "question": "What most contributes to reliable integrations?",
    "options": {
      "A": "Complex expressions",
      "B": "Clear transformations with validation",
      "C": "Hardcoded assumptions",
      "D": "Minimal testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clarity and validation ensure reliability.",
      "incorrect": {
        "A": "Complexity adds risk.",
        "C": "Assumptions fail.",
        "D": "Testing is essential."
      }
    }
  },
  {
    "id": "CH06-0390",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "data safety",
    "difficulty": "Easy",
    "question": "What ensures data safety during transformations?",
    "options": {
      "A": "Mutable variables",
      "B": "Immutability",
      "C": "Global state",
      "D": "Side effects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability prevents unintended changes.",
      "incorrect": {
        "A": "Mutation is unsafe.",
        "C": "Globals cause issues.",
        "D": "Side effects are avoided."
      }
    }
  },
  {
    "id": "CH06-0391",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "primary role",
    "difficulty": "Easy",
    "question": "What is DataWeaveâ€™s primary role in Mule?",
    "options": {
      "A": "Routing messages",
      "B": "Transforming data",
      "C": "Managing threads",
      "D": "Persisting data"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave focuses on data transformation.",
      "incorrect": {
        "A": "Routing is flow logic.",
        "C": "Threads are runtime-managed.",
        "D": "Persistence is external."
      }
    }
  },
  {
    "id": "CH06-0392",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "developer priority",
    "difficulty": "Easy",
    "question": "What should be the developerâ€™s top priority?",
    "options": {
      "A": "Premature optimization",
      "B": "Correctness and clarity",
      "C": "Complex syntax",
      "D": "Global reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct, clear transformations are essential.",
      "incorrect": {
        "A": "Optimization comes later.",
        "C": "Complexity is discouraged.",
        "D": "Globals are discouraged."
      }
    }
  },
  {
    "id": "CH06-0393",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "scalability factor",
    "difficulty": "Easy",
    "question": "Which factor most supports scalability?",
    "options": {
      "A": "Stateful logic",
      "B": "Stateless transformations",
      "C": "Hardcoded paths",
      "D": "Shared mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless transformations scale safely.",
      "incorrect": {
        "A": "State hinders scaling.",
        "C": "Hardcoding limits reuse.",
        "D": "Mutation breaks safety."
      }
    }
  },
  {
    "id": "CH06-0394",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "test strategy",
    "difficulty": "Easy",
    "question": "What should DataWeave tests focus on?",
    "options": {
      "A": "Thread timing",
      "B": "Input-to-output correctness",
      "C": "Memory allocation",
      "D": "Deployment speed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tests verify correct transformation results.",
      "incorrect": {
        "A": "Threads are runtime-managed.",
        "C": "Memory is abstracted.",
        "D": "Deployment is separate."
      }
    }
  },
  {
    "id": "CH06-0395",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "learning method",
    "difficulty": "Easy",
    "question": "What is the most effective learning method?",
    "options": {
      "A": "Reading syntax only",
      "B": "Practicing real scenarios",
      "C": "Avoiding edge cases",
      "D": "Ignoring types"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Practice with real data builds understanding.",
      "incorrect": {
        "A": "Syntax alone is insufficient.",
        "C": "Edge cases matter.",
        "D": "Types aid correctness."
      }
    }
  },
  {
    "id": "CH06-0396",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "core principle",
    "difficulty": "Easy",
    "question": "Which principle best guides DataWeave usage?",
    "options": {
      "A": "Control execution order",
      "B": "Describe desired output",
      "C": "Mutate data carefully",
      "D": "Optimize early"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DataWeave is declarativeâ€”describe the output.",
      "incorrect": {
        "A": "Order is minimal.",
        "C": "Mutation is avoided.",
        "D": "Premature optimization is discouraged."
      }
    }
  },
  {
    "id": "CH06-0397",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "code quality",
    "difficulty": "Easy",
    "question": "What indicates high-quality DataWeave code?",
    "options": {
      "A": "Deep nesting",
      "B": "Readable, predictable logic",
      "C": "Minimal whitespace",
      "D": "Hardcoded values"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readability and predictability signal quality.",
      "incorrect": {
        "A": "Nesting reduces clarity.",
        "C": "Whitespace alone is insufficient.",
        "D": "Hardcoding reduces flexibility."
      }
    }
  },
  {
    "id": "CH06-0398",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "robustness",
    "difficulty": "Easy",
    "question": "What improves robustness most?",
    "options": {
      "A": "Assuming valid input",
      "B": "Explicit null and type handling",
      "C": "Inlining expressions",
      "D": "Avoiding tests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit handling prevents failures.",
      "incorrect": {
        "A": "Assumptions fail.",
        "C": "Inlining reduces clarity.",
        "D": "Tests are essential."
      }
    }
  },
  {
    "id": "CH06-0399",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "integration fit",
    "difficulty": "Easy",
    "question": "Why is DataWeave well-suited for integrations?",
    "options": {
      "A": "Stateful processing",
      "B": "Clear, declarative transformations",
      "C": "Manual memory control",
      "D": "Thread APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Declarative transformations fit integration needs.",
      "incorrect": {
        "A": "State is avoided.",
        "C": "Memory is abstracted.",
        "D": "Threads are runtime-managed."
      }
    }
  },
  {
    "id": "CH06-0400",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "summary takeaway",
    "difficulty": "Easy",
    "question": "What is the key takeaway for effective DataWeave development?",
    "options": {
      "A": "Focus on execution control",
      "B": "Focus on data shape and intent",
      "C": "Rely on globals",
      "D": "Optimize before correctness"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design transformations around desired data shape and intent.",
      "incorrect": {
        "A": "Execution control is minimal.",
        "C": "Globals are discouraged.",
        "D": "Correctness comes first."
      }
    }
  },
  {
    "id": "CH06-0401",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "chunking",
    "difficulty": "Medium",
    "question": "What is the purpose of chunk when applied to an array?",
    "options": {
      "A": "Flatten nested arrays",
      "B": "Split an array into fixed-size subarrays",
      "C": "Remove null values",
      "D": "Sort elements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "chunk divides an array into subarrays of a specified size.",
      "incorrect": {
        "A": "Flatten removes nesting.",
        "C": "Null removal uses filter.",
        "D": "Sorting uses sortBy."
      }
    }
  },
  {
    "id": "CH06-0402",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "takeWhile",
    "difficulty": "Hard",
    "question": "What does takeWhile do on an array?",
    "options": {
      "A": "Selects elements matching a condition anywhere",
      "B": "Takes elements until the condition fails",
      "C": "Skips elements matching a condition",
      "D": "Reorders elements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "takeWhile returns elements from the start until the predicate becomes false.",
      "incorrect": {
        "A": "filter matches anywhere.",
        "C": "dropWhile skips initial matches.",
        "D": "Reordering is unrelated."
      }
    }
  },
  {
    "id": "CH06-0403",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "dropWhile",
    "difficulty": "Hard",
    "question": "What is the behavior of dropWhile?",
    "options": {
      "A": "Drops elements until a condition becomes false",
      "B": "Drops all elements matching a condition",
      "C": "Drops elements from the end",
      "D": "Drops null values only"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "dropWhile removes elements from the start while the predicate is true.",
      "incorrect": {
        "B": "filter removes all matches.",
        "C": "End removal is different.",
        "D": "Null handling is separate."
      }
    }
  },
  {
    "id": "CH06-0404",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "find",
    "difficulty": "Medium",
    "question": "What does find return when a match exists?",
    "options": {
      "A": "Array of matches",
      "B": "First matching element",
      "C": "Boolean true",
      "D": "Index of match"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "find returns the first element satisfying the predicate.",
      "incorrect": {
        "A": "filter returns arrays.",
        "C": "matches returns Boolean.",
        "D": "indexOf returns indices."
      }
    }
  },
  {
    "id": "CH06-0405",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Arrays",
    "subtopic": "find default",
    "difficulty": "Medium",
    "question": "What does find return when no element matches?",
    "options": {
      "A": "null",
      "B": "false",
      "C": "Empty array",
      "D": "Error"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "find returns null if no element matches.",
      "incorrect": {
        "B": "Boolean is not returned.",
        "C": "Arrays are not returned.",
        "D": "No error occurs."
      }
    }
  },
  {
    "id": "CH06-0406",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "pluck",
    "difficulty": "Medium",
    "question": "What does pluck produce when applied to an object?",
    "options": {
      "A": "Another object",
      "B": "An array derived from key-value pairs",
      "C": "A Boolean",
      "D": "A single value"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "pluck transforms object entries into an array.",
      "incorrect": {
        "A": "mapObject returns objects.",
        "C": "Boolean is not produced.",
        "D": "Single values are not returned."
      }
    }
  },
  {
    "id": "CH06-0407",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "key presence",
    "difficulty": "Easy",
    "question": "Which function checks if an object contains a key?",
    "options": {
      "A": "containsKey()",
      "B": "hasKey()",
      "C": "keys() contains",
      "D": "exists()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "containsKey checks for the presence of a key.",
      "incorrect": {
        "B": "Not a valid function.",
        "C": "keys returns an array; contains is separate.",
        "D": "Not supported."
      }
    }
  },
  {
    "id": "CH06-0408",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Objects",
    "subtopic": "value update",
    "difficulty": "Hard",
    "question": "How can an existing object value be updated immutably?",
    "options": {
      "A": "Direct assignment",
      "B": "Using ++ with a new key-value",
      "C": "Using set()",
      "D": "Using mutate()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "++ creates a new object with updated values.",
      "incorrect": {
        "A": "Direct assignment is not allowed.",
        "C": "set is not supported.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0409",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "trim",
    "difficulty": "Easy",
    "question": "What does trim remove from a string?",
    "options": {
      "A": "All whitespace",
      "B": "Leading and trailing whitespace",
      "C": "Internal spaces",
      "D": "Special characters"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "trim removes whitespace from both ends of a string.",
      "incorrect": {
        "A": "Internal spaces remain.",
        "C": "Not affected.",
        "D": "Special characters are unchanged."
      }
    }
  },
  {
    "id": "CH06-0410",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Strings",
    "subtopic": "lower upper",
    "difficulty": "Easy",
    "question": "Which function converts a string to uppercase?",
    "options": {
      "A": "upper()",
      "B": "toUpper()",
      "C": "uppercase()",
      "D": "cap()"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "upper converts a string to uppercase.",
      "incorrect": {
        "B": "Not a valid function.",
        "C": "Not supported.",
        "D": "Invalid."
      }
    }
  },
  {
    "id": "CH06-0411",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "abs",
    "difficulty": "Easy",
    "question": "What does abs return?",
    "options": {
      "A": "Rounded number",
      "B": "Absolute value",
      "C": "Ceiling value",
      "D": "Floor value"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "abs returns the absolute value of a number.",
      "incorrect": {
        "A": "Rounding is different.",
        "C": "Ceiling rounds up.",
        "D": "Floor rounds down."
      }
    }
  },
  {
    "id": "CH06-0412",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Numbers",
    "subtopic": "sign",
    "difficulty": "Medium",
    "question": "What does sign return for a negative number?",
    "options": {
      "A": "-1",
      "B": "0",
      "C": "1",
      "D": "null"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "sign returns -1 for negative numbers.",
      "incorrect": {
        "B": "0 is returned for zero.",
        "C": "1 is for positive.",
        "D": "null is not returned."
      }
    }
  },
  {
    "id": "CH06-0413",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "now precision",
    "difficulty": "Medium",
    "question": "What does now return?",
    "options": {
      "A": "Date only",
      "B": "DateTime with timezone",
      "C": "String timestamp",
      "D": "Milliseconds only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "now returns a DateTime including timezone.",
      "incorrect": {
        "A": "Date only uses today.",
        "C": "String is not returned.",
        "D": "Milliseconds alone are not returned."
      }
    }
  },
  {
    "id": "CH06-0414",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Dates",
    "subtopic": "format",
    "difficulty": "Medium",
    "question": "How are Date values formatted for output?",
    "options": {
      "A": "Using formatDate()",
      "B": "Using as String with a format",
      "C": "Automatic formatting only",
      "D": "Using stringify()"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dates are formatted using as String with a pattern.",
      "incorrect": {
        "A": "Not a valid function.",
        "C": "Automatic formatting is limited.",
        "D": "stringify is not supported."
      }
    }
  },
  {
    "id": "CH06-0415",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "ternary absence",
    "difficulty": "Easy",
    "question": "How is conditional logic expressed without a ternary operator?",
    "options": {
      "A": "Using when only",
      "B": "Using if-else expressions",
      "C": "Using match only",
      "D": "Using switch"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "if-else expressions replace ternary usage.",
      "incorrect": {
        "A": "when is for objects.",
        "C": "match is pattern-based.",
        "D": "switch is not used."
      }
    }
  },
  {
    "id": "CH06-0416",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Conditionals",
    "subtopic": "truthy falsy",
    "difficulty": "Hard",
    "question": "Which value is considered falsy?",
    "options": {
      "A": "Empty array",
      "B": "0",
      "C": "null",
      "D": "Empty object"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "null is considered falsy.",
      "incorrect": {
        "A": "Empty arrays are truthy.",
        "B": "0 is truthy.",
        "D": "Empty objects are truthy."
      }
    }
  },
  {
    "id": "CH06-0417",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "named functions",
    "difficulty": "Easy",
    "question": "How are reusable functions typically defined?",
    "options": {
      "A": "Inline only",
      "B": "As named functions",
      "C": "As comments",
      "D": "As variables only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Named functions improve reuse and clarity.",
      "incorrect": {
        "A": "Inline limits reuse.",
        "C": "Comments are not executable.",
        "D": "Variables alone are insufficient."
      }
    }
  },
  {
    "id": "CH06-0418",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Functions",
    "subtopic": "anonymous functions",
    "difficulty": "Medium",
    "question": "When are anonymous functions most useful?",
    "options": {
      "A": "Global reuse",
      "B": "Short inline transformations",
      "C": "Complex logic",
      "D": "Stateful operations"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Anonymous functions are ideal for concise inline logic.",
      "incorrect": {
        "A": "Globals are discouraged.",
        "C": "Complex logic needs named functions.",
        "D": "State is immutable."
      }
    }
  },
  {
    "id": "CH06-0419",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "expression reuse",
    "difficulty": "Medium",
    "question": "Why reuse expressions with let?",
    "options": {
      "A": "To change evaluation order",
      "B": "To reduce repeated computation",
      "C": "To enable mutation",
      "D": "To force typing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "let prevents recalculating the same expression.",
      "incorrect": {
        "A": "Order remains the same.",
        "C": "Mutation is not allowed.",
        "D": "Typing is unaffected."
      }
    }
  },
  {
    "id": "CH06-0420",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Performance",
    "subtopic": "avoid recomputation",
    "difficulty": "Medium",
    "question": "What causes unnecessary recomputation?",
    "options": {
      "A": "Using let",
      "B": "Repeating the same expression multiple times",
      "C": "Using functions",
      "D": "Using constants"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Repeating expressions recalculates values.",
      "incorrect": {
        "A": "let avoids recomputation.",
        "C": "Functions encapsulate logic.",
        "D": "Constants are evaluated once."
      }
    }
  },
  {
    "id": "CH06-0421",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "query params",
    "difficulty": "Easy",
    "question": "Where are HTTP query parameters accessed?",
    "options": {
      "A": "attributes.queryParams",
      "B": "attributes.uriParams",
      "C": "payload.params",
      "D": "vars.query"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Query parameters are available in attributes.queryParams.",
      "incorrect": {
        "B": "URI params are path variables.",
        "C": "Payload is the body.",
        "D": "vars are flow-scoped."
      }
    }
  },
  {
    "id": "CH06-0422",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Integration Context",
    "subtopic": "method access",
    "difficulty": "Easy",
    "question": "Where is the HTTP method accessed?",
    "options": {
      "A": "payload.method",
      "B": "attributes.method",
      "C": "vars.method",
      "D": "context.method"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP method is stored in attributes.method.",
      "incorrect": {
        "A": "Payload is body.",
        "C": "vars are user-defined.",
        "D": "context is invalid."
      }
    }
  },
  {
    "id": "CH06-0423",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "null pointer",
    "difficulty": "Medium",
    "question": "What is the safest way to avoid null pointer errors?",
    "options": {
      "A": "Assume non-null input",
      "B": "Use safe navigation and defaults",
      "C": "Inline expressions",
      "D": "Avoid conditionals"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe navigation and defaults prevent null access.",
      "incorrect": {
        "A": "Assumptions cause failures.",
        "C": "Inlining does not prevent nulls.",
        "D": "Conditionals are useful."
      }
    }
  },
  {
    "id": "CH06-0424",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Debugging",
    "subtopic": "type inspection",
    "difficulty": "Medium",
    "question": "How can developers inspect inferred types?",
    "options": {
      "A": "Through comments",
      "B": "Using IDE metadata and preview",
      "C": "Using logs only",
      "D": "At runtime only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "IDE preview and metadata show inferred types.",
      "incorrect": {
        "A": "Comments do not inspect types.",
        "C": "Logs are indirect.",
        "D": "Not limited to runtime."
      }
    }
  },
  {
    "id": "CH06-0425",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "readability",
    "difficulty": "Easy",
    "question": "What improves readability most?",
    "options": {
      "A": "Deep nesting",
      "B": "Clear formatting and naming",
      "C": "Hardcoded values",
      "D": "Minimal whitespace"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Formatting and naming improve understanding.",
      "incorrect": {
        "A": "Nesting reduces clarity.",
        "C": "Hardcoding harms reuse.",
        "D": "Whitespace alone is insufficient."
      }
    }
  },
  {
    "id": "CH06-0426",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Best Practices",
    "subtopic": "function reuse",
    "difficulty": "Easy",
    "question": "Why reuse functions?",
    "options": {
      "A": "Increase complexity",
      "B": "Reduce duplication",
      "C": "Force eager evaluation",
      "D": "Enable mutation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse avoids duplication and errors.",
      "incorrect": {
        "A": "Complexity is reduced.",
        "C": "Evaluation is unchanged.",
        "D": "Mutation is not allowed."
      }
    }
  },
  {
    "id": "CH06-0427",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "determinism",
    "difficulty": "Medium",
    "question": "What ensures deterministic transformations?",
    "options": {
      "A": "Global variables",
      "B": "Pure functions and immutability",
      "C": "Runtime context",
      "D": "Random inputs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Purity and immutability ensure determinism.",
      "incorrect": {
        "A": "Globals break determinism.",
        "C": "Context can vary.",
        "D": "Randomness breaks determinism."
      }
    }
  },
  {
    "id": "CH06-0428",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Concepts",
    "subtopic": "side effects",
    "difficulty": "Medium",
    "question": "Why are side effects avoided?",
    "options": {
      "A": "They slow execution",
      "B": "They reduce predictability",
      "C": "They increase memory",
      "D": "They prevent compilation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Side effects make behavior unpredictable.",
      "incorrect": {
        "A": "Speed impact varies.",
        "C": "Memory is not primary.",
        "D": "Compilation is unaffected."
      }
    }
  },
  {
    "id": "CH06-0429",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "integration goal",
    "difficulty": "Easy",
    "question": "What is the primary goal of DataWeave in integrations?",
    "options": {
      "A": "Transport data",
      "B": "Transform data accurately",
      "C": "Persist data",
      "D": "Manage sessions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accurate transformation is the core goal.",
      "incorrect": {
        "A": "Transport is connector responsibility.",
        "C": "Persistence is external.",
        "D": "Sessions are managed elsewhere."
      }
    }
  },
  {
    "id": "CH06-0430",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "developer mindset",
    "difficulty": "Easy",
    "question": "Which mindset best fits DataWeave?",
    "options": {
      "A": "Imperative",
      "B": "Declarative",
      "C": "Stateful",
      "D": "Procedural"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Declarative thinking aligns with DataWeave.",
      "incorrect": {
        "A": "Imperative style is discouraged.",
        "C": "State is immutable.",
        "D": "Procedural is not primary."
      }
    }
  },
  {
    "id": "CH06-0431",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "robust design",
    "difficulty": "Easy",
    "question": "What most improves robustness?",
    "options": {
      "A": "Assumptions",
      "B": "Validation and null handling",
      "C": "Inlining logic",
      "D": "Ignoring errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation prevents failures.",
      "incorrect": {
        "A": "Assumptions fail.",
        "C": "Inlining reduces clarity.",
        "D": "Errors must be handled."
      }
    }
  },
  {
    "id": "CH06-0432",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "clarity",
    "difficulty": "Easy",
    "question": "What most contributes to clarity?",
    "options": {
      "A": "Complex expressions",
      "B": "Readable structure",
      "C": "Hardcoding",
      "D": "Minimal spacing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Readable structure improves clarity.",
      "incorrect": {
        "A": "Complexity reduces clarity.",
        "C": "Hardcoding harms reuse.",
        "D": "Spacing alone is insufficient."
      }
    }
  },
  {
    "id": "CH06-0433",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "scalability",
    "difficulty": "Easy",
    "question": "Which supports scalability?",
    "options": {
      "A": "Mutable state",
      "B": "Stateless transformations",
      "C": "Global variables",
      "D": "Side effects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stateless design scales safely.",
      "incorrect": {
        "A": "State hinders scaling.",
        "C": "Globals cause contention.",
        "D": "Side effects reduce safety."
      }
    }
  },
  {
    "id": "CH06-0434",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "testing",
    "difficulty": "Easy",
    "question": "What should tests validate?",
    "options": {
      "A": "Thread usage",
      "B": "Correct output for given input",
      "C": "Memory allocation",
      "D": "Deployment time"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tests confirm input-to-output correctness.",
      "incorrect": {
        "A": "Threads are runtime-managed.",
        "C": "Memory is abstracted.",
        "D": "Deployment is unrelated."
      }
    }
  },
  {
    "id": "CH06-0435",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "learning",
    "difficulty": "Easy",
    "question": "What accelerates mastery?",
    "options": {
      "A": "Memorization",
      "B": "Hands-on practice",
      "C": "Avoiding complexity",
      "D": "Ignoring errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Practice builds real understanding.",
      "incorrect": {
        "A": "Memorization is limited.",
        "C": "Complexity must be addressed.",
        "D": "Errors teach lessons."
      }
    }
  },
  {
    "id": "CH06-0436",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "core strength",
    "difficulty": "Easy",
    "question": "What is DataWeaveâ€™s core strength?",
    "options": {
      "A": "Routing",
      "B": "Declarative transformation",
      "C": "Persistence",
      "D": "Thread control"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Declarative transformation is its core.",
      "incorrect": {
        "A": "Routing is flow logic.",
        "C": "Persistence is external.",
        "D": "Threads are runtime-managed."
      }
    }
  },
  {
    "id": "CH06-0437",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "quality indicator",
    "difficulty": "Easy",
    "question": "What indicates quality code?",
    "options": {
      "A": "Deep nesting",
      "B": "Predictable results",
      "C": "Hardcoded values",
      "D": "Minimal comments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable behavior indicates quality.",
      "incorrect": {
        "A": "Nesting harms clarity.",
        "C": "Hardcoding limits reuse.",
        "D": "Comments can help."
      }
    }
  },
  {
    "id": "CH06-0438",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "error prevention",
    "difficulty": "Easy",
    "question": "What best prevents runtime errors?",
    "options": {
      "A": "Assuming valid input",
      "B": "Defensive checks",
      "C": "Inlining expressions",
      "D": "Avoiding functions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defensive checks catch issues early.",
      "incorrect": {
        "A": "Assumptions are risky.",
        "C": "Inlining reduces clarity.",
        "D": "Functions aid structure."
      }
    }
  },
  {
    "id": "CH06-0439",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "integration fit",
    "difficulty": "Easy",
    "question": "Why is DataWeave ideal for integrations?",
    "options": {
      "A": "Stateful logic",
      "B": "Clear transformation semantics",
      "C": "Manual memory control",
      "D": "Thread APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear semantics suit integration needs.",
      "incorrect": {
        "A": "State is avoided.",
        "C": "Memory is abstracted.",
        "D": "Threads are runtime-managed."
      }
    }
  },
  {
    "id": "CH06-0440",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "guiding idea",
    "difficulty": "Easy",
    "question": "What guiding idea should developers follow?",
    "options": {
      "A": "Control execution",
      "B": "Shape data intentionally",
      "C": "Optimize early",
      "D": "Track state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Intentional data shaping is key.",
      "incorrect": {
        "A": "Execution control is minimal.",
        "C": "Optimization comes later.",
        "D": "State is immutable."
      }
    }
  },
  {
    "id": "CH06-0441",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "immutability benefit",
    "difficulty": "Medium",
    "question": "What is a key benefit of immutability?",
    "options": {
      "A": "Faster IO",
      "B": "Thread safety",
      "C": "Lower latency",
      "D": "Dynamic typing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability prevents shared-state issues.",
      "incorrect": {
        "A": "IO speed is unrelated.",
        "C": "Latency varies.",
        "D": "Typing is separate."
      }
    }
  },
  {
    "id": "CH06-0442",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "purity value",
    "difficulty": "Medium",
    "question": "Why are pure functions valuable?",
    "options": {
      "A": "They mutate data",
      "B": "They are predictable",
      "C": "They depend on time",
      "D": "They require globals"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictability simplifies reasoning and testing.",
      "incorrect": {
        "A": "Mutation is avoided.",
        "C": "Time dependence breaks purity.",
        "D": "Globals are discouraged."
      }
    }
  },
  {
    "id": "CH06-0443",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "lazy evaluation",
    "difficulty": "Medium",
    "question": "What is a benefit of lazy evaluation?",
    "options": {
      "A": "Immediate execution",
      "B": "Avoiding unnecessary computation",
      "C": "Guaranteed order",
      "D": "Side effects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lazy evaluation skips work until needed.",
      "incorrect": {
        "A": "Execution is deferred.",
        "C": "Order is unaffected.",
        "D": "Side effects are avoided."
      }
    }
  },
  {
    "id": "CH06-0444",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "lazy risk",
    "difficulty": "Medium",
    "question": "What risk comes with lazy evaluation?",
    "options": {
      "A": "Higher memory always",
      "B": "Delayed error detection",
      "C": "Forced eager execution",
      "D": "Non-determinism"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Errors may appear later when values are evaluated.",
      "incorrect": {
        "A": "Memory may be lower.",
        "C": "Lazy does not force eager.",
        "D": "Determinism remains."
      }
    }
  },
  {
    "id": "CH06-0445",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "referential transparency",
    "difficulty": "Medium",
    "question": "What does referential transparency guarantee?",
    "options": {
      "A": "Different outputs per call",
      "B": "Same output for same input",
      "C": "Mutation safety",
      "D": "Runtime optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Same input always yields the same output.",
      "incorrect": {
        "A": "Non-deterministic.",
        "C": "Mutation is avoided.",
        "D": "Optimization is secondary."
      }
    }
  },
  {
    "id": "CH06-0446",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "functional style",
    "difficulty": "Easy",
    "question": "What defines functional style in DataWeave?",
    "options": {
      "A": "Mutable state",
      "B": "Pure functions and expressions",
      "C": "Procedural loops",
      "D": "Global variables"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Functional style relies on pure expressions.",
      "incorrect": {
        "A": "State is immutable.",
        "C": "Loops are abstracted.",
        "D": "Globals are discouraged."
      }
    }
  },
  {
    "id": "CH06-0447",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Advanced Review",
    "subtopic": "integration safety",
    "difficulty": "Easy",
    "question": "What property makes integrations safer?",
    "options": {
      "A": "Shared mutable state",
      "B": "Immutability",
      "C": "Random inputs",
      "D": "Side effects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Immutability prevents unintended changes.",
      "incorrect": {
        "A": "Shared state is risky.",
        "C": "Randomness is unsafe.",
        "D": "Side effects cause issues."
      }
    }
  },
  {
    "id": "CH06-0448",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "best habit",
    "difficulty": "Easy",
    "question": "Which habit leads to better DataWeave code?",
    "options": {
      "A": "Assuming input shape",
      "B": "Validating inputs",
      "C": "Avoiding tests",
      "D": "Inlining everything"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation prevents unexpected failures.",
      "incorrect": {
        "A": "Assumptions fail.",
        "C": "Tests are important.",
        "D": "Inlining reduces clarity."
      }
    }
  },
  {
    "id": "CH06-0449",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "success factor",
    "difficulty": "Easy",
    "question": "What most contributes to successful transformations?",
    "options": {
      "A": "Complex syntax",
      "B": "Clear intent",
      "C": "Global reuse",
      "D": "Minimal whitespace"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear intent guides correct transformations.",
      "incorrect": {
        "A": "Complexity adds risk.",
        "C": "Globals are discouraged.",
        "D": "Whitespace alone is insufficient."
      }
    }
  },
  {
    "id": "CH06-0450",
    "chapter": 6,
    "chapterTitle": "DataWeave Fundamentals",
    "topic": "Final Review",
    "subtopic": "final takeaway",
    "difficulty": "Easy",
    "question": "What is the final takeaway for DataWeave fundamentals?",
    "options": {
      "A": "Optimize first",
      "B": "Focus on data shape and correctness",
      "C": "Control execution flow",
      "D": "Rely on side effects"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correct data shaping is the core focus.",
      "incorrect": {
        "A": "Optimization comes later.",
        "C": "Execution control is minimal.",
        "D": "Side effects are avoided."
      }
    }
  }
]
