[
  {
    "id": "CH02-0001",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "REST constraints",
    "difficulty": "Medium",
    "question": "Which REST constraint enforces that each request must contain all information needed to process it?",
    "options": {
      "A": "Cacheable",
      "B": "Statelessness",
      "C": "Uniform interface",
      "D": "Layered system"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Statelessness requires every request to be independent and self-contained.",
      "incorrect": {
        "A": "Caching relates to response reuse.",
        "C": "Uniform interface standardizes interactions.",
        "D": "Layered systems hide internal structure."
      }
    }
  },
  {
    "id": "CH02-0002",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Resources",
    "difficulty": "Easy",
    "question": "In REST, what does a resource represent?",
    "options": {
      "A": "A database table",
      "B": "A conceptual object identified by a URI",
      "C": "A backend service",
      "D": "An HTTP method"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Resources are conceptual entities exposed via URIs.",
      "incorrect": {
        "A": "Resources are not tied directly to tables.",
        "C": "Services may expose resources but are not resources themselves.",
        "D": "Methods act on resources."
      }
    }
  },
  {
    "id": "CH02-0003",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "GET semantics",
    "difficulty": "Easy",
    "question": "Which characteristic is mandatory for a proper GET request?",
    "options": {
      "A": "It modifies server state",
      "B": "It is idempotent and safe",
      "C": "It requires a request body",
      "D": "It must return status code 201"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "GET must be safe (no state change) and idempotent.",
      "incorrect": {
        "A": "GET must not modify state.",
        "C": "GET requests typically do not have bodies.",
        "D": "201 is for resource creation."
      }
    }
  },
  {
    "id": "CH02-0004",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "POST behavior",
    "difficulty": "Medium",
    "question": "When should POST be used in a RESTful API?",
    "options": {
      "A": "To retrieve resources",
      "B": "To partially update a resource",
      "C": "To create a new subordinate resource",
      "D": "To replace an entire resource"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "POST is commonly used to create new resources under a collection.",
      "incorrect": {
        "A": "GET retrieves resources.",
        "B": "PATCH is used for partial updates.",
        "D": "PUT replaces a resource."
      }
    }
  },
  {
    "id": "CH02-0005",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "PUT vs PATCH",
    "difficulty": "Hard",
    "question": "What is the primary difference between PUT and PATCH?",
    "options": {
      "A": "PUT is not idempotent",
      "B": "PATCH replaces the entire resource",
      "C": "PUT replaces the full resource, PATCH updates parts",
      "D": "PATCH cannot return a response body"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "PUT replaces the complete resource, PATCH applies partial updates.",
      "incorrect": {
        "A": "PUT is idempotent.",
        "B": "PATCH does not replace the entire resource.",
        "D": "PATCH may return a body."
      }
    }
  },

  {
    "id": "CH02-0006",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "2xx responses",
    "difficulty": "Easy",
    "question": "Which HTTP status code indicates successful resource creation?",
    "options": {
      "A": "200",
      "B": "201",
      "C": "202",
      "D": "204"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "201 Created confirms successful resource creation.",
      "incorrect": {
        "A": "200 is a generic success.",
        "C": "202 indicates accepted for processing.",
        "D": "204 has no response body."
      }
    }
  },
  {
    "id": "CH02-0007",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "Client errors",
    "difficulty": "Medium",
    "question": "When should HTTP 400 be returned?",
    "options": {
      "A": "Authentication failure",
      "B": "Authorization failure",
      "C": "Malformed or invalid client request",
      "D": "Server processing failure"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "400 indicates a bad request due to invalid client input.",
      "incorrect": {
        "A": "401 is authentication failure.",
        "B": "403 is authorization failure.",
        "D": "500 indicates server errors."
      }
    }
  },
  {
    "id": "CH02-0008",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Best practices",
    "difficulty": "Medium",
    "question": "Which URI follows REST best practices?",
    "options": {
      "A": "/getUserDetails",
      "B": "/users/get",
      "C": "/users/123",
      "D": "/fetch-user"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "URIs should represent resources, not actions.",
      "incorrect": {
        "A": "Verbs should not be in URIs.",
        "B": "Actions belong to HTTP methods.",
        "D": "Non-resource naming is discouraged."
      }
    }
  },
  {
    "id": "CH02-0009",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Filtering",
    "difficulty": "Easy",
    "question": "What is the primary purpose of query parameters?",
    "options": {
      "A": "Define resource identity",
      "B": "Modify server configuration",
      "C": "Filter or refine resource results",
      "D": "Replace request headers"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Query parameters refine or filter returned resources.",
      "incorrect": {
        "A": "Path parameters identify resources.",
        "B": "Clients should not modify server config.",
        "D": "Headers serve a different purpose."
      }
    }
  },
  {
    "id": "CH02-0010",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Headers",
    "subtopic": "Content negotiation",
    "difficulty": "Medium",
    "question": "Which header is used for content negotiation by the client?",
    "options": {
      "A": "Content-Type",
      "B": "Accept",
      "C": "Authorization",
      "D": "Cache-Control"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Accept header specifies the response formats the client can process.",
      "incorrect": {
        "A": "Content-Type describes request payload.",
        "C": "Authorization handles security.",
        "D": "Cache-Control manages caching."
      }
    }
  },
  {
    "id": "CH02-0011",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Headers",
    "subtopic": "Content-Type usage",
    "difficulty": "Easy",
    "question": "What does the Content-Type header represent in an HTTP request?",
    "options": {
      "A": "The format expected in the response",
      "B": "The authentication mechanism used",
      "C": "The media type of the request payload",
      "D": "The caching strategy"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Content-Type indicates the media type of the request body sent to the server.",
      "incorrect": {
        "A": "Accept header defines response formats.",
        "B": "Authentication is handled separately.",
        "D": "Caching is controlled via Cache-Control."
      }
    }
  },
  {
    "id": "CH02-0012",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "204 usage",
    "difficulty": "Medium",
    "question": "When is HTTP 204 No Content most appropriate?",
    "options": {
      "A": "When a new resource is created",
      "B": "When a request succeeds but no response body is needed",
      "C": "When the request is invalid",
      "D": "When authentication fails"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "204 is returned when the operation succeeds without returning a payload.",
      "incorrect": {
        "A": "201 is used for creation.",
        "C": "400 indicates invalid requests.",
        "D": "401 is for authentication failures."
      }
    }
  },
  {
    "id": "CH02-0013",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Plural nouns",
    "difficulty": "Easy",
    "question": "Why are plural nouns recommended in REST resource URIs?",
    "options": {
      "A": "They improve database mapping",
      "B": "They better represent collections of resources",
      "C": "They reduce URI length",
      "D": "They eliminate versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Plural nouns clearly indicate collections of resources.",
      "incorrect": {
        "A": "URIs should not reflect database structure.",
        "C": "Length is not the main concern.",
        "D": "Versioning is independent of naming."
      }
    }
  },
  {
    "id": "CH02-0014",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Pagination",
    "difficulty": "Medium",
    "question": "Which query parameter strategy best supports pagination?",
    "options": {
      "A": "/users/page/1",
      "B": "/users?offset=0&limit=10",
      "C": "/users/getPage",
      "D": "/users/pageOne"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Offset and limit parameters are commonly used for pagination.",
      "incorrect": {
        "A": "Path parameters should represent resources.",
        "C": "Actions should not appear in URIs.",
        "D": "Non-standard naming reduces clarity."
      }
    }
  },
  {
    "id": "CH02-0015",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Constraints",
    "subtopic": "Cacheable",
    "difficulty": "Medium",
    "question": "What is the main benefit of cacheable responses in REST?",
    "options": {
      "A": "Improved security",
      "B": "Reduced server load and latency",
      "C": "Simpler error handling",
      "D": "Elimination of authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Caching reduces repeated processing and improves performance.",
      "incorrect": {
        "A": "Caching does not directly improve security.",
        "C": "Error handling is unrelated.",
        "D": "Authentication is still required."
      }
    }
  },

  {
    "id": "CH02-0016",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "DELETE semantics",
    "difficulty": "Medium",
    "question": "Which statement about DELETE is correct?",
    "options": {
      "A": "DELETE must always return a body",
      "B": "DELETE is not idempotent",
      "C": "DELETE removes a resource identified by the URI",
      "D": "DELETE replaces the resource"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "DELETE removes the resource identified by the URI.",
      "incorrect": {
        "A": "DELETE may return 204 with no body.",
        "B": "DELETE is idempotent.",
        "D": "PUT replaces resources."
      }
    }
  },
  {
    "id": "CH02-0017",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "URI versioning",
    "difficulty": "Medium",
    "question": "Which URI demonstrates versioning through the path?",
    "options": {
      "A": "/users?version=1",
      "B": "/v1/users",
      "C": "/users/v1",
      "D": "/users-version1"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Placing the version at the base path is a common versioning approach.",
      "incorrect": {
        "A": "Query versioning is less explicit.",
        "C": "Version should precede resource collections.",
        "D": "Non-standard naming reduces clarity."
      }
    }
  },
  {
    "id": "CH02-0018",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Consistency",
    "difficulty": "Hard",
    "question": "Why should APIs return consistent error response structures?",
    "options": {
      "A": "To expose stack traces",
      "B": "To simplify client-side error handling",
      "C": "To eliminate retries",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency allows consumers to reliably parse and react to errors.",
      "incorrect": {
        "A": "Internal details should not be exposed.",
        "C": "Retries depend on error type.",
        "D": "Payload size is secondary."
      }
    }
  },
  {
    "id": "CH02-0019",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Sorting",
    "subtopic": "Query parameters",
    "difficulty": "Easy",
    "question": "Which query parameter approach best supports sorting?",
    "options": {
      "A": "/users/sort/name",
      "B": "/users?sort=name,asc",
      "C": "/users/sorted",
      "D": "/users/nameSort"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sorting is typically handled through query parameters.",
      "incorrect": {
        "A": "Path parameters should identify resources.",
        "C": "Non-specific naming lacks clarity.",
        "D": "Actions should not appear in URIs."
      }
    }
  },
  {
    "id": "CH02-0020",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "401 vs 403",
    "difficulty": "Hard",
    "question": "What is the key difference between HTTP 401 and 403?",
    "options": {
      "A": "401 is server error, 403 is client error",
      "B": "401 indicates missing or invalid authentication, 403 indicates insufficient authorization",
      "C": "401 is permanent, 403 is temporary",
      "D": "There is no difference"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "401 relates to authentication, 403 relates to authorization.",
      "incorrect": {
        "A": "Both are client error responses.",
        "C": "Neither implies permanence.",
        "D": "They represent distinct conditions."
      }
    }
  },

  {
    "id": "CH02-0021",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML Basics",
    "subtopic": "Design-first",
    "difficulty": "Medium",
    "question": "What does design-first API development emphasize?",
    "options": {
      "A": "Writing code before documentation",
      "B": "Defining the API contract before implementation",
      "C": "Avoiding specifications",
      "D": "Skipping validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design-first focuses on defining the contract before coding.",
      "incorrect": {
        "A": "Design comes before coding.",
        "C": "Specifications are central.",
        "D": "Validation is essential."
      }
    }
  },
  {
    "id": "CH02-0022",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Base URI",
    "difficulty": "Easy",
    "question": "What is the purpose of baseUri in RAML?",
    "options": {
      "A": "Define authentication",
      "B": "Specify the root URI of the API",
      "C": "Describe error handling",
      "D": "Enable versioning automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "baseUri defines the root endpoint for the API.",
      "incorrect": {
        "A": "Authentication is defined separately.",
        "C": "Errors are modeled elsewhere.",
        "D": "Versioning must be specified explicitly."
      }
    }
  },
  {
    "id": "CH02-0023",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Resource types",
    "difficulty": "Medium",
    "question": "Why are resourceTypes used in RAML?",
    "options": {
      "A": "To define security policies",
      "B": "To reuse common resource patterns",
      "C": "To enforce runtime behavior",
      "D": "To manage deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "resourceTypes promote reuse of common resource structures.",
      "incorrect": {
        "A": "Security is handled via security schemes.",
        "C": "RAML defines contracts, not runtime behavior.",
        "D": "Deployment is outside RAML scope."
      }
    }
  },
  {
    "id": "CH02-0024",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Traits",
    "difficulty": "Medium",
    "question": "What is the main purpose of traits in RAML?",
    "options": {
      "A": "Define data types",
      "B": "Reuse method-level behavior such as headers or query params",
      "C": "Control deployment environments",
      "D": "Handle authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traits allow reuse of method-level configurations.",
      "incorrect": {
        "A": "Data types are defined separately.",
        "C": "Deployment is not part of RAML.",
        "D": "Authentication uses security schemes."
      }
    }
  },
  {
    "id": "CH02-0025",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Examples",
    "difficulty": "Easy",
    "question": "Why are examples important in API specifications?",
    "options": {
      "A": "They replace documentation",
      "B": "They help consumers understand request and response formats",
      "C": "They enforce runtime validation",
      "D": "They eliminate testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Examples improve clarity and reduce onboarding time.",
      "incorrect": {
        "A": "Documentation is still required.",
        "C": "Validation depends on implementation.",
        "D": "Testing remains necessary."
      }
    }
  },

  {
    "id": "CH02-0026",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "OpenAPI purpose",
    "difficulty": "Easy",
    "question": "What is the primary goal of the OpenAPI Specification?",
    "options": {
      "A": "To implement APIs",
      "B": "To describe REST APIs in a standard, machine-readable format",
      "C": "To deploy APIs",
      "D": "To replace HTTP"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "OAS provides a standard way to describe REST APIs.",
      "incorrect": {
        "A": "Implementation is separate.",
        "C": "Deployment is not handled by OAS.",
        "D": "HTTP remains fundamental."
      }
    }
  },
  {
    "id": "CH02-0027",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "RAML vs OAS",
    "difficulty": "Medium",
    "question": "Which statement correctly compares RAML and OAS?",
    "options": {
      "A": "RAML cannot define responses",
      "B": "Both can describe REST APIs using specifications",
      "C": "OAS is proprietary to MuleSoft",
      "D": "RAML cannot be design-first"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Both RAML and OAS are used to define REST APIs.",
      "incorrect": {
        "A": "RAML supports responses.",
        "C": "OAS is vendor-neutral.",
        "D": "RAML strongly supports design-first."
      }
    }
  },
  {
    "id": "CH02-0028",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Schemas",
    "difficulty": "Medium",
    "question": "Why should APIs define schemas for request and response bodies?",
    "options": {
      "A": "To slow development",
      "B": "To validate structure and improve consistency",
      "C": "To eliminate documentation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schemas ensure consistent and predictable data structures.",
      "incorrect": {
        "A": "Schemas improve efficiency.",
        "C": "Documentation remains required.",
        "D": "Versioning is still needed."
      }
    }
  },
  {
    "id": "CH02-0029",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Envelope pattern",
    "difficulty": "Hard",
    "question": "Why is a response envelope sometimes used in APIs?",
    "options": {
      "A": "To hide response data",
      "B": "To include metadata alongside the actual payload",
      "C": "To eliminate HTTP status codes",
      "D": "To reduce payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Envelopes allow metadata such as pagination info to accompany data.",
      "incorrect": {
        "A": "Data is still exposed.",
        "C": "HTTP status codes are still used.",
        "D": "Payload size may increase."
      }
    }
  },
  {
    "id": "CH02-0030",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Best Practices",
    "subtopic": "Consistency",
    "difficulty": "Medium",
    "question": "Why is consistency critical across an API surface?",
    "options": {
      "A": "It increases development time",
      "B": "It improves usability and reduces consumer errors",
      "C": "It eliminates the need for documentation",
      "D": "It removes governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent APIs are easier to learn and integrate with.",
      "incorrect": {
        "A": "Consistency speeds development.",
        "C": "Documentation is still required.",
        "D": "Governance remains essential."
      }
    }
  },

  {
    "id": "CH02-0031",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Consumer-driven design",
    "difficulty": "Hard",
    "question": "What does consumer-driven API design emphasize?",
    "options": {
      "A": "Backend convenience",
      "B": "Consumer needs and use cases",
      "C": "Database structure",
      "D": "Infrastructure optimization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Designing around consumer needs improves adoption and reuse.",
      "incorrect": {
        "A": "Backend convenience should not dominate design.",
        "C": "APIs should abstract databases.",
        "D": "Infrastructure is secondary."
      }
    }
  },
  {
    "id": "CH02-0032",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Client guidance",
    "difficulty": "Medium",
    "question": "Why should API error messages provide actionable information?",
    "options": {
      "A": "To expose internal logic",
      "B": "To help clients correct requests",
      "C": "To eliminate retries",
      "D": "To replace documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Actionable errors reduce trial-and-error for clients.",
      "incorrect": {
        "A": "Internal details should not be exposed.",
        "C": "Retries may still be needed.",
        "D": "Documentation is still required."
      }
    }
  },
  {
    "id": "CH02-0033",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Backward compatibility",
    "difficulty": "Hard",
    "question": "Which change is most likely to break backward compatibility?",
    "options": {
      "A": "Adding optional fields",
      "B": "Removing required fields",
      "C": "Adding new endpoints",
      "D": "Improving documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing required fields breaks existing consumers.",
      "incorrect": {
        "A": "Optional additions are safe.",
        "C": "New endpoints do not affect existing ones.",
        "D": "Documentation does not affect behavior."
      }
    }
  },
  {
    "id": "CH02-0034",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Contracts",
    "subtopic": "Stability",
    "difficulty": "Medium",
    "question": "Why are stable API contracts important?",
    "options": {
      "A": "They slow innovation",
      "B": "They protect consumers from frequent breaking changes",
      "C": "They eliminate versioning",
      "D": "They avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts build trust and enable reuse.",
      "incorrect": {
        "A": "Innovation can continue safely.",
        "C": "Versioning is still needed.",
        "D": "Governance supports stability."
      }
    }
  },
  {
    "id": "CH02-0035",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Mocking",
    "difficulty": "Medium",
    "question": "Why are API mocks useful during design?",
    "options": {
      "A": "They replace implementation",
      "B": "They allow early validation with consumers",
      "C": "They enforce runtime policies",
      "D": "They remove testing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mocks enable early feedback before implementation.",
      "incorrect": {
        "A": "Mocks do not replace real services.",
        "C": "Policies apply at runtime.",
        "D": "Testing is still required."
      }
    }
  },

  {
    "id": "CH02-0036",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Patterns",
    "subtopic": "HATEOAS",
    "difficulty": "Hard",
    "question": "What is the purpose of HATEOAS in REST?",
    "options": {
      "A": "To reduce payload size",
      "B": "To guide clients using hypermedia links",
      "C": "To eliminate documentation",
      "D": "To enforce authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HATEOAS allows clients to discover actions dynamically.",
      "incorrect": {
        "A": "Payload size may increase.",
        "C": "Documentation is still needed.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH02-0037",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Predictability",
    "difficulty": "Medium",
    "question": "What improves predictability in API design?",
    "options": {
      "A": "Inconsistent naming",
      "B": "Standardized patterns and conventions",
      "C": "Frequent breaking changes",
      "D": "Minimal documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards and conventions reduce surprises for consumers.",
      "incorrect": {
        "A": "Inconsistency reduces usability.",
        "C": "Breaking changes harm predictability.",
        "D": "Documentation is essential."
      }
    }
  },
  {
    "id": "CH02-0038",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Design-time security",
    "difficulty": "Hard",
    "question": "Why should security be considered at API design time?",
    "options": {
      "A": "Security can be added later",
      "B": "Design-time security reduces costly rework and vulnerabilities",
      "C": "Security eliminates flexibility",
      "D": "Security is only runtime concern"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early security design prevents vulnerabilities and redesign.",
      "incorrect": {
        "A": "Late security increases risk.",
        "C": "Good security preserves flexibility.",
        "D": "Security spans design and runtime."
      }
    }
  },
  {
    "id": "CH02-0039",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Standards enforcement",
    "difficulty": "Medium",
    "question": "What is the primary role of API design standards?",
    "options": {
      "A": "To restrict innovation",
      "B": "To ensure consistency and quality across APIs",
      "C": "To eliminate documentation",
      "D": "To avoid reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards ensure APIs are consistent and high-quality.",
      "incorrect": {
        "A": "Standards enable innovation at scale.",
        "C": "Documentation is still required.",
        "D": "Reuse is encouraged."
      }
    }
  },
  {
    "id": "CH02-0040",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Maturity",
    "subtopic": "Continuous improvement",
    "difficulty": "Hard",
    "question": "Why should API designs be continuously improved?",
    "options": {
      "A": "Requirements never change",
      "B": "Consumer needs and usage patterns evolve",
      "C": "Documentation becomes unnecessary",
      "D": "Versioning can be avoided"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs must evolve to remain useful and relevant.",
      "incorrect": {
        "A": "Requirements change over time.",
        "C": "Documentation remains essential.",
        "D": "Versioning is still needed."
      }
    }
  },

  {
    "id": "CH02-0041",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "Idempotency",
    "difficulty": "Medium",
    "question": "Which HTTP method is idempotent but not safe?",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PUT",
      "D": "PATCH"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "PUT is idempotent because multiple identical requests result in the same state, but it is not safe because it modifies server state.",
      "incorrect": {
        "A": "GET is both safe and idempotent.",
        "B": "POST is neither safe nor idempotent.",
        "D": "PATCH is generally not idempotent."
      }
    }
  },
  {
    "id": "CH02-0042",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "Safety",
    "difficulty": "Easy",
    "question": "What does it mean when an HTTP method is described as safe?",
    "options": {
      "A": "It encrypts data automatically",
      "B": "It does not modify server state",
      "C": "It always returns status 200",
      "D": "It cannot fail"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Safe methods do not cause state changes on the server.",
      "incorrect": {
        "A": "Encryption is handled separately.",
        "C": "Different success codes may be returned.",
        "D": "Any request can fail."
      }
    }
  },
  {
    "id": "CH02-0043",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "202 Accepted",
    "difficulty": "Medium",
    "question": "When should HTTP 202 Accepted be used?",
    "options": {
      "A": "When a request is fully processed",
      "B": "When processing is asynchronous and not yet complete",
      "C": "When a resource is created",
      "D": "When authentication fails"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "202 indicates that the request has been accepted for processing but is not yet complete.",
      "incorrect": {
        "A": "200 indicates full processing.",
        "C": "201 is used for creation.",
        "D": "401 indicates authentication failure."
      }
    }
  },
  {
    "id": "CH02-0044",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Hierarchy",
    "difficulty": "Medium",
    "question": "Which URI best represents a sub-resource?",
    "options": {
      "A": "/orders/getItems",
      "B": "/items/123/order",
      "C": "/orders/123/items",
      "D": "/order-items"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "Sub-resources are represented hierarchically under their parent resources.",
      "incorrect": {
        "A": "Actions should not appear in URIs.",
        "B": "Hierarchy is reversed.",
        "D": "This does not represent a clear relationship."
      }
    }
  },
  {
    "id": "CH02-0045",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Searching",
    "difficulty": "Easy",
    "question": "What is the preferred way to implement search functionality in APIs?",
    "options": {
      "A": "Embedding search logic in the URI path",
      "B": "Using query parameters for search criteria",
      "C": "Creating separate endpoints for every search",
      "D": "Using request headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Query parameters are ideal for search and filtering operations.",
      "incorrect": {
        "A": "Paths should identify resources, not actions.",
        "C": "This approach does not scale.",
        "D": "Headers are not meant for search logic."
      }
    }
  },

  {
    "id": "CH02-0046",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Header versioning",
    "difficulty": "Hard",
    "question": "What is an advantage of header-based API versioning?",
    "options": {
      "A": "It simplifies routing logic",
      "B": "It keeps URIs clean and stable",
      "C": "It eliminates backward compatibility concerns",
      "D": "It avoids documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Header-based versioning avoids cluttering URIs with version numbers.",
      "incorrect": {
        "A": "Routing can become more complex.",
        "C": "Backward compatibility is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0047",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Headers",
    "subtopic": "Cache-Control",
    "difficulty": "Medium",
    "question": "What is the purpose of the Cache-Control header?",
    "options": {
      "A": "Authenticate requests",
      "B": "Define caching behavior of responses",
      "C": "Specify response format",
      "D": "Control request routing"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cache-Control specifies how responses may be cached by clients and intermediaries.",
      "incorrect": {
        "A": "Authentication uses Authorization headers.",
        "C": "Formats are defined using Accept or Content-Type.",
        "D": "Routing is not controlled via headers."
      }
    }
  },
  {
    "id": "CH02-0048",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Types",
    "difficulty": "Medium",
    "question": "What is the main benefit of defining types in RAML?",
    "options": {
      "A": "They enforce runtime performance",
      "B": "They promote consistency and reuse in data models",
      "C": "They handle authentication",
      "D": "They manage deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Types allow reuse and consistency across request and response bodies.",
      "incorrect": {
        "A": "RAML types define structure, not performance.",
        "C": "Authentication is defined separately.",
        "D": "Deployment is outside RAML scope."
      }
    }
  },
  {
    "id": "CH02-0049",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Libraries",
    "difficulty": "Medium",
    "question": "Why are libraries used in RAML?",
    "options": {
      "A": "To deploy APIs",
      "B": "To share reusable definitions across APIs",
      "C": "To execute business logic",
      "D": "To define runtime policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Libraries enable reuse of types, traits, and resourceTypes across specifications.",
      "incorrect": {
        "A": "Deployment is not handled by RAML.",
        "C": "RAML does not execute logic.",
        "D": "Policies are applied at runtime."
      }
    }
  },
  {
    "id": "CH02-0050",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Components",
    "difficulty": "Medium",
    "question": "What is the purpose of components in OpenAPI Specification?",
    "options": {
      "A": "To define deployment pipelines",
      "B": "To store reusable schema and parameter definitions",
      "C": "To handle authentication logic",
      "D": "To execute API calls"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Components promote reuse of schemas, parameters, and responses.",
      "incorrect": {
        "A": "Deployment is not covered by OAS.",
        "C": "Authentication is described, not implemented.",
        "D": "OAS does not execute APIs."
      }
    }
  },

  {
    "id": "CH02-0051",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Optional vs required",
    "difficulty": "Hard",
    "question": "Why should required fields be used carefully in API design?",
    "options": {
      "A": "They improve payload size",
      "B": "They increase risk of breaking changes",
      "C": "They simplify versioning",
      "D": "They reduce validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Changing required fields later can break existing consumers.",
      "incorrect": {
        "A": "Required fields may increase payload size.",
        "C": "Versioning becomes harder.",
        "D": "Validation becomes stricter, not reduced."
      }
    }
  },
  {
    "id": "CH02-0052",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Standardization",
    "difficulty": "Medium",
    "question": "Why should response structures be standardized across endpoints?",
    "options": {
      "A": "To reduce server performance",
      "B": "To simplify consumer integration and parsing",
      "C": "To eliminate documentation",
      "D": "To avoid reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standardized responses reduce complexity for consumers.",
      "incorrect": {
        "A": "Performance is not negatively impacted.",
        "C": "Documentation is still required.",
        "D": "Standardization supports reuse."
      }
    }
  },
  {
    "id": "CH02-0053",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Design",
    "subtopic": "Error codes",
    "difficulty": "Medium",
    "question": "Why should APIs define custom error codes in addition to HTTP status codes?",
    "options": {
      "A": "HTTP status codes are obsolete",
      "B": "Custom codes provide finer-grained error identification",
      "C": "They reduce payload size",
      "D": "They eliminate retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Custom error codes allow precise identification of error scenarios.",
      "incorrect": {
        "A": "HTTP status codes remain essential.",
        "C": "Payload size may increase.",
        "D": "Retries depend on error type."
      }
    }
  },
  {
    "id": "CH02-0054",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "API-first",
    "difficulty": "Medium",
    "question": "What distinguishes API-first from code-first design?",
    "options": {
      "A": "API-first skips documentation",
      "B": "API-first defines contracts before implementation",
      "C": "API-first eliminates testing",
      "D": "API-first avoids standards"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-first prioritizes contract definition before coding.",
      "incorrect": {
        "A": "Documentation is central to API-first.",
        "C": "Testing remains critical.",
        "D": "Standards are emphasized."
      }
    }
  },
  {
    "id": "CH02-0055",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Cursor-based",
    "difficulty": "Hard",
    "question": "What is a key advantage of cursor-based pagination?",
    "options": {
      "A": "Simpler implementation",
      "B": "Better performance for large datasets",
      "C": "Elimination of query parameters",
      "D": "Reduced documentation needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cursor-based pagination scales better for large and dynamic datasets.",
      "incorrect": {
        "A": "It is usually more complex.",
        "C": "Query parameters are still used.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0056",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Sorting",
    "subtopic": "Multiple fields",
    "difficulty": "Medium",
    "question": "How should APIs support sorting by multiple fields?",
    "options": {
      "A": "Separate endpoints per field",
      "B": "Comma-separated query parameters",
      "C": "Path parameters",
      "D": "Request headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Comma-separated values allow flexible multi-field sorting.",
      "incorrect": {
        "A": "This approach does not scale.",
        "C": "Paths should represent resources.",
        "D": "Headers are not suitable for sorting."
      }
    }
  },
  {
    "id": "CH02-0057",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Exposure minimization",
    "difficulty": "Hard",
    "question": "Why should APIs avoid exposing internal identifiers?",
    "options": {
      "A": "It improves performance",
      "B": "It reduces security and coupling risks",
      "C": "It eliminates versioning",
      "D": "It simplifies documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exposing internals increases security risk and tight coupling.",
      "incorrect": {
        "A": "Performance is not the main concern.",
        "C": "Versioning is unrelated.",
        "D": "Documentation is still required."
      }
    }
  },
  {
    "id": "CH02-0058",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Contract testing",
    "difficulty": "Medium",
    "question": "What is the primary goal of contract testing?",
    "options": {
      "A": "To test infrastructure",
      "B": "To ensure implementations adhere to API contracts",
      "C": "To eliminate mocks",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contract testing ensures implementations conform to defined contracts.",
      "incorrect": {
        "A": "Infrastructure testing is separate.",
        "C": "Mocks are still useful.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0059",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Usability",
    "subtopic": "Error messages",
    "difficulty": "Medium",
    "question": "What characteristic makes API error messages user-friendly?",
    "options": {
      "A": "Including stack traces",
      "B": "Clear, concise, and actionable messages",
      "C": "Using internal error codes only",
      "D": "Omitting error details"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear and actionable errors help clients resolve issues faster.",
      "incorrect": {
        "A": "Stack traces expose internals.",
        "C": "Internal codes alone are insufficient.",
        "D": "Omitting details reduces usability."
      }
    }
  },
  {
    "id": "CH02-0060",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Governance",
    "subtopic": "Review process",
    "difficulty": "Medium",
    "question": "Why are API design reviews important?",
    "options": {
      "A": "To delay delivery",
      "B": "To ensure quality, consistency, and compliance",
      "C": "To eliminate innovation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design reviews catch issues early and ensure standards compliance.",
      "incorrect": {
        "A": "Reviews improve long-term speed.",
        "C": "Standards enable innovation.",
        "D": "Documentation remains required."
      }
    }
  },

  {
    "id": "CH02-0061",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Deprecation",
    "difficulty": "Medium",
    "question": "Why should deprecated endpoints remain available for a transition period?",
    "options": {
      "A": "To increase maintenance cost",
      "B": "To give consumers time to migrate safely",
      "C": "To avoid versioning",
      "D": "To eliminate governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Grace periods reduce disruption for existing consumers.",
      "incorrect": {
        "A": "Maintenance cost is a trade-off.",
        "C": "Versioning is still required.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0062",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Consistency",
    "subtopic": "Naming",
    "difficulty": "Easy",
    "question": "Why should naming conventions be consistent across APIs?",
    "options": {
      "A": "They reduce payload size",
      "B": "They improve learnability and reduce errors",
      "C": "They eliminate documentation",
      "D": "They avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent naming makes APIs easier to learn and use.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Documentation is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0063",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Performance",
    "subtopic": "Payload size",
    "difficulty": "Medium",
    "question": "Why should API payload sizes be minimized?",
    "options": {
      "A": "To reduce documentation",
      "B": "To improve performance and network efficiency",
      "C": "To eliminate validation",
      "D": "To avoid security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Smaller payloads improve response times and efficiency.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Validation is still required.",
        "D": "Security remains critical."
      }
    }
  },
  {
    "id": "CH02-0064",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Least privilege",
    "difficulty": "Hard",
    "question": "How does the principle of least privilege apply to API design?",
    "options": {
      "A": "Expose all data by default",
      "B": "Limit access to only what consumers need",
      "C": "Avoid authentication",
      "D": "Use a single API key for all consumers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege reduces security risks by limiting access.",
      "incorrect": {
        "A": "Overexposure increases risk.",
        "C": "Authentication is essential.",
        "D": "Shared keys increase risk."
      }
    }
  },
  {
    "id": "CH02-0065",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Documentation",
    "subtopic": "Self-describing APIs",
    "difficulty": "Medium",
    "question": "What makes an API self-describing?",
    "options": {
      "A": "Hidden endpoints",
      "B": "Clear contracts, examples, and metadata",
      "C": "Minimal error handling",
      "D": "No versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Self-describing APIs clearly communicate usage through contracts and examples.",
      "incorrect": {
        "A": "Hidden endpoints reduce usability.",
        "C": "Error handling is critical.",
        "D": "Versioning is still required."
      }
    }
  },

  {
    "id": "CH02-0066",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Interoperability",
    "subtopic": "Standards",
    "difficulty": "Medium",
    "question": "Why is adherence to standards important for API interoperability?",
    "options": {
      "A": "It restricts flexibility",
      "B": "It enables easier integration across platforms",
      "C": "It eliminates governance",
      "D": "It avoids documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards ensure APIs work consistently across different systems.",
      "incorrect": {
        "A": "Standards enable controlled flexibility.",
        "C": "Governance relies on standards.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0067",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Onboarding",
    "difficulty": "Medium",
    "question": "What improves API consumer onboarding the most?",
    "options": {
      "A": "Hidden APIs",
      "B": "Clear documentation, examples, and consistent design",
      "C": "Minimal error messages",
      "D": "Complex authentication flows"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clarity and consistency significantly reduce onboarding friction.",
      "incorrect": {
        "A": "Hidden APIs reduce adoption.",
        "C": "Error clarity is important.",
        "D": "Unnecessary complexity hinders onboarding."
      }
    }
  },
  {
    "id": "CH02-0068",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Review",
    "subtopic": "Feedback loops",
    "difficulty": "Hard",
    "question": "Why are feedback loops critical in API design?",
    "options": {
      "A": "They slow down development",
      "B": "They help refine APIs based on real usage",
      "C": "They eliminate versioning",
      "D": "They avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Feedback ensures APIs evolve to meet real consumer needs.",
      "incorrect": {
        "A": "Feedback improves long-term speed.",
        "C": "Versioning is still required.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0069",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Reuse-first",
    "difficulty": "Medium",
    "question": "What does a reuse-first API strategy emphasize?",
    "options": {
      "A": "One-off implementations",
      "B": "Designing APIs for reuse across multiple use cases",
      "C": "Minimal documentation",
      "D": "Avoiding standards"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse-first maximizes long-term value of APIs.",
      "incorrect": {
        "A": "One-off designs reduce value.",
        "C": "Documentation is essential.",
        "D": "Standards enable reuse."
      }
    }
  },
  {
    "id": "CH02-0070",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Metrics",
    "subtopic": "Adoption",
    "difficulty": "Medium",
    "question": "Which metric best reflects API design success?",
    "options": {
      "A": "Lines of code",
      "B": "Number of consumers and reuse rate",
      "C": "Server CPU usage",
      "D": "Number of endpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High adoption and reuse indicate effective API design.",
      "incorrect": {
        "A": "Code size is not a success indicator.",
        "C": "CPU usage is operational.",
        "D": "Quantity does not equal quality."
      }
    }
  },

  {
    "id": "CH02-0071",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Contracts",
    "subtopic": "Clarity",
    "difficulty": "Medium",
    "question": "Why should API contracts be explicit rather than implicit?",
    "options": {
      "A": "To slow development",
      "B": "To avoid ambiguity and misinterpretation",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit contracts reduce misunderstandings and errors.",
      "incorrect": {
        "A": "Clarity speeds development.",
        "C": "Testing remains essential.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0072",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Extensibility",
    "subtopic": "Future-proofing",
    "difficulty": "Hard",
    "question": "Which design choice best supports future extensibility?",
    "options": {
      "A": "Using rigid schemas",
      "B": "Allowing optional fields and versioning",
      "C": "Embedding logic in URIs",
      "D": "Avoiding documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Optional fields and versioning allow safe evolution.",
      "incorrect": {
        "A": "Rigid schemas hinder evolution.",
        "C": "URIs should not contain logic.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0073",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Governance",
    "subtopic": "Design linting",
    "difficulty": "Medium",
    "question": "What is the purpose of API design linting?",
    "options": {
      "A": "To deploy APIs",
      "B": "To automatically detect design rule violations",
      "C": "To execute tests",
      "D": "To manage infrastructure"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Linting enforces standards early in the design phase.",
      "incorrect": {
        "A": "Deployment is separate.",
        "C": "Testing is different from linting.",
        "D": "Infrastructure is unrelated."
      }
    }
  },
  {
    "id": "CH02-0074",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Maturity",
    "subtopic": "Evolution readiness",
    "difficulty": "Medium",
    "question": "Which characteristic indicates a mature API design?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Clear versioning and backward compatibility",
      "C": "Minimal documentation",
      "D": "Tight coupling to backend systems"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mature APIs manage change through versioning and compatibility.",
      "incorrect": {
        "A": "Breaking changes indicate immaturity.",
        "C": "Documentation is critical.",
        "D": "Loose coupling is preferred."
      }
    }
  },
  {
    "id": "CH02-0075",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Input validation",
    "difficulty": "Hard",
    "question": "Why is strict input validation essential in API design?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent security vulnerabilities and data corruption",
      "C": "To eliminate authentication",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation protects APIs from malicious or malformed input.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Authentication is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },

  {
    "id": "CH02-0076",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Design considerations",
    "difficulty": "Medium",
    "question": "Why should observability be considered during API design?",
    "options": {
      "A": "It only matters at runtime",
      "B": "Design decisions affect logging and monitoring capabilities",
      "C": "It eliminates governance",
      "D": "It avoids documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Design choices influence how effectively APIs can be monitored.",
      "incorrect": {
        "A": "Observability starts at design.",
        "C": "Governance is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0077",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Design",
    "subtopic": "Coupling",
    "difficulty": "Hard",
    "question": "Which design practice best reduces consumer coupling?",
    "options": {
      "A": "Exposing database schemas",
      "B": "Using stable contracts and abstraction",
      "C": "Frequent breaking changes",
      "D": "Embedding logic in URIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts and abstraction protect consumers from backend changes.",
      "incorrect": {
        "A": "Database exposure increases coupling.",
        "C": "Breaking changes increase coupling.",
        "D": "URIs should remain simple."
      }
    }
  },
  {
    "id": "CH02-0078",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Long-term value",
    "difficulty": "Medium",
    "question": "Why should APIs be treated as long-term products?",
    "options": {
      "A": "They are easy to replace",
      "B": "They require ongoing evolution, support, and governance",
      "C": "They eliminate integration platforms",
      "D": "They reduce documentation needs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "APIs evolve continuously and require stewardship like products.",
      "incorrect": {
        "A": "Replacing APIs is costly.",
        "C": "Integration platforms remain important.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0079",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Outcomes",
    "subtopic": "Adoption barriers",
    "difficulty": "Medium",
    "question": "Which factor most commonly reduces API adoption?",
    "options": {
      "A": "Clear documentation",
      "B": "Inconsistent design and unclear contracts",
      "C": "Stable versioning",
      "D": "Strong governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Inconsistency and ambiguity discourage consumers.",
      "incorrect": {
        "A": "Clear documentation improves adoption.",
        "C": "Stable versioning builds trust.",
        "D": "Governance supports reliability."
      }
    }
  },
  {
    "id": "CH02-0080",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "API usability",
    "difficulty": "Hard",
    "question": "What ultimately defines an excellent API design?",
    "options": {
      "A": "Number of endpoints",
      "B": "Ease of use, consistency, and adaptability",
      "C": "Minimal security",
      "D": "Lack of governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Excellent APIs are easy to use, consistent, and adaptable over time.",
      "incorrect": {
        "A": "Quantity does not indicate quality.",
        "C": "Security is essential.",
        "D": "Governance enables excellence."
      }
    }
  },

  {
    "id": "CH02-0081",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Uniform interface",
    "difficulty": "Medium",
    "question": "What is the primary benefit of the uniform interface constraint in REST?",
    "options": {
      "A": "Improved database performance",
      "B": "Decoupling of client and server implementations",
      "C": "Automatic security enforcement",
      "D": "Elimination of versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "A uniform interface decouples clients from servers, allowing them to evolve independently.",
      "incorrect": {
        "A": "Database performance is unrelated.",
        "C": "Security must be implemented explicitly.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0082",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "PATCH usage",
    "difficulty": "Hard",
    "question": "In which scenario is PATCH preferred over PUT?",
    "options": {
      "A": "When replacing an entire resource",
      "B": "When partially updating a resource",
      "C": "When retrieving a resource",
      "D": "When deleting a resource"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PATCH is designed for partial updates to a resource.",
      "incorrect": {
        "A": "PUT replaces the full resource.",
        "C": "GET retrieves data.",
        "D": "DELETE removes resources."
      }
    }
  },
  {
    "id": "CH02-0083",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "409 Conflict",
    "difficulty": "Hard",
    "question": "When should an API return HTTP 409 Conflict?",
    "options": {
      "A": "When authentication fails",
      "B": "When a request conflicts with the current resource state",
      "C": "When the server is unavailable",
      "D": "When a resource is not found"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "409 is used when a request cannot be completed due to a conflict with the current state of the resource.",
      "incorrect": {
        "A": "Authentication failures return 401.",
        "C": "503 indicates server unavailability.",
        "D": "404 indicates missing resources."
      }
    }
  },
  {
    "id": "CH02-0084",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Verb avoidance",
    "difficulty": "Easy",
    "question": "Why should verbs be avoided in RESTful URIs?",
    "options": {
      "A": "They increase payload size",
      "B": "Actions are expressed via HTTP methods",
      "C": "They break caching",
      "D": "They reduce security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP methods define actions; URIs should represent resources.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Caching is not directly affected.",
        "D": "Security is unrelated."
      }
    }
  },
  {
    "id": "CH02-0085",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Filtering vs searching",
    "difficulty": "Medium",
    "question": "What distinguishes filtering from searching in APIs?",
    "options": {
      "A": "Filtering modifies server data",
      "B": "Filtering narrows results, searching matches patterns",
      "C": "Searching uses path parameters",
      "D": "Filtering eliminates pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering narrows result sets, while searching matches patterns or keywords.",
      "incorrect": {
        "A": "Neither modifies server data.",
        "C": "Both typically use query parameters.",
        "D": "Pagination still applies."
      }
    }
  },

  {
    "id": "CH02-0086",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Breaking changes",
    "difficulty": "Hard",
    "question": "Which change is considered a breaking change in APIs?",
    "options": {
      "A": "Adding a new optional field",
      "B": "Removing an existing endpoint",
      "C": "Adding documentation",
      "D": "Improving response descriptions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Removing endpoints breaks existing consumers relying on them.",
      "incorrect": {
        "A": "Optional additions are backward compatible.",
        "C": "Documentation does not affect behavior.",
        "D": "Descriptions do not break consumers."
      }
    }
  },
  {
    "id": "CH02-0087",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Headers",
    "subtopic": "ETag",
    "difficulty": "Hard",
    "question": "What is the primary purpose of the ETag header?",
    "options": {
      "A": "Authentication",
      "B": "Optimistic concurrency control and caching",
      "C": "Content negotiation",
      "D": "Routing requests"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ETags support caching and concurrency control by identifying resource versions.",
      "incorrect": {
        "A": "Authentication uses Authorization headers.",
        "C": "Content negotiation uses Accept headers.",
        "D": "Routing is handled differently."
      }
    }
  },
  {
    "id": "CH02-0088",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Security schemes",
    "difficulty": "Medium",
    "question": "What is the purpose of securitySchemes in RAML?",
    "options": {
      "A": "To define deployment strategies",
      "B": "To describe authentication mechanisms",
      "C": "To execute security logic",
      "D": "To manage runtime policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "securitySchemes describe how APIs are secured, such as OAuth or Basic Auth.",
      "incorrect": {
        "A": "Deployment is outside RAML scope.",
        "C": "RAML does not execute logic.",
        "D": "Runtime policies are applied elsewhere."
      }
    }
  },
  {
    "id": "CH02-0089",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Examples vs schemas",
    "difficulty": "Medium",
    "question": "How do examples differ from schemas in API specifications?",
    "options": {
      "A": "Examples enforce validation rules",
      "B": "Schemas define structure, examples illustrate usage",
      "C": "Schemas are optional, examples are mandatory",
      "D": "Examples replace schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Schemas define structure, while examples demonstrate real usage.",
      "incorrect": {
        "A": "Schemas enforce structure.",
        "C": "Neither is universally mandatory.",
        "D": "They complement each other."
      }
    }
  },
  {
    "id": "CH02-0090",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Paths object",
    "difficulty": "Medium",
    "question": "What does the Paths object represent in OpenAPI?",
    "options": {
      "A": "Server configuration",
      "B": "Available API endpoints and operations",
      "C": "Authentication rules",
      "D": "Deployment pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Paths define endpoints and supported HTTP operations.",
      "incorrect": {
        "A": "Servers are defined separately.",
        "C": "Authentication is defined via security schemes.",
        "D": "Deployment is outside OAS scope."
      }
    }
  },

  {
    "id": "CH02-0091",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Enum usage",
    "difficulty": "Medium",
    "question": "Why should enums be used in API data models?",
    "options": {
      "A": "To reduce payload size only",
      "B": "To restrict values and improve data consistency",
      "C": "To eliminate validation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enums restrict allowed values, improving consistency and validation.",
      "incorrect": {
        "A": "Consistency is the main benefit.",
        "C": "Enums enforce validation.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0092",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "HTTP semantics",
    "difficulty": "Medium",
    "question": "Why should APIs rely on HTTP status codes instead of embedding status in response bodies?",
    "options": {
      "A": "It reduces payload size",
      "B": "It aligns with HTTP semantics and tooling",
      "C": "It eliminates error handling",
      "D": "It avoids versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Using HTTP status codes leverages built-in client and tooling behavior.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Error handling is still needed.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0093",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Retry semantics",
    "difficulty": "Hard",
    "question": "Which error response is typically safe to retry automatically?",
    "options": {
      "A": "400 Bad Request",
      "B": "500 Internal Server Error",
      "C": "401 Unauthorized",
      "D": "403 Forbidden"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "500 errors indicate server issues that may succeed on retry.",
      "incorrect": {
        "A": "400 indicates client errors.",
        "C": "401 requires authentication changes.",
        "D": "403 requires permission changes."
      }
    }
  },
  {
    "id": "CH02-0094",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Consistency across APIs",
    "difficulty": "Medium",
    "question": "Why is cross-API consistency important in large organizations?",
    "options": {
      "A": "It reduces innovation",
      "B": "It lowers learning curves for consumers",
      "C": "It eliminates governance",
      "D": "It avoids reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent APIs are easier to learn and adopt across teams.",
      "incorrect": {
        "A": "Consistency enables innovation at scale.",
        "C": "Governance supports consistency.",
        "D": "Consistency encourages reuse."
      }
    }
  },
  {
    "id": "CH02-0095",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Metadata",
    "difficulty": "Medium",
    "question": "What pagination metadata is most useful to clients?",
    "options": {
      "A": "Database table names",
      "B": "Links or cursors for next and previous pages",
      "C": "Server hostname",
      "D": "Internal IDs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Navigation links or cursors help clients traverse result sets.",
      "incorrect": {
        "A": "Internal details should not be exposed.",
        "C": "Hostname is irrelevant.",
        "D": "Internal IDs are not helpful."
      }
    }
  },

  {
    "id": "CH02-0096",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Overexposure",
    "difficulty": "Hard",
    "question": "What is a common risk of overexposing API data?",
    "options": {
      "A": "Improved usability",
      "B": "Increased attack surface and data leakage",
      "C": "Simpler versioning",
      "D": "Reduced maintenance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Exposing excessive data increases security and privacy risks.",
      "incorrect": {
        "A": "Usability does not justify risk.",
        "C": "Versioning becomes harder.",
        "D": "Maintenance often increases."
      }
    }
  },
  {
    "id": "CH02-0097",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Documentation",
    "subtopic": "Living documentation",
    "difficulty": "Medium",
    "question": "What is meant by living API documentation?",
    "options": {
      "A": "Documentation written once and archived",
      "B": "Documentation that evolves with the API",
      "C": "Documentation generated only at runtime",
      "D": "Documentation without examples"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Living documentation stays aligned with API evolution.",
      "incorrect": {
        "A": "Static docs become outdated.",
        "C": "Runtime-only docs are insufficient.",
        "D": "Examples are essential."
      }
    }
  },
  {
    "id": "CH02-0098",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Governance",
    "subtopic": "Design standards",
    "difficulty": "Medium",
    "question": "What is the primary goal of API design standards?",
    "options": {
      "A": "To restrict teams",
      "B": "To ensure quality, consistency, and interoperability",
      "C": "To eliminate documentation",
      "D": "To avoid reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards ensure APIs are predictable and interoperable.",
      "incorrect": {
        "A": "Standards enable teams to scale.",
        "C": "Documentation is still required.",
        "D": "Reuse is encouraged."
      }
    }
  },
  {
    "id": "CH02-0099",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Error discoverability",
    "difficulty": "Hard",
    "question": "Why should APIs make errors easily discoverable?",
    "options": {
      "A": "To expose internal logic",
      "B": "To help clients detect and fix issues quickly",
      "C": "To reduce security",
      "D": "To avoid validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear error reporting speeds troubleshooting and reduces friction.",
      "incorrect": {
        "A": "Internals should not be exposed.",
        "C": "Security must not be reduced.",
        "D": "Validation remains essential."
      }
    }
  },
  {
    "id": "CH02-0100",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Outcomes",
    "subtopic": "Consumer trust",
    "difficulty": "Hard",
    "question": "What most directly builds long-term consumer trust in APIs?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Stable contracts, clear documentation, and predictable behavior",
      "C": "Minimal governance",
      "D": "Hidden error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Trust is built through stability, clarity, and predictability.",
      "incorrect": {
        "A": "Breaking changes erode trust.",
        "C": "Governance supports reliability.",
        "D": "Hidden behavior reduces confidence."
      }
    }
  },

  {
    "id": "CH02-0101",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Maturity",
    "subtopic": "Scalability",
    "difficulty": "Medium",
    "question": "Why is scalability an important consideration during API design?",
    "options": {
      "A": "To eliminate documentation",
      "B": "To ensure APIs can handle growth in consumers and traffic",
      "C": "To avoid reuse",
      "D": "To reduce governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Scalable APIs can support increasing demand without redesign.",
      "incorrect": {
        "A": "Documentation is still required.",
        "C": "Reuse improves scalability.",
        "D": "Governance is still necessary."
      }
    }
  },
  {
    "id": "CH02-0102",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Constraints",
    "subtopic": "Layered system",
    "difficulty": "Medium",
    "question": "What benefit does the layered system constraint provide?",
    "options": {
      "A": "Improved payload size",
      "B": "Abstraction of underlying system complexity",
      "C": "Elimination of versioning",
      "D": "Automatic caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Layering hides internal complexity and enables intermediaries.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning is still required.",
        "D": "Caching is separate."
      }
    }
  },
  {
    "id": "CH02-0103",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Business alignment",
    "difficulty": "Medium",
    "question": "Why must API design align with business capabilities?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure APIs expose meaningful, reusable business functions",
      "C": "To eliminate documentation",
      "D": "To avoid security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Business-aligned APIs deliver long-term value and reuse.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Documentation remains essential.",
        "D": "Security is critical."
      }
    }
  },
  {
    "id": "CH02-0104",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Longevity",
    "difficulty": "Hard",
    "question": "What design quality most contributes to API longevity?",
    "options": {
      "A": "Tight coupling to backend systems",
      "B": "Loose coupling and backward compatibility",
      "C": "Minimal documentation",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling and compatibility allow APIs to evolve over time.",
      "incorrect": {
        "A": "Tight coupling reduces lifespan.",
        "C": "Documentation is essential.",
        "D": "Breaking changes shorten lifespan."
      }
    }
  },
  {
    "id": "CH02-0105",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Simplicity",
    "difficulty": "Easy",
    "question": "Why is simplicity important in API design?",
    "options": {
      "A": "It limits functionality",
      "B": "It reduces learning curve and integration effort",
      "C": "It eliminates governance",
      "D": "It avoids documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Simple APIs are easier to understand, adopt, and maintain.",
      "incorrect": {
        "A": "Simplicity improves usability.",
        "C": "Governance is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0106",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Design",
    "subtopic": "Abstraction",
    "difficulty": "Medium",
    "question": "What role does abstraction play in API design?",
    "options": {
      "A": "It exposes internal logic",
      "B": "It hides implementation details from consumers",
      "C": "It reduces validation",
      "D": "It eliminates versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Abstraction protects consumers from internal changes.",
      "incorrect": {
        "A": "Internals should not be exposed.",
        "C": "Validation remains necessary.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0107",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Lifecycle",
    "subtopic": "Deprecation strategy",
    "difficulty": "Hard",
    "question": "What is a best practice for API deprecation?",
    "options": {
      "A": "Immediate removal",
      "B": "Clear communication and migration period",
      "C": "Silent changes",
      "D": "Avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deprecation should be communicated clearly with adequate transition time.",
      "incorrect": {
        "A": "Immediate removal breaks consumers.",
        "C": "Silent changes erode trust.",
        "D": "Versioning supports deprecation."
      }
    }
  },
  {
    "id": "CH02-0108",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Predictability",
    "difficulty": "Medium",
    "question": "How does predictable API behavior benefit consumers?",
    "options": {
      "A": "It increases debugging effort",
      "B": "It reduces unexpected failures and integration cost",
      "C": "It eliminates testing",
      "D": "It avoids governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictability lowers risk and integration complexity.",
      "incorrect": {
        "A": "Debugging effort is reduced.",
        "C": "Testing remains necessary.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0109",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Enterprise APIs",
    "subtopic": "Reuse enablement",
    "difficulty": "Medium",
    "question": "Which design choice most encourages API reuse?",
    "options": {
      "A": "Narrow, project-specific endpoints",
      "B": "Generic, well-documented business capabilities",
      "C": "Hidden documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable business capabilities maximize API value.",
      "incorrect": {
        "A": "Project-specific designs limit reuse.",
        "C": "Hidden docs reduce reuse.",
        "D": "Tight coupling discourages reuse."
      }
    }
  },
  {
    "id": "CH02-0110",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Governance",
    "subtopic": "Automation",
    "difficulty": "Medium",
    "question": "Why is automated API design governance important?",
    "options": {
      "A": "To slow delivery",
      "B": "To enforce standards consistently at scale",
      "C": "To eliminate human oversight",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistent enforcement without bottlenecks.",
      "incorrect": {
        "A": "Automation improves speed.",
        "C": "Human oversight is still required.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0111",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Outcomes",
    "subtopic": "Integration cost",
    "difficulty": "Medium",
    "question": "How does good API design impact integration cost?",
    "options": {
      "A": "It increases long-term cost",
      "B": "It reduces cost through reuse and simplicity",
      "C": "It eliminates maintenance",
      "D": "It avoids security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reusable and simple APIs reduce development and maintenance costs.",
      "incorrect": {
        "A": "Costs are reduced, not increased.",
        "C": "Maintenance is still required.",
        "D": "Security remains critical."
      }
    }
  },
  {
    "id": "CH02-0112",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Minor vs major versions",
    "difficulty": "Hard",
    "question": "What typically justifies a major API version change?",
    "options": {
      "A": "Documentation updates",
      "B": "Breaking changes affecting existing consumers",
      "C": "Performance optimizations",
      "D": "Adding optional fields"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Major versions signal breaking changes.",
      "incorrect": {
        "A": "Docs do not require new versions.",
        "C": "Optimizations can be backward compatible.",
        "D": "Optional fields are non-breaking."
      }
    }
  },
  {
    "id": "CH02-0113",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Authentication vs authorization",
    "difficulty": "Medium",
    "question": "What is the difference between authentication and authorization?",
    "options": {
      "A": "They are the same",
      "B": "Authentication verifies identity, authorization verifies access rights",
      "C": "Authorization happens before authentication",
      "D": "Authentication eliminates authorization"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Authentication identifies who you are; authorization determines what you can do.",
      "incorrect": {
        "A": "They are distinct concepts.",
        "C": "Authentication comes first.",
        "D": "Authorization is still required."
      }
    }
  },
  {
    "id": "CH02-0114",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Consistency of errors",
    "difficulty": "Medium",
    "question": "Why should error responses be consistent across all endpoints?",
    "options": {
      "A": "To expose internal logic",
      "B": "To simplify client-side error handling",
      "C": "To reduce payload size",
      "D": "To avoid validation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency allows clients to handle errors uniformly.",
      "incorrect": {
        "A": "Internals should not be exposed.",
        "C": "Payload size is secondary.",
        "D": "Validation remains essential."
      }
    }
  },
  {
    "id": "CH02-0115",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "API as product",
    "difficulty": "Hard",
    "question": "What does treating an API as a product imply?",
    "options": {
      "A": "Building it once and forgetting it",
      "B": "Ongoing investment in usability, documentation, and support",
      "C": "Eliminating governance",
      "D": "Avoiding feedback"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product thinking emphasizes lifecycle management and consumer experience.",
      "incorrect": {
        "A": "APIs require ongoing care.",
        "C": "Governance remains necessary.",
        "D": "Feedback is essential."
      }
    }
  },
  {
    "id": "CH02-0116",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Backward compatibility",
    "difficulty": "Hard",
    "question": "Why is backward compatibility critical in enterprise APIs?",
    "options": {
      "A": "To slow innovation",
      "B": "To protect existing consumers from disruption",
      "C": "To eliminate versioning",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Backward compatibility minimizes breaking changes for consumers.",
      "incorrect": {
        "A": "Innovation can still continue.",
        "C": "Versioning supports compatibility.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0117",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit contracts",
    "difficulty": "Medium",
    "question": "Why should API contracts be explicit rather than inferred?",
    "options": {
      "A": "To increase ambiguity",
      "B": "To reduce misunderstandings between providers and consumers",
      "C": "To eliminate testing",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit contracts remove ambiguity and align expectations.",
      "incorrect": {
        "A": "Ambiguity increases errors.",
        "C": "Testing remains necessary.",
        "D": "Documentation is still required."
      }
    }
  },
  {
    "id": "CH02-0118",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Design reviews",
    "difficulty": "Medium",
    "question": "What is the main outcome of effective API design reviews?",
    "options": {
      "A": "Delayed releases",
      "B": "Higher quality, more consistent APIs",
      "C": "Elimination of documentation",
      "D": "Reduced reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reviews catch issues early and improve consistency.",
      "incorrect": {
        "A": "Reviews improve long-term speed.",
        "C": "Documentation is still required.",
        "D": "Reuse is encouraged."
      }
    }
  },
  {
    "id": "CH02-0119",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Enterprise scale",
    "difficulty": "Hard",
    "question": "What enables API programs to scale across large enterprises?",
    "options": {
      "A": "Ad-hoc designs",
      "B": "Standardized design, governance, and reuse",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standards and governance enable consistent scaling.",
      "incorrect": {
        "A": "Ad-hoc designs do not scale.",
        "C": "Documentation is essential.",
        "D": "Tight coupling limits scale."
      }
    }
  },
  {
    "id": "CH02-0120",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Sustainable APIs",
    "difficulty": "Hard",
    "question": "What characterizes a sustainable API design?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Loose coupling, reuse, and governed evolution",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainable APIs balance flexibility, reuse, and governance.",
      "incorrect": {
        "A": "Breaking changes reduce sustainability.",
        "C": "Security is essential.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0121",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Client-server separation",
    "difficulty": "Medium",
    "question": "What benefit does the client-server constraint provide in REST architecture?",
    "options": {
      "A": "Improved database normalization",
      "B": "Independent evolution of client and server",
      "C": "Automatic caching",
      "D": "Elimination of security concerns"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client-server separation allows UI and backend to evolve independently without tight coupling.",
      "incorrect": {
        "A": "Database design is unrelated.",
        "C": "Caching is a separate constraint.",
        "D": "Security must still be designed explicitly."
      }
    }
  },
  {
    "id": "CH02-0122",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "HEAD usage",
    "difficulty": "Medium",
    "question": "What is the primary purpose of the HTTP HEAD method?",
    "options": {
      "A": "To retrieve a resource body",
      "B": "To retrieve headers without the response body",
      "C": "To partially update a resource",
      "D": "To delete metadata"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HEAD returns the same headers as GET but without the body, useful for metadata checks.",
      "incorrect": {
        "A": "GET retrieves the body.",
        "C": "PATCH is for updates.",
        "D": "DELETE removes resources."
      }
    }
  },
  {
    "id": "CH02-0123",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "422 Unprocessable Entity",
    "difficulty": "Hard",
    "question": "When is HTTP 422 Unprocessable Entity most appropriate?",
    "options": {
      "A": "Malformed JSON syntax",
      "B": "Valid request syntax but semantic validation failure",
      "C": "Authentication failure",
      "D": "Resource not found"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "422 is used when syntax is valid but business or semantic rules fail.",
      "incorrect": {
        "A": "400 is more appropriate for syntax errors.",
        "C": "401 indicates authentication issues.",
        "D": "404 indicates missing resources."
      }
    }
  },
  {
    "id": "CH02-0124",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Case sensitivity",
    "difficulty": "Easy",
    "question": "Why are lowercase URIs recommended in REST APIs?",
    "options": {
      "A": "They improve performance",
      "B": "They avoid ambiguity and platform inconsistencies",
      "C": "They reduce payload size",
      "D": "They eliminate versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Lowercase URIs avoid confusion caused by case sensitivity differences across systems.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Payload size is unrelated.",
        "D": "Versioning is independent."
      }
    }
  },
  {
    "id": "CH02-0125",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Default values",
    "difficulty": "Medium",
    "question": "Why should APIs define default values for optional query parameters?",
    "options": {
      "A": "To reduce documentation",
      "B": "To ensure predictable behavior",
      "C": "To eliminate validation",
      "D": "To avoid pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defaults ensure consistent behavior when parameters are omitted.",
      "incorrect": {
        "A": "Documentation is still required.",
        "C": "Validation remains necessary.",
        "D": "Pagination is unrelated."
      }
    }
  },

  {
    "id": "CH02-0126",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Media type versioning",
    "difficulty": "Hard",
    "question": "What is media type versioning in APIs?",
    "options": {
      "A": "Versioning via URI path",
      "B": "Embedding version information in the Content-Type or Accept header",
      "C": "Using query parameters for versioning",
      "D": "Using separate domains per version"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Media type versioning encodes version info in headers like Accept.",
      "incorrect": {
        "A": "That is URI versioning.",
        "C": "Query versioning is a different approach.",
        "D": "Domains are rarely used for versioning."
      }
    }
  },
  {
    "id": "CH02-0127",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "Cacheability",
    "difficulty": "Medium",
    "question": "Which response is safest to mark as cacheable by default?",
    "options": {
      "A": "GET",
      "B": "POST",
      "C": "PATCH",
      "D": "DELETE"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "GET responses are safe and ideal for caching.",
      "incorrect": {
        "B": "POST modifies state.",
        "C": "PATCH modifies state.",
        "D": "DELETE modifies state."
      }
    }
  },
  {
    "id": "CH02-0128",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "BaseUriParameters",
    "difficulty": "Medium",
    "question": "What are baseUriParameters used for in RAML?",
    "options": {
      "A": "Defining query parameters",
      "B": "Parameterizing parts of the base URI",
      "C": "Handling authentication",
      "D": "Defining response schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "baseUriParameters allow variables such as version or environment in the base URI.",
      "incorrect": {
        "A": "Query parameters are defined elsewhere.",
        "C": "Authentication is defined via securitySchemes.",
        "D": "Schemas define payload structure."
      }
    }
  },
  {
    "id": "CH02-0129",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Resource nesting",
    "difficulty": "Medium",
    "question": "Why should deep resource nesting be avoided in API design?",
    "options": {
      "A": "It improves discoverability",
      "B": "It increases complexity and reduces usability",
      "C": "It eliminates pagination",
      "D": "It improves security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deep nesting makes APIs harder to understand and maintain.",
      "incorrect": {
        "A": "Deep nesting harms discoverability.",
        "C": "Pagination is unrelated.",
        "D": "Security is not improved by nesting."
      }
    }
  },
  {
    "id": "CH02-0130",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Servers object",
    "difficulty": "Medium",
    "question": "What does the servers object define in OpenAPI?",
    "options": {
      "A": "Security configuration",
      "B": "API endpoint base URLs",
      "C": "Response schemas",
      "D": "Deployment pipelines"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Servers define base URLs where the API is hosted.",
      "incorrect": {
        "A": "Security is defined elsewhere.",
        "C": "Schemas define data models.",
        "D": "Deployment is not part of OAS."
      }
    }
  },

  {
    "id": "CH02-0131",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Nullable fields",
    "difficulty": "Hard",
    "question": "Why should nullable fields be clearly defined in API schemas?",
    "options": {
      "A": "To reduce payload size",
      "B": "To avoid ambiguity in consumer implementations",
      "C": "To eliminate versioning",
      "D": "To improve performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit nullability avoids misinterpretation of missing vs null values.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning is still required.",
        "D": "Performance impact is minimal."
      }
    }
  },
  {
    "id": "CH02-0132",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Hypermedia links",
    "difficulty": "Hard",
    "question": "What is the main advantage of including hypermedia links in responses?",
    "options": {
      "A": "Reduced payload size",
      "B": "Improved client navigation and discoverability",
      "C": "Elimination of documentation",
      "D": "Avoidance of versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hypermedia guides clients dynamically through available actions.",
      "incorrect": {
        "A": "Payload size may increase.",
        "C": "Documentation is still needed.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0133",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Error categorization",
    "difficulty": "Medium",
    "question": "Why should API errors be categorized (client vs server)?",
    "options": {
      "A": "To simplify server logs",
      "B": "To guide clients on corrective actions",
      "C": "To reduce security",
      "D": "To avoid retries"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Categorization helps clients understand responsibility and next steps.",
      "incorrect": {
        "A": "Logs are secondary.",
        "C": "Security must not be reduced.",
        "D": "Retries depend on error type."
      }
    }
  },
  {
    "id": "CH02-0134",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Standard error format",
    "difficulty": "Medium",
    "question": "What is the benefit of a standardized error response format?",
    "options": {
      "A": "Reduced payload size",
      "B": "Simplified client-side error parsing",
      "C": "Elimination of HTTP status codes",
      "D": "Improved database performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standard formats allow clients to handle errors consistently.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "HTTP status codes are still required.",
        "D": "Database performance is unrelated."
      }
    }
  },
  {
    "id": "CH02-0135",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Limit safeguards",
    "difficulty": "Medium",
    "question": "Why should APIs enforce maximum limits on pagination?",
    "options": {
      "A": "To reduce usability",
      "B": "To protect system performance and stability",
      "C": "To eliminate reuse",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limits prevent excessive resource consumption and abuse.",
      "incorrect": {
        "A": "Usability is preserved with reasonable limits.",
        "C": "Reuse is unaffected.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0136",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Sensitive data masking",
    "difficulty": "Hard",
    "question": "Why should sensitive data be masked or omitted in API responses?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent data leaks and compliance violations",
      "C": "To improve performance",
      "D": "To eliminate authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Masking protects against accidental exposure and regulatory issues.",
      "incorrect": {
        "A": "Security is the primary concern.",
        "C": "Performance impact is minimal.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH02-0137",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Documentation",
    "subtopic": "Examples completeness",
    "difficulty": "Medium",
    "question": "Why should API examples include both success and error cases?",
    "options": {
      "A": "To increase documentation length",
      "B": "To set correct consumer expectations",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Examples help consumers understand all possible outcomes.",
      "incorrect": {
        "A": "Length is not the goal.",
        "C": "Testing remains necessary.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0138",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Governance",
    "subtopic": "Design-time checks",
    "difficulty": "Medium",
    "question": "What is the main benefit of design-time API checks?",
    "options": {
      "A": "Runtime optimization",
      "B": "Early detection of issues before implementation",
      "C": "Elimination of runtime policies",
      "D": "Avoidance of documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early checks reduce costly rework later.",
      "incorrect": {
        "A": "Runtime optimization is separate.",
        "C": "Policies are still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0139",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Discoverability",
    "difficulty": "Medium",
    "question": "What improves API discoverability the most?",
    "options": {
      "A": "Hidden endpoints",
      "B": "Clear naming, documentation, and catalogs",
      "C": "Tight coupling",
      "D": "Minimal governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear naming and catalogs help consumers find and reuse APIs.",
      "incorrect": {
        "A": "Hidden endpoints reduce discoverability.",
        "C": "Tight coupling discourages reuse.",
        "D": "Governance supports discoverability."
      }
    }
  },
  {
    "id": "CH02-0140",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Consumer experience",
    "difficulty": "Hard",
    "question": "Which factor most directly improves overall API consumer experience?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Consistency, clarity, and predictable behavior",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Good consumer experience is driven by clarity, consistency, and reliability.",
      "incorrect": {
        "A": "Breaking changes harm experience.",
        "C": "Security is essential.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0141",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit constraints",
    "difficulty": "Medium",
    "question": "Why should API constraints be explicitly documented?",
    "options": {
      "A": "To reduce payload size",
      "B": "To avoid assumptions by consumers",
      "C": "To eliminate validation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit constraints prevent incorrect assumptions and misuse.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation remains required.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0142",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Change communication",
    "difficulty": "Medium",
    "question": "Why is proactive communication of API changes critical?",
    "options": {
      "A": "To reduce documentation",
      "B": "To allow consumers to plan and adapt",
      "C": "To eliminate governance",
      "D": "To avoid security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Advance notice reduces disruption for consumers.",
      "incorrect": {
        "A": "Documentation is still needed.",
        "C": "Governance remains essential.",
        "D": "Security remains critical."
      }
    }
  },
  {
    "id": "CH02-0143",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Robustness",
    "difficulty": "Hard",
    "question": "What contributes most to a robust API design?",
    "options": {
      "A": "Minimal validation",
      "B": "Clear contracts, validation, and error handling",
      "C": "Hidden logic",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Robust APIs handle errors gracefully and enforce contracts.",
      "incorrect": {
        "A": "Minimal validation increases risk.",
        "C": "Hidden logic reduces clarity.",
        "D": "Breaking changes reduce robustness."
      }
    }
  },
  {
    "id": "CH02-0144",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Lifecycle",
    "subtopic": "Retirement",
    "difficulty": "Medium",
    "question": "When should an API be retired?",
    "options": {
      "A": "Immediately after deprecation",
      "B": "After consumers have migrated to alternatives",
      "C": "Without notification",
      "D": "Before documentation updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retirement should occur only after safe migration.",
      "incorrect": {
        "A": "Immediate removal breaks consumers.",
        "C": "Notification is essential.",
        "D": "Documentation should be updated first."
      }
    }
  },
  {
    "id": "CH02-0145",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Metrics",
    "subtopic": "Error rates",
    "difficulty": "Medium",
    "question": "What can consistently high client error rates indicate?",
    "options": {
      "A": "Excellent API design",
      "B": "Poor usability or unclear contracts",
      "C": "Strong governance",
      "D": "Optimal performance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High client errors often point to confusing or poorly documented APIs.",
      "incorrect": {
        "A": "Errors indicate problems, not excellence.",
        "C": "Governance alone does not cause errors.",
        "D": "Performance is unrelated."
      }
    }
  },

  {
    "id": "CH02-0146",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Enterprise APIs",
    "subtopic": "Standard vocabularies",
    "difficulty": "Medium",
    "question": "Why should enterprise APIs use a standard business vocabulary?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure shared understanding across teams",
      "C": "To eliminate versioning",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shared vocabulary reduces misinterpretation and rework.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0147",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Consistency",
    "subtopic": "Cross-team alignment",
    "difficulty": "Medium",
    "question": "How does consistent API design benefit cross-team collaboration?",
    "options": {
      "A": "It reduces autonomy",
      "B": "It enables teams to integrate faster with fewer surprises",
      "C": "It eliminates governance",
      "D": "It avoids reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency lowers integration friction between teams.",
      "incorrect": {
        "A": "Consistency supports autonomy.",
        "C": "Governance remains essential.",
        "D": "Reuse is encouraged."
      }
    }
  },
  {
    "id": "CH02-0148",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Learning curve",
    "difficulty": "Easy",
    "question": "What reduces the learning curve for new API consumers?",
    "options": {
      "A": "Complex authentication",
      "B": "Clear documentation and consistent patterns",
      "C": "Hidden examples",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clarity and consistency make APIs easier to learn.",
      "incorrect": {
        "A": "Complexity increases the learning curve.",
        "C": "Hidden examples reduce clarity.",
        "D": "Breaking changes confuse consumers."
      }
    }
  },
  {
    "id": "CH02-0149",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Reuse economics",
    "difficulty": "Hard",
    "question": "Why does API reuse significantly improve ROI?",
    "options": {
      "A": "It increases development cost",
      "B": "It reduces duplicated development effort",
      "C": "It eliminates maintenance",
      "D": "It avoids governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse spreads development cost across many consumers.",
      "incorrect": {
        "A": "Costs are reduced, not increased.",
        "C": "Maintenance is still required.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0150",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Future readiness",
    "difficulty": "Hard",
    "question": "Which design practice best prepares APIs for future requirements?",
    "options": {
      "A": "Tight coupling to backend",
      "B": "Loose coupling, extensibility, and versioning",
      "C": "Minimal documentation",
      "D": "Hidden error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling and extensibility allow APIs to evolve safely.",
      "incorrect": {
        "A": "Tight coupling limits evolution.",
        "C": "Documentation is essential.",
        "D": "Hidden behavior reduces trust."
      }
    }
  },

  {
    "id": "CH02-0151",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Consumer feedback",
    "difficulty": "Medium",
    "question": "Why should consumer feedback be incorporated early in API design?",
    "options": {
      "A": "To delay delivery",
      "B": "To validate assumptions and reduce rework",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early feedback helps catch issues before costly implementation.",
      "incorrect": {
        "A": "Feedback improves long-term speed.",
        "C": "Governance remains essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0152",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Consistency checks",
    "difficulty": "Medium",
    "question": "What is the goal of automated consistency checks in API governance?",
    "options": {
      "A": "To slow development",
      "B": "To ensure APIs conform to standards at scale",
      "C": "To eliminate reviews",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures standards are consistently enforced.",
      "incorrect": {
        "A": "Automation improves speed.",
        "C": "Human reviews are still valuable.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0153",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Central catalog",
    "difficulty": "Medium",
    "question": "Why is a central API catalog important in enterprises?",
    "options": {
      "A": "To hide APIs",
      "B": "To improve discoverability and reuse",
      "C": "To eliminate versioning",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Catalogs help teams find and reuse existing APIs.",
      "incorrect": {
        "A": "Hiding APIs reduces reuse.",
        "C": "Versioning remains necessary.",
        "D": "Governance relies on catalogs."
      }
    }
  },
  {
    "id": "CH02-0154",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Maintainability",
    "difficulty": "Medium",
    "question": "Which design choice most improves API maintainability?",
    "options": {
      "A": "Hardcoded logic",
      "B": "Clear contracts and modular design",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear contracts and modularity simplify maintenance.",
      "incorrect": {
        "A": "Hardcoding reduces maintainability.",
        "C": "Documentation is essential.",
        "D": "Tight coupling increases maintenance cost."
      }
    }
  },
  {
    "id": "CH02-0155",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Fail-fast",
    "difficulty": "Hard",
    "question": "What does the fail-fast principle mean in API design?",
    "options": {
      "A": "Crash the server immediately",
      "B": "Detect and report errors as early as possible",
      "C": "Eliminate validation",
      "D": "Avoid error messages"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fail-fast helps identify issues early, reducing downstream impact.",
      "incorrect": {
        "A": "Servers should not crash.",
        "C": "Validation is required.",
        "D": "Clear error messages are essential."
      }
    }
  },

  {
    "id": "CH02-0156",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Rate limiting",
    "difficulty": "Medium",
    "question": "Why should APIs support rate limiting?",
    "options": {
      "A": "To reduce documentation",
      "B": "To protect APIs from abuse and ensure fair usage",
      "C": "To eliminate authentication",
      "D": "To avoid pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limiting prevents abuse and protects system stability.",
      "incorrect": {
        "A": "Documentation is unrelated.",
        "C": "Authentication is still required.",
        "D": "Pagination is unrelated."
      }
    }
  },
  {
    "id": "CH02-0157",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Correlation IDs",
    "difficulty": "Hard",
    "question": "Why should APIs support correlation IDs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To trace requests across distributed systems",
      "C": "To eliminate logging",
      "D": "To avoid security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs help trace and debug requests across services.",
      "incorrect": {
        "A": "Payload size is minimal impact.",
        "C": "Logging is still required.",
        "D": "Security remains essential."
      }
    }
  },
  {
    "id": "CH02-0158",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Change management",
    "difficulty": "Medium",
    "question": "Why is change management critical in API programs?",
    "options": {
      "A": "To slow innovation",
      "B": "To minimize disruption to consumers",
      "C": "To eliminate versioning",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Managing change protects consumers and maintains trust.",
      "incorrect": {
        "A": "Good change management enables innovation.",
        "C": "Versioning supports change management.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0159",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Success factors",
    "difficulty": "Medium",
    "question": "Which factor is most critical for long-term API program success?",
    "options": {
      "A": "One-time delivery",
      "B": "Strong governance, reuse, and consumer focus",
      "C": "Minimal documentation",
      "D": "Hidden APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Successful programs balance governance, reuse, and consumer needs.",
      "incorrect": {
        "A": "APIs require ongoing management.",
        "C": "Documentation is essential.",
        "D": "Hidden APIs reduce value."
      }
    }
  },
  {
    "id": "CH02-0160",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Enterprise readiness",
    "difficulty": "Hard",
    "question": "What makes an API enterprise-ready?",
    "options": {
      "A": "Minimal security",
      "B": "Governance, scalability, security, and reuse",
      "C": "Tight coupling",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enterprise-ready APIs are secure, scalable, governed, and reusable.",
      "incorrect": {
        "A": "Security must be strong.",
        "C": "Tight coupling limits enterprise use.",
        "D": "Documentation must be accessible."
      }
    }
  },

  {
    "id": "CH02-0161",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Stateless constraint",
    "difficulty": "Medium",
    "question": "Why does the stateless constraint improve API scalability?",
    "options": {
      "A": "It forces clients to store server state",
      "B": "It allows servers to process requests independently",
      "C": "It eliminates the need for authentication",
      "D": "It reduces payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Statelessness allows servers to handle each request independently, improving scalability.",
      "incorrect": {
        "A": "Clients do not store server state.",
        "C": "Authentication is still required.",
        "D": "Payload size is unrelated."
      }
    }
  },
  {
    "id": "CH02-0162",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "OPTIONS usage",
    "difficulty": "Medium",
    "question": "What is the primary purpose of the HTTP OPTIONS method?",
    "options": {
      "A": "Retrieve resource data",
      "B": "Discover supported methods and capabilities",
      "C": "Update a resource partially",
      "D": "Authenticate the client"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "OPTIONS allows clients to discover allowed methods and server capabilities.",
      "incorrect": {
        "A": "GET retrieves resource data.",
        "C": "PATCH updates resources.",
        "D": "Authentication is handled separately."
      }
    }
  },
  {
    "id": "CH02-0163",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "503 Service Unavailable",
    "difficulty": "Hard",
    "question": "When should an API return HTTP 503 Service Unavailable?",
    "options": {
      "A": "Client sent invalid data",
      "B": "Server is temporarily unable to handle requests",
      "C": "Authentication failed",
      "D": "Resource does not exist"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "503 indicates temporary unavailability, often due to overload or maintenance.",
      "incorrect": {
        "A": "400 is used for invalid input.",
        "C": "401 indicates authentication issues.",
        "D": "404 indicates missing resources."
      }
    }
  },
  {
    "id": "CH02-0164",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Hyphen usage",
    "difficulty": "Easy",
    "question": "Why are hyphens preferred over underscores in URI paths?",
    "options": {
      "A": "They improve database mapping",
      "B": "They are more readable and SEO-friendly",
      "C": "They reduce payload size",
      "D": "They enforce security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Hyphens improve readability and are widely supported.",
      "incorrect": {
        "A": "Database mapping is irrelevant.",
        "C": "Payload size is unaffected.",
        "D": "Security is unrelated."
      }
    }
  },
  {
    "id": "CH02-0165",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Boolean flags",
    "difficulty": "Medium",
    "question": "What is a best practice when designing boolean query parameters?",
    "options": {
      "A": "Use vague names like flag1",
      "B": "Use descriptive names and default values",
      "C": "Avoid documentation",
      "D": "Encode them in the URI path"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear naming and defaults make boolean parameters intuitive.",
      "incorrect": {
        "A": "Vague names reduce usability.",
        "C": "Documentation is essential.",
        "D": "Paths should represent resources."
      }
    }
  },

  {
    "id": "CH02-0166",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Deprecation headers",
    "difficulty": "Hard",
    "question": "Why should APIs use deprecation headers?",
    "options": {
      "A": "To eliminate versioning",
      "B": "To inform consumers about upcoming removals",
      "C": "To reduce payload size",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Deprecation headers proactively notify consumers of planned changes.",
      "incorrect": {
        "A": "Versioning is still required.",
        "C": "Payload size is unrelated.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0167",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "ETag validation",
    "difficulty": "Hard",
    "question": "How do ETags help reduce unnecessary data transfer?",
    "options": {
      "A": "By encrypting responses",
      "B": "By allowing clients to validate cached responses",
      "C": "By compressing payloads",
      "D": "By eliminating authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "ETags allow conditional requests that return data only if changed.",
      "incorrect": {
        "A": "Encryption is unrelated.",
        "C": "Compression is separate.",
        "D": "Authentication is still required."
      }
    }
  },
  {
    "id": "CH02-0168",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Includes",
    "difficulty": "Medium",
    "question": "What is the purpose of !include in RAML?",
    "options": {
      "A": "Execute runtime logic",
      "B": "Reuse external files such as schemas or examples",
      "C": "Define security policies",
      "D": "Deploy APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "!include allows modular reuse of external definitions.",
      "incorrect": {
        "A": "RAML does not execute logic.",
        "C": "Security is defined separately.",
        "D": "Deployment is outside RAML scope."
      }
    }
  },
  {
    "id": "CH02-0169",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Multiple responses",
    "difficulty": "Medium",
    "question": "Why should APIs explicitly define multiple response codes in RAML?",
    "options": {
      "A": "To increase payload size",
      "B": "To clearly document all possible outcomes",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit responses help consumers handle different scenarios correctly.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Testing remains necessary.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0170",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "OperationId",
    "difficulty": "Medium",
    "question": "What is the primary purpose of operationId in OpenAPI?",
    "options": {
      "A": "Routing requests",
      "B": "Uniquely identifying operations for tooling and code generation",
      "C": "Defining authentication",
      "D": "Managing deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "operationId uniquely identifies operations for SDKs and tools.",
      "incorrect": {
        "A": "Routing is handled by paths.",
        "C": "Authentication is defined elsewhere.",
        "D": "Deployment is outside OAS scope."
      }
    }
  },

  {
    "id": "CH02-0171",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Default values",
    "difficulty": "Medium",
    "question": "Why should schemas define default values where appropriate?",
    "options": {
      "A": "To eliminate validation",
      "B": "To ensure predictable behavior when fields are omitted",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Defaults provide consistent behavior even when clients omit fields.",
      "incorrect": {
        "A": "Validation remains essential.",
        "C": "Payload size is unrelated.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0172",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "HTTP 206 Partial Content",
    "difficulty": "Hard",
    "question": "When is HTTP 206 Partial Content typically used?",
    "options": {
      "A": "When authentication fails",
      "B": "When returning a subset of a resource via range requests",
      "C": "When creating a resource",
      "D": "When deleting a resource"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "206 is used for partial responses, often with Range headers.",
      "incorrect": {
        "A": "401 indicates authentication failure.",
        "C": "201 indicates creation.",
        "D": "DELETE usually returns 204."
      }
    }
  },
  {
    "id": "CH02-0173",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Problem Details",
    "difficulty": "Hard",
    "question": "What is the benefit of using RFC 7807 Problem Details format?",
    "options": {
      "A": "Reduced payload size",
      "B": "Standardized, machine-readable error responses",
      "C": "Elimination of HTTP status codes",
      "D": "Avoidance of versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RFC 7807 provides a consistent structure for error details.",
      "incorrect": {
        "A": "Payload size may increase.",
        "C": "HTTP status codes are still used.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0174",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Consumer empathy",
    "difficulty": "Medium",
    "question": "Why is consumer empathy important in API design?",
    "options": {
      "A": "To reduce documentation",
      "B": "To design APIs that are intuitive and easy to use",
      "C": "To eliminate validation",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Understanding consumers leads to better usability and adoption.",
      "incorrect": {
        "A": "Documentation remains necessary.",
        "C": "Validation is required.",
        "D": "Governance remains essential."
      }
    }
  },
  {
    "id": "CH02-0175",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Consistency",
    "difficulty": "Medium",
    "question": "Why should pagination behavior be consistent across endpoints?",
    "options": {
      "A": "To reduce payload size",
      "B": "To simplify consumer implementation",
      "C": "To eliminate reuse",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency reduces complexity for API consumers.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Consistency encourages reuse.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0176",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Transport security",
    "difficulty": "Medium",
    "question": "Why should APIs enforce HTTPS exclusively?",
    "options": {
      "A": "To reduce payload size",
      "B": "To protect data in transit",
      "C": "To eliminate authentication",
      "D": "To avoid rate limiting"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTPS encrypts data and prevents interception.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is still required.",
        "D": "Rate limiting is separate."
      }
    }
  },
  {
    "id": "CH02-0177",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Standard logging fields",
    "difficulty": "Medium",
    "question": "Which information is most important to log for API observability?",
    "options": {
      "A": "Database schema",
      "B": "Request IDs, timestamps, and response status",
      "C": "Source code paths",
      "D": "Internal memory addresses"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standard fields enable tracing, debugging, and monitoring.",
      "incorrect": {
        "A": "Schemas are irrelevant to logs.",
        "C": "Source paths are not useful externally.",
        "D": "Memory addresses are meaningless."
      }
    }
  },
  {
    "id": "CH02-0178",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Lifecycle ownership",
    "difficulty": "Hard",
    "question": "Why should APIs have clearly defined owners?",
    "options": {
      "A": "To avoid accountability",
      "B": "To ensure maintenance, evolution, and support",
      "C": "To eliminate governance",
      "D": "To reduce documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear ownership ensures APIs are properly maintained.",
      "incorrect": {
        "A": "Ownership increases accountability.",
        "C": "Governance remains essential.",
        "D": "Documentation remains required."
      }
    }
  },
  {
    "id": "CH02-0179",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "KPIs",
    "difficulty": "Medium",
    "question": "Which KPI best reflects API usability?",
    "options": {
      "A": "Server CPU usage",
      "B": "Time to first successful integration",
      "C": "Number of endpoints",
      "D": "Deployment frequency"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Faster onboarding indicates good usability.",
      "incorrect": {
        "A": "CPU usage is operational.",
        "C": "Quantity does not reflect usability.",
        "D": "Deployment frequency is internal."
      }
    }
  },
  {
    "id": "CH02-0180",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Resilience",
    "difficulty": "Hard",
    "question": "Which design practice improves API resilience?",
    "options": {
      "A": "Tight coupling",
      "B": "Graceful error handling and retries",
      "C": "Minimal validation",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Graceful handling allows APIs to recover from failures.",
      "incorrect": {
        "A": "Tight coupling reduces resilience.",
        "C": "Validation is essential.",
        "D": "Documentation must be accessible."
      }
    }
  },

  {
    "id": "CH02-0181",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit defaults",
    "difficulty": "Medium",
    "question": "Why should API defaults be explicitly documented?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent unexpected behavior for consumers",
      "C": "To eliminate validation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit defaults avoid hidden assumptions.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation remains necessary.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0182",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Sunset headers",
    "difficulty": "Hard",
    "question": "What is the purpose of the Sunset HTTP header?",
    "options": {
      "A": "To indicate authentication expiry",
      "B": "To communicate planned API retirement dates",
      "C": "To reduce payload size",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sunset headers inform consumers about end-of-life timelines.",
      "incorrect": {
        "A": "Authentication expiry is separate.",
        "C": "Payload size is unrelated.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0183",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Clarity",
    "difficulty": "Easy",
    "question": "What is the primary goal of clear API naming?",
    "options": {
      "A": "To reduce payload size",
      "B": "To make APIs self-explanatory",
      "C": "To eliminate documentation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear names reduce confusion and speed adoption.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Documentation is still required.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0184",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Lifecycle",
    "subtopic": "Version coexistence",
    "difficulty": "Medium",
    "question": "Why should multiple API versions coexist temporarily?",
    "options": {
      "A": "To increase maintenance cost",
      "B": "To allow gradual consumer migration",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Coexistence reduces disruption for consumers.",
      "incorrect": {
        "A": "Cost is a trade-off, not the goal.",
        "C": "Governance remains essential.",
        "D": "Documentation remains required."
      }
    }
  },
  {
    "id": "CH02-0185",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Metrics",
    "subtopic": "Reuse rate",
    "difficulty": "Medium",
    "question": "What does a high API reuse rate indicate?",
    "options": {
      "A": "Poor API design",
      "B": "Well-designed, valuable APIs",
      "C": "Excessive governance",
      "D": "Low adoption"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "High reuse reflects strong design and business value.",
      "incorrect": {
        "A": "Reuse indicates success.",
        "C": "Governance supports reuse.",
        "D": "Reuse implies adoption."
      }
    }
  },

  {
    "id": "CH02-0186",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Enterprise APIs",
    "subtopic": "Loose coupling",
    "difficulty": "Hard",
    "question": "How does loose coupling benefit enterprise APIs?",
    "options": {
      "A": "It increases dependency on backend systems",
      "B": "It allows independent evolution of systems",
      "C": "It eliminates documentation",
      "D": "It avoids security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Loose coupling enables systems to change independently.",
      "incorrect": {
        "A": "Loose coupling reduces dependency.",
        "C": "Documentation remains essential.",
        "D": "Security remains critical."
      }
    }
  },
  {
    "id": "CH02-0187",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Consistency",
    "subtopic": "HTTP semantics",
    "difficulty": "Medium",
    "question": "Why should APIs strictly follow HTTP semantics?",
    "options": {
      "A": "To confuse consumers",
      "B": "To leverage standard client and tooling behavior",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Following standards ensures predictable behavior.",
      "incorrect": {
        "A": "Confusion reduces adoption.",
        "C": "Payload size is unrelated.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0188",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Self-service",
    "difficulty": "Medium",
    "question": "What enables self-service API consumption?",
    "options": {
      "A": "Hidden endpoints",
      "B": "Clear documentation, examples, and onboarding guides",
      "C": "Minimal error handling",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Self-service requires clarity and guidance.",
      "incorrect": {
        "A": "Hidden endpoints hinder self-service.",
        "C": "Error handling is essential.",
        "D": "Tight coupling reduces usability."
      }
    }
  },
  {
    "id": "CH02-0189",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Platform thinking",
    "difficulty": "Hard",
    "question": "What does platform thinking emphasize in API programs?",
    "options": {
      "A": "One-off integrations",
      "B": "Reusable building blocks for multiple use cases",
      "C": "Minimal governance",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Platform thinking maximizes reuse and scalability.",
      "incorrect": {
        "A": "One-off designs limit value.",
        "C": "Governance is essential.",
        "D": "Documentation must be accessible."
      }
    }
  },
  {
    "id": "CH02-0190",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Longevity",
    "difficulty": "Hard",
    "question": "Which factor most contributes to long-term API longevity?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Backward compatibility and clear governance",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Longevity depends on stable evolution and governance.",
      "incorrect": {
        "A": "Breaking changes shorten lifespan.",
        "C": "Security is essential.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0191",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Contract adherence",
    "difficulty": "Medium",
    "question": "Why is contract adherence critical in API implementations?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure consumers receive expected behavior",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Adherence prevents breaking consumer expectations.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Testing remains essential.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0192",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Design maturity",
    "difficulty": "Medium",
    "question": "What indicates increasing API design maturity in an organization?",
    "options": {
      "A": "Ad-hoc designs",
      "B": "Standardized practices and automated checks",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity is reflected in standards and automation.",
      "incorrect": {
        "A": "Ad-hoc designs indicate immaturity.",
        "C": "Documentation is essential.",
        "D": "Tight coupling reduces maturity."
      }
    }
  },
  {
    "id": "CH02-0193",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Developer experience",
    "difficulty": "Medium",
    "question": "Which factor most directly improves API developer experience?",
    "options": {
      "A": "Complex authentication",
      "B": "Clear contracts, examples, and predictable behavior",
      "C": "Hidden error handling",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Good DX depends on clarity and predictability.",
      "incorrect": {
        "A": "Complexity reduces DX.",
        "C": "Hidden behavior reduces trust.",
        "D": "Breaking changes harm DX."
      }
    }
  },
  {
    "id": "CH02-0194",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Testability",
    "difficulty": "Medium",
    "question": "What makes an API easy to test?",
    "options": {
      "A": "Hidden contracts",
      "B": "Deterministic behavior and clear responses",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable responses simplify testing.",
      "incorrect": {
        "A": "Hidden contracts hinder testing.",
        "C": "Documentation supports testing.",
        "D": "Tight coupling complicates testing."
      }
    }
  },
  {
    "id": "CH02-0195",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Transparency",
    "difficulty": "Medium",
    "question": "Why is transparency important in API design?",
    "options": {
      "A": "To expose internal logic",
      "B": "To set clear expectations for consumers",
      "C": "To eliminate validation",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Transparency builds trust and reduces confusion.",
      "incorrect": {
        "A": "Internals should not be exposed.",
        "C": "Validation remains essential.",
        "D": "Governance remains essential."
      }
    }
  },

  {
    "id": "CH02-0196",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Least exposure",
    "difficulty": "Hard",
    "question": "What does least exposure mean in API design?",
    "options": {
      "A": "Expose all available data",
      "B": "Expose only data necessary for consumer use cases",
      "C": "Eliminate authentication",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least exposure minimizes security and privacy risks.",
      "incorrect": {
        "A": "Overexposure increases risk.",
        "C": "Authentication is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0197",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Metrics",
    "difficulty": "Medium",
    "question": "Which metric is most useful for detecting API performance issues?",
    "options": {
      "A": "Number of endpoints",
      "B": "Response latency",
      "C": "Documentation length",
      "D": "Reuse rate"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Latency directly reflects performance problems.",
      "incorrect": {
        "A": "Endpoint count is irrelevant.",
        "C": "Documentation length is unrelated.",
        "D": "Reuse reflects design value."
      }
    }
  },
  {
    "id": "CH02-0198",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Change resilience",
    "difficulty": "Hard",
    "question": "What design approach best improves change resilience?",
    "options": {
      "A": "Tight coupling",
      "B": "Stable contracts with versioning",
      "C": "Minimal documentation",
      "D": "Hidden logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts isolate consumers from internal changes.",
      "incorrect": {
        "A": "Tight coupling reduces resilience.",
        "C": "Documentation is essential.",
        "D": "Hidden logic reduces trust."
      }
    }
  },
  {
    "id": "CH02-0199",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Governance balance",
    "difficulty": "Medium",
    "question": "Why must API governance balance control and flexibility?",
    "options": {
      "A": "To eliminate standards",
      "B": "To enable innovation while maintaining consistency",
      "C": "To reduce documentation",
      "D": "To avoid reuse"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Balanced governance supports innovation at scale.",
      "incorrect": {
        "A": "Standards are essential.",
        "C": "Documentation remains required.",
        "D": "Reuse is encouraged."
      }
    }
  },
  {
    "id": "CH02-0200",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Enterprise sustainability",
    "difficulty": "Hard",
    "question": "What ultimately ensures sustainable API ecosystems?",
    "options": {
      "A": "One-time delivery",
      "B": "Governance, reuse, and continuous improvement",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainability depends on governance, reuse, and ongoing evolution.",
      "incorrect": {
        "A": "APIs require ongoing management.",
        "C": "Security must be strong.",
        "D": "Documentation must be accessible."
      }
    }
  },

  {
    "id": "CH02-0201",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Cache constraint",
    "difficulty": "Medium",
    "question": "What is the primary benefit of the cache constraint in REST?",
    "options": {
      "A": "Improved database normalization",
      "B": "Reduced latency and server load",
      "C": "Elimination of authentication",
      "D": "Automatic versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Caching reduces repeated processing by allowing reuse of responses.",
      "incorrect": {
        "A": "Database design is unrelated.",
        "C": "Authentication is still required.",
        "D": "Versioning is independent of caching."
      }
    }
  },
  {
    "id": "CH02-0202",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "Idempotency",
    "difficulty": "Medium",
    "question": "Which HTTP method is idempotent by definition?",
    "options": {
      "A": "POST",
      "B": "PUT",
      "C": "CONNECT",
      "D": "PATCH"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "PUT can be repeated with the same result, making it idempotent.",
      "incorrect": {
        "A": "POST is not idempotent.",
        "C": "CONNECT establishes tunnels.",
        "D": "PATCH may not be idempotent."
      }
    }
  },
  {
    "id": "CH02-0203",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "204 No Content",
    "difficulty": "Easy",
    "question": "When is HTTP 204 No Content most appropriate?",
    "options": {
      "A": "After successful deletion with no response body",
      "B": "When a resource is created",
      "C": "When authentication fails",
      "D": "When validation fails"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "204 indicates success without returning a payload.",
      "incorrect": {
        "B": "201 indicates creation.",
        "C": "401 indicates authentication failure.",
        "D": "422 or 400 indicate validation errors."
      }
    }
  },
  {
    "id": "CH02-0204",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Pluralization",
    "difficulty": "Easy",
    "question": "Why are plural nouns recommended for collection resources?",
    "options": {
      "A": "They reduce payload size",
      "B": "They clearly represent collections of resources",
      "C": "They eliminate versioning",
      "D": "They improve security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Plural nouns clearly indicate a collection endpoint.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning is independent.",
        "D": "Security is not affected."
      }
    }
  },
  {
    "id": "CH02-0205",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Sorting",
    "difficulty": "Medium",
    "question": "What is a common best practice for sorting API responses?",
    "options": {
      "A": "Sort only on the server side implicitly",
      "B": "Expose explicit sort parameters",
      "C": "Disable pagination when sorting",
      "D": "Sort using request headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit sort parameters give consumers control over ordering.",
      "incorrect": {
        "A": "Implicit behavior is unpredictable.",
        "C": "Sorting and pagination should coexist.",
        "D": "Headers are not ideal for sorting."
      }
    }
  },

  {
    "id": "CH02-0206",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "URI versioning trade-offs",
    "difficulty": "Hard",
    "question": "What is a key disadvantage of URI-based versioning?",
    "options": {
      "A": "It breaks HTTP semantics",
      "B": "It can lead to URI proliferation",
      "C": "It cannot be cached",
      "D": "It eliminates backward compatibility"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Each version introduces new URIs, increasing maintenance complexity.",
      "incorrect": {
        "A": "HTTP semantics still apply.",
        "C": "Caching still works.",
        "D": "Backward compatibility is a design choice."
      }
    }
  },
  {
    "id": "CH02-0207",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "Cache-Control",
    "difficulty": "Medium",
    "question": "What does the Cache-Control: no-store directive indicate?",
    "options": {
      "A": "Response can be cached indefinitely",
      "B": "Response must not be stored by any cache",
      "C": "Response can be conditionally cached",
      "D": "Response is private to the client"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "no-store prevents any caching of sensitive data.",
      "incorrect": {
        "A": "That would be max-age.",
        "C": "Conditional caching uses validators.",
        "D": "private is a different directive."
      }
    }
  },
  {
    "id": "CH02-0208",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Traits",
    "difficulty": "Medium",
    "question": "What problem do RAML traits primarily solve?",
    "options": {
      "A": "Runtime execution",
      "B": "Reuse of common method-level patterns",
      "C": "Deployment automation",
      "D": "Security enforcement"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Traits allow reuse of common behaviors like pagination or headers.",
      "incorrect": {
        "A": "RAML is design-time only.",
        "C": "Deployment is outside RAML scope.",
        "D": "Security is defined separately."
      }
    }
  },
  {
    "id": "CH02-0209",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "ResourceTypes",
    "difficulty": "Medium",
    "question": "When should RAML resourceTypes be used?",
    "options": {
      "A": "To reuse common resource structures",
      "B": "To define deployment environments",
      "C": "To execute transformations",
      "D": "To manage runtime traffic"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "resourceTypes standardize patterns across similar resources.",
      "incorrect": {
        "B": "Environments are not part of RAML.",
        "C": "Transformations are runtime concerns.",
        "D": "Traffic management is runtime."
      }
    }
  },
  {
    "id": "CH02-0210",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Components section",
    "difficulty": "Medium",
    "question": "What is the purpose of the components section in OpenAPI?",
    "options": {
      "A": "Define servers",
      "B": "Store reusable schemas, parameters, and responses",
      "C": "Execute security checks",
      "D": "Deploy APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Components centralize reusable definitions.",
      "incorrect": {
        "A": "Servers are defined elsewhere.",
        "C": "Security logic is not executed.",
        "D": "Deployment is outside OAS scope."
      }
    }
  },

  {
    "id": "CH02-0211",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Required fields",
    "difficulty": "Medium",
    "question": "Why should required fields be minimized in API schemas?",
    "options": {
      "A": "To reduce payload size",
      "B": "To improve backward compatibility",
      "C": "To eliminate validation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Fewer required fields reduce breaking changes in future versions.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Validation is still needed.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0212",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Consistent envelopes",
    "difficulty": "Medium",
    "question": "What is a benefit of using consistent response envelopes?",
    "options": {
      "A": "Reduced security",
      "B": "Predictable parsing for clients",
      "C": "Elimination of HTTP status codes",
      "D": "Avoidance of pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent envelopes simplify client-side parsing logic.",
      "incorrect": {
        "A": "Security must not be reduced.",
        "C": "HTTP status codes are still required.",
        "D": "Pagination can still be used."
      }
    }
  },
  {
    "id": "CH02-0213",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Retry-After header",
    "difficulty": "Hard",
    "question": "When should the Retry-After header be included?",
    "options": {
      "A": "After successful responses",
      "B": "When clients should wait before retrying a request",
      "C": "During authentication",
      "D": "For all 4xx errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Retry-After guides clients on when to retry safely.",
      "incorrect": {
        "A": "It is unnecessary after success.",
        "C": "Authentication uses different headers.",
        "D": "Not all 4xx errors are retryable."
      }
    }
  },
  {
    "id": "CH02-0214",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "API-first approach",
    "difficulty": "Medium",
    "question": "What is the main advantage of an API-first approach?",
    "options": {
      "A": "Faster coding without design",
      "B": "Clear contracts before implementation begins",
      "C": "Elimination of documentation",
      "D": "Reduced security requirements"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "API-first ensures alignment and clarity before development.",
      "incorrect": {
        "A": "Design is essential.",
        "C": "Documentation is critical.",
        "D": "Security remains essential."
      }
    }
  },
  {
    "id": "CH02-0215",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Cursor-based pagination",
    "difficulty": "Hard",
    "question": "Why is cursor-based pagination preferred for large datasets?",
    "options": {
      "A": "It is easier to implement",
      "B": "It avoids issues with data changes during paging",
      "C": "It eliminates sorting",
      "D": "It reduces security risks"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Cursors are stable even when underlying data changes.",
      "incorrect": {
        "A": "Implementation is more complex.",
        "C": "Sorting can still apply.",
        "D": "Security is unrelated."
      }
    }
  },

  {
    "id": "CH02-0216",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Input validation",
    "difficulty": "Medium",
    "question": "Why is strict input validation critical for APIs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent injection and misuse",
      "C": "To eliminate authentication",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Validation protects APIs from malicious or malformed input.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Authentication is still required.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0217",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Health endpoints",
    "difficulty": "Easy",
    "question": "What is the purpose of health check endpoints?",
    "options": {
      "A": "Expose business data",
      "B": "Indicate service availability and readiness",
      "C": "Authenticate clients",
      "D": "Version APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Health endpoints signal service status to monitoring systems.",
      "incorrect": {
        "A": "They should not expose business data.",
        "C": "Authentication is separate.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0218",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Consumer contracts",
    "difficulty": "Medium",
    "question": "Why should APIs treat consumers as contract partners?",
    "options": {
      "A": "To reduce development cost",
      "B": "To ensure changes respect agreed behavior",
      "C": "To eliminate documentation",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contracts define expectations and protect consumers from breaking changes.",
      "incorrect": {
        "A": "Cost reduction is indirect.",
        "C": "Documentation remains essential.",
        "D": "Governance supports contracts."
      }
    }
  },
  {
    "id": "CH02-0219",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Adoption metrics",
    "difficulty": "Medium",
    "question": "Which metric best reflects API adoption?",
    "options": {
      "A": "Number of deployments",
      "B": "Active consuming applications",
      "C": "Source code size",
      "D": "Number of endpoints"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Active consumers directly indicate adoption.",
      "incorrect": {
        "A": "Deployments are internal.",
        "C": "Code size is irrelevant.",
        "D": "Endpoint count does not reflect usage."
      }
    }
  },
  {
    "id": "CH02-0220",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Change tolerance",
    "difficulty": "Hard",
    "question": "What improves an APIs tolerance to internal system changes?",
    "options": {
      "A": "Tight coupling",
      "B": "Abstraction and stable contracts",
      "C": "Minimal validation",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Abstraction shields consumers from backend changes.",
      "incorrect": {
        "A": "Tight coupling increases impact.",
        "C": "Validation remains essential.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0221",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit contracts",
    "difficulty": "Medium",
    "question": "Why should APIs avoid implicit behavior?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent surprises for consumers",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Implicit behavior leads to unpredictable integrations.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Testing is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0222",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Evolution",
    "subtopic": "Compatibility testing",
    "difficulty": "Medium",
    "question": "What is the purpose of backward compatibility testing?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure existing consumers are not broken",
      "C": "To eliminate validation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Compatibility testing protects existing integrations.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation remains essential.",
        "D": "Documentation remains required."
      }
    }
  },
  {
    "id": "CH02-0223",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Consistency of naming",
    "difficulty": "Easy",
    "question": "Why is consistent naming important across APIs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To reduce cognitive load for consumers",
      "C": "To eliminate governance",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency makes APIs easier to understand and use.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance supports consistency.",
        "D": "Versioning is independent."
      }
    }
  },
  {
    "id": "CH02-0224",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Lifecycle",
    "subtopic": "Support phase",
    "difficulty": "Medium",
    "question": "What is a key responsibility during the API support phase?",
    "options": {
      "A": "Ignoring consumer feedback",
      "B": "Monitoring usage and addressing issues",
      "C": "Removing documentation",
      "D": "Avoiding updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Support involves monitoring, fixes, and consumer assistance.",
      "incorrect": {
        "A": "Feedback is essential.",
        "C": "Documentation must be maintained.",
        "D": "Updates may be required."
      }
    }
  },
  {
    "id": "CH02-0225",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Metrics",
    "subtopic": "Error distribution",
    "difficulty": "Medium",
    "question": "Why is monitoring error distribution useful?",
    "options": {
      "A": "To reduce payload size",
      "B": "To identify usability or stability issues",
      "C": "To eliminate logging",
      "D": "To avoid governance"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error trends reveal design or operational problems.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Logging remains essential.",
        "D": "Governance remains necessary."
      }
    }
  },

  {
    "id": "CH02-0226",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Enterprise APIs",
    "subtopic": "Domain alignment",
    "difficulty": "Medium",
    "question": "Why should APIs align with business domains?",
    "options": {
      "A": "To reduce payload size",
      "B": "To improve reuse and clarity",
      "C": "To eliminate documentation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Domain alignment improves reuse and understanding.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Documentation remains essential.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0227",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Consistency",
    "subtopic": "Response shapes",
    "difficulty": "Medium",
    "question": "Why should response shapes be consistent across endpoints?",
    "options": {
      "A": "To increase complexity",
      "B": "To simplify client development",
      "C": "To eliminate pagination",
      "D": "To reduce security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent shapes reduce conditional client logic.",
      "incorrect": {
        "A": "Complexity should be minimized.",
        "C": "Pagination is unrelated.",
        "D": "Security must not be reduced."
      }
    }
  },
  {
    "id": "CH02-0228",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Usability",
    "subtopic": "Discoverable errors",
    "difficulty": "Medium",
    "question": "What makes an API error discoverable?",
    "options": {
      "A": "Hidden error codes",
      "B": "Clear messages and machine-readable fields",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear, structured errors improve troubleshooting.",
      "incorrect": {
        "A": "Hidden errors hinder debugging.",
        "C": "Documentation is essential.",
        "D": "Tight coupling reduces usability."
      }
    }
  },
  {
    "id": "CH02-0229",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Ecosystem thinking",
    "difficulty": "Hard",
    "question": "What does ecosystem thinking emphasize in API design?",
    "options": {
      "A": "Single consumer focus",
      "B": "Multiple consumers and long-term reuse",
      "C": "Minimal governance",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Ecosystems require scalable, reusable designs.",
      "incorrect": {
        "A": "Single-focus limits value.",
        "C": "Governance is essential.",
        "D": "Documentation must be accessible."
      }
    }
  },
  {
    "id": "CH02-0230",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "API sustainability",
    "difficulty": "Hard",
    "question": "What is a hallmark of sustainable API design?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Governed evolution and reuse",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainability requires controlled change and reuse.",
      "incorrect": {
        "A": "Breaking changes harm sustainability.",
        "C": "Security must be strong.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0231",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Mocking",
    "difficulty": "Medium",
    "question": "Why is API mocking useful during design?",
    "options": {
      "A": "To replace documentation",
      "B": "To validate contracts before implementation",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Mocks allow early feedback and validation.",
      "incorrect": {
        "A": "Documentation is still required.",
        "C": "Testing remains necessary.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0232",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Policy alignment",
    "difficulty": "Medium",
    "question": "Why should design policies align with runtime policies?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure consistency from design to execution",
      "C": "To eliminate validation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alignment prevents gaps between design intent and runtime behavior.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation remains required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0233",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Onboarding time",
    "difficulty": "Medium",
    "question": "Why is onboarding time a critical API metric?",
    "options": {
      "A": "It reflects server performance",
      "B": "It reflects usability and clarity of APIs",
      "C": "It eliminates governance",
      "D": "It avoids versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Shorter onboarding indicates better design and documentation.",
      "incorrect": {
        "A": "Performance is separate.",
        "C": "Governance remains essential.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0234",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Extensibility",
    "difficulty": "Medium",
    "question": "Which design choice best supports API extensibility?",
    "options": {
      "A": "Tight coupling",
      "B": "Optional fields and flexible schemas",
      "C": "Minimal documentation",
      "D": "Hidden logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Optional fields allow safe future expansion.",
      "incorrect": {
        "A": "Tight coupling limits extensibility.",
        "C": "Documentation remains essential.",
        "D": "Hidden logic reduces trust."
      }
    }
  },
  {
    "id": "CH02-0235",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Least surprise",
    "difficulty": "Medium",
    "question": "What does the principle of least surprise mean in API design?",
    "options": {
      "A": "APIs should behave unpredictably",
      "B": "APIs should behave as consumers expect",
      "C": "APIs should hide errors",
      "D": "APIs should avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable behavior improves usability and trust.",
      "incorrect": {
        "A": "Unpredictability harms adoption.",
        "C": "Errors should be clear.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0236",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Output encoding",
    "difficulty": "Hard",
    "question": "Why is output encoding important in API responses?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent injection attacks in consuming systems",
      "C": "To eliminate authentication",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Encoding protects downstream consumers from malicious data.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0237",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Tracing",
    "difficulty": "Medium",
    "question": "What is distributed tracing used for?",
    "options": {
      "A": "Authentication",
      "B": "Following a request across multiple services",
      "C": "Reducing payload size",
      "D": "Avoiding versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tracing helps diagnose latency and failures across systems.",
      "incorrect": {
        "A": "Authentication is separate.",
        "C": "Payload size is unrelated.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0238",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Backward compatibility mindset",
    "difficulty": "Hard",
    "question": "Why should backward compatibility be the default mindset?",
    "options": {
      "A": "To slow innovation",
      "B": "To protect existing consumers and trust",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Protecting consumers maintains trust and adoption.",
      "incorrect": {
        "A": "Innovation can still occur safely.",
        "C": "Governance remains essential.",
        "D": "Documentation remains required."
      }
    }
  },
  {
    "id": "CH02-0239",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Value realization",
    "difficulty": "Medium",
    "question": "How do organizations realize value from APIs?",
    "options": {
      "A": "By building many endpoints",
      "B": "Through reuse, adoption, and business enablement",
      "C": "By minimizing security",
      "D": "By hiding APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Value comes from reuse and enabling business capabilities.",
      "incorrect": {
        "A": "Quantity alone has little value.",
        "C": "Security is essential.",
        "D": "Hidden APIs reduce value."
      }
    }
  },
  {
    "id": "CH02-0240",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Long-term trust",
    "difficulty": "Hard",
    "question": "What ultimately builds long-term trust in API consumers?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Stable behavior, transparency, and reliability",
      "C": "Minimal documentation",
      "D": "Hidden errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Trust is built through consistency, clarity, and reliability over time.",
      "incorrect": {
        "A": "Breaking changes erode trust.",
        "C": "Documentation is essential.",
        "D": "Hidden errors reduce confidence."
      }
    }
  },

  {
    "id": "CH02-0241",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Self-descriptive messages",
    "difficulty": "Hard",
    "question": "What does the self-descriptive messages constraint ensure in REST?",
    "options": {
      "A": "Messages contain enough information to be processed without prior context",
      "B": "Messages are always cached",
      "C": "Messages eliminate the need for documentation",
      "D": "Messages enforce authentication automatically"
    },
    "correctAnswer": "A",
    "explanation": {
      "correct": "Self-descriptive messages include metadata (headers, media types) needed to interpret them.",
      "incorrect": {
        "B": "Caching is a separate constraint.",
        "C": "Documentation is still required.",
        "D": "Authentication must be explicitly designed."
      }
    }
  },
  {
    "id": "CH02-0242",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "Safe methods",
    "difficulty": "Medium",
    "question": "Which HTTP method is considered safe?",
    "options": {
      "A": "PUT",
      "B": "POST",
      "C": "GET",
      "D": "PATCH"
    },
    "correctAnswer": "C",
    "explanation": {
      "correct": "GET is safe because it must not modify server state.",
      "incorrect": {
        "A": "PUT modifies state.",
        "B": "POST modifies state.",
        "D": "PATCH modifies state."
      }
    }
  },
  {
    "id": "CH02-0243",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "301 vs 302",
    "difficulty": "Hard",
    "question": "What is the key difference between HTTP 301 and 302?",
    "options": {
      "A": "301 is temporary, 302 is permanent",
      "B": "301 indicates permanent redirection, 302 indicates temporary",
      "C": "302 is cacheable by default",
      "D": "301 eliminates the need for clients to retry"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "301 signals a permanent move, while 302 indicates a temporary redirect.",
      "incorrect": {
        "A": "This is reversed.",
        "C": "302 is not cacheable by default.",
        "D": "Clients may still retry."
      }
    }
  },
  {
    "id": "CH02-0244",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Canonical URIs",
    "difficulty": "Medium",
    "question": "Why should APIs define canonical URIs for resources?",
    "options": {
      "A": "To reduce payload size",
      "B": "To avoid duplicate representations of the same resource",
      "C": "To eliminate versioning",
      "D": "To enforce authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Canonical URIs prevent ambiguity and duplication.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning is independent.",
        "D": "Authentication is unrelated."
      }
    }
  },
  {
    "id": "CH02-0245",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Search endpoints",
    "difficulty": "Medium",
    "question": "When is it appropriate to introduce a dedicated search endpoint?",
    "options": {
      "A": "For simple filtering only",
      "B": "When queries are complex and not resource-oriented",
      "C": "To replace all GET endpoints",
      "D": "To eliminate pagination"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Complex queries may justify a search-oriented endpoint.",
      "incorrect": {
        "A": "Simple filtering fits standard collection endpoints.",
        "C": "Search does not replace basic retrieval.",
        "D": "Pagination is still required."
      }
    }
  },

  {
    "id": "CH02-0246",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Semantic versioning",
    "difficulty": "Hard",
    "question": "What does a major version increment indicate in semantic versioning?",
    "options": {
      "A": "Bug fixes only",
      "B": "Breaking changes",
      "C": "Performance improvements",
      "D": "Documentation updates"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Major versions signal breaking changes to consumers.",
      "incorrect": {
        "A": "Bug fixes are minor/patch changes.",
        "C": "Performance improvements do not require major versions.",
        "D": "Documentation changes do not justify major versions."
      }
    }
  },
  {
    "id": "CH02-0247",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "Last-Modified",
    "difficulty": "Medium",
    "question": "How does the Last-Modified header support caching?",
    "options": {
      "A": "By encrypting cached responses",
      "B": "By allowing conditional requests using timestamps",
      "C": "By eliminating cache storage",
      "D": "By enforcing authentication"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients can use If-Modified-Since to validate cached responses.",
      "incorrect": {
        "A": "Encryption is unrelated.",
        "C": "Caching is still allowed.",
        "D": "Authentication is separate."
      }
    }
  },
  {
    "id": "CH02-0248",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Annotations",
    "difficulty": "Medium",
    "question": "What is the purpose of annotations in RAML?",
    "options": {
      "A": "Execute runtime logic",
      "B": "Add custom metadata to API definitions",
      "C": "Define deployment pipelines",
      "D": "Apply security policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Annotations allow extending RAML with custom metadata.",
      "incorrect": {
        "A": "RAML does not execute logic.",
        "C": "Deployment is outside RAML scope.",
        "D": "Security is defined via securitySchemes."
      }
    }
  },
  {
    "id": "CH02-0249",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Libraries",
    "difficulty": "Medium",
    "question": "Why are RAML libraries useful?",
    "options": {
      "A": "They reduce payload size",
      "B": "They enable reuse of common types and traits across APIs",
      "C": "They manage runtime traffic",
      "D": "They deploy APIs automatically"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Libraries centralize reusable definitions.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Traffic management is runtime.",
        "D": "Deployment is not handled by RAML."
      }
    }
  },
  {
    "id": "CH02-0250",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "RequestBody object",
    "difficulty": "Medium",
    "question": "What does the RequestBody object define in OpenAPI?",
    "options": {
      "A": "Response schemas",
      "B": "The structure and media types of request payloads",
      "C": "Authentication rules",
      "D": "Deployment environments"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "RequestBody specifies payload structure and content types.",
      "incorrect": {
        "A": "Responses are defined separately.",
        "C": "Authentication is defined via security.",
        "D": "Deployment is outside OAS scope."
      }
    }
  },

  {
    "id": "CH02-0251",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "OneOf / AnyOf",
    "difficulty": "Hard",
    "question": "When should oneOf or anyOf constructs be used in schemas?",
    "options": {
      "A": "To reduce payload size",
      "B": "To represent multiple valid schema alternatives",
      "C": "To eliminate validation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "These constructs express polymorphic data structures.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Validation is still required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0252",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Problem transparency",
    "difficulty": "Medium",
    "question": "Why should error responses avoid exposing stack traces?",
    "options": {
      "A": "To reduce payload size",
      "B": "To prevent leaking internal implementation details",
      "C": "To eliminate debugging",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stack traces expose sensitive internal details and security risks.",
      "incorrect": {
        "A": "Security is the primary concern.",
        "C": "Debugging should be done internally.",
        "D": "Versioning is unrelated."
      }
    }
  },
  {
    "id": "CH02-0253",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Client guidance",
    "difficulty": "Medium",
    "question": "What should well-designed error messages include?",
    "options": {
      "A": "Only internal error codes",
      "B": "Actionable information for clients",
      "C": "Stack traces",
      "D": "Database details"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Actionable messages help clients correct issues quickly.",
      "incorrect": {
        "A": "Codes alone are insufficient.",
        "C": "Stack traces should not be exposed.",
        "D": "Database details must remain internal."
      }
    }
  },
  {
    "id": "CH02-0254",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Backward compatibility by default",
    "difficulty": "Hard",
    "question": "Why should backward compatibility be the default design assumption?",
    "options": {
      "A": "To slow innovation",
      "B": "To avoid breaking existing consumers",
      "C": "To eliminate versioning",
      "D": "To reduce security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Protecting consumers preserves trust and adoption.",
      "incorrect": {
        "A": "Innovation can still occur safely.",
        "C": "Versioning supports compatibility.",
        "D": "Security remains essential."
      }
    }
  },
  {
    "id": "CH02-0255",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Deterministic ordering",
    "difficulty": "Medium",
    "question": "Why is deterministic ordering important for pagination?",
    "options": {
      "A": "To eliminate sorting",
      "B": "To ensure consistent results across pages",
      "C": "To reduce payload size",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable ordering prevents duplicates or missing items.",
      "incorrect": {
        "A": "Sorting is still required.",
        "C": "Payload size is unrelated.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0256",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Principle of least privilege",
    "difficulty": "Hard",
    "question": "What does the principle of least privilege mean in API security?",
    "options": {
      "A": "Grant maximum access by default",
      "B": "Grant only the permissions necessary for a task",
      "C": "Eliminate authentication",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Least privilege minimizes risk by limiting access.",
      "incorrect": {
        "A": "Excessive access increases risk.",
        "C": "Authentication is essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0257",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "SLIs and SLOs",
    "difficulty": "Hard",
    "question": "Why are SLIs and SLOs important for APIs?",
    "options": {
      "A": "To eliminate monitoring",
      "B": "To define and measure reliability targets",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLIs/SLOs quantify reliability expectations.",
      "incorrect": {
        "A": "Monitoring is required.",
        "C": "Payload size is unrelated.",
        "D": "Versioning is independent."
      }
    }
  },
  {
    "id": "CH02-0258",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Consumer-driven contracts",
    "difficulty": "Hard",
    "question": "What is the main benefit of consumer-driven contract testing?",
    "options": {
      "A": "Reduced payload size",
      "B": "Ensuring providers meet consumer expectations",
      "C": "Eliminating documentation",
      "D": "Avoiding versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Contracts validate provider behavior against consumer needs.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Documentation is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0259",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Portfolio management",
    "difficulty": "Medium",
    "question": "Why is API portfolio management important?",
    "options": {
      "A": "To hide APIs",
      "B": "To manage lifecycle, reuse, and redundancy",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Portfolio management avoids duplication and unmanaged growth.",
      "incorrect": {
        "A": "Hiding APIs reduces value.",
        "C": "Governance relies on portfolio visibility.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0260",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Scalable governance",
    "difficulty": "Hard",
    "question": "What enables governance to scale across many APIs?",
    "options": {
      "A": "Manual reviews only",
      "B": "Automation and standardization",
      "C": "Minimal documentation",
      "D": "Hidden policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures consistent enforcement at scale.",
      "incorrect": {
        "A": "Manual reviews do not scale.",
        "C": "Documentation remains essential.",
        "D": "Hidden policies reduce effectiveness."
      }
    }
  },

  {
    "id": "CH02-0261",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Early feedback loops",
    "difficulty": "Medium",
    "question": "Why are early feedback loops critical in API design?",
    "options": {
      "A": "To delay delivery",
      "B": "To catch design flaws before implementation",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Early feedback reduces costly rework later.",
      "incorrect": {
        "A": "Feedback accelerates delivery long-term.",
        "C": "Testing is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0262",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Design linting",
    "difficulty": "Medium",
    "question": "What is API design linting used for?",
    "options": {
      "A": "Runtime execution",
      "B": "Automated validation of design standards",
      "C": "Deployment automation",
      "D": "Traffic shaping"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Linting enforces design rules automatically.",
      "incorrect": {
        "A": "Design linting is not runtime.",
        "C": "Deployment is separate.",
        "D": "Traffic shaping is runtime."
      }
    }
  },
  {
    "id": "CH02-0263",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Developer enablement",
    "difficulty": "Medium",
    "question": "Why is developer enablement critical to API success?",
    "options": {
      "A": "To reduce payload size",
      "B": "To maximize adoption and correct usage",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Enabled developers adopt and use APIs correctly.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance remains essential.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0264",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Predictable errors",
    "difficulty": "Medium",
    "question": "Why should APIs return predictable error formats?",
    "options": {
      "A": "To increase complexity",
      "B": "To simplify error handling for consumers",
      "C": "To eliminate HTTP status codes",
      "D": "To reduce security"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Predictable errors reduce client-side complexity.",
      "incorrect": {
        "A": "Complexity should be minimized.",
        "C": "Status codes remain essential.",
        "D": "Security must not be reduced."
      }
    }
  },
  {
    "id": "CH02-0265",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit documentation",
    "difficulty": "Easy",
    "question": "Why must APIs be explicitly documented even if they seem intuitive?",
    "options": {
      "A": "To reduce payload size",
      "B": "To avoid ambiguity and assumptions",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit documentation prevents misinterpretation.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Testing remains necessary.",
        "D": "Versioning remains necessary."
      }
    }
  },

  {
    "id": "CH02-0266",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Threat modeling",
    "difficulty": "Hard",
    "question": "Why should threat modeling be part of API design?",
    "options": {
      "A": "To reduce payload size",
      "B": "To identify and mitigate security risks early",
      "C": "To eliminate authentication",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Threat modeling anticipates and reduces vulnerabilities.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0267",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Alerting",
    "difficulty": "Medium",
    "question": "Why is alerting essential for APIs?",
    "options": {
      "A": "To eliminate monitoring",
      "B": "To notify teams of failures or SLA breaches",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alerts enable rapid response to issues.",
      "incorrect": {
        "A": "Monitoring is still required.",
        "C": "Payload size is unrelated.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0268",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Reuse over rebuild",
    "difficulty": "Medium",
    "question": "Why should organizations favor API reuse over rebuilding?",
    "options": {
      "A": "To slow delivery",
      "B": "To reduce cost and improve consistency",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Reuse reduces duplication and increases ROI.",
      "incorrect": {
        "A": "Reuse accelerates delivery.",
        "C": "Governance supports reuse.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0269",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Operating model",
    "difficulty": "Hard",
    "question": "What is the purpose of an API operating model?",
    "options": {
      "A": "To define coding standards only",
      "B": "To define roles, processes, and governance",
      "C": "To eliminate versioning",
      "D": "To hide APIs"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Operating models align people, process, and technology.",
      "incorrect": {
        "A": "Coding standards are only part of it.",
        "C": "Versioning remains necessary.",
        "D": "Hiding APIs reduces value."
      }
    }
  },
  {
    "id": "CH02-0270",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Enterprise scalability",
    "difficulty": "Hard",
    "question": "What enables APIs to scale across an enterprise?",
    "options": {
      "A": "Ad-hoc designs",
      "B": "Standardization, reuse, and governance",
      "C": "Minimal documentation",
      "D": "Tight coupling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Standardization and governance enable scalable reuse.",
      "incorrect": {
        "A": "Ad-hoc designs do not scale.",
        "C": "Documentation remains essential.",
        "D": "Tight coupling limits scale."
      }
    }
  },

  {
    "id": "CH02-0271",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Contract-first testing",
    "difficulty": "Medium",
    "question": "What is the benefit of contract-first testing?",
    "options": {
      "A": "Reduced payload size",
      "B": "Ensuring implementations conform to the API contract",
      "C": "Eliminating documentation",
      "D": "Avoiding versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Tests validate adherence to the defined contract.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Documentation is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0272",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Design approval gates",
    "difficulty": "Medium",
    "question": "Why are design approval gates used in API governance?",
    "options": {
      "A": "To slow development",
      "B": "To ensure quality before implementation",
      "C": "To eliminate reuse",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Gates prevent poor designs from progressing.",
      "incorrect": {
        "A": "They improve long-term speed.",
        "C": "Reuse is encouraged.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0273",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Community building",
    "difficulty": "Medium",
    "question": "Why is building an API consumer community valuable?",
    "options": {
      "A": "To reduce payload size",
      "B": "To gather feedback and drive adoption",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Communities provide feedback and increase engagement.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance remains essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0274",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Consistency audits",
    "difficulty": "Medium",
    "question": "What is the goal of API consistency audits?",
    "options": {
      "A": "To reduce payload size",
      "B": "To identify deviations from design standards",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audits ensure APIs adhere to agreed standards.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Testing remains required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0275",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Consistency over cleverness",
    "difficulty": "Medium",
    "question": "Why is consistency preferred over cleverness in API design?",
    "options": {
      "A": "To reduce innovation",
      "B": "To make APIs easier to learn and use",
      "C": "To eliminate documentation",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistency lowers cognitive load for consumers.",
      "incorrect": {
        "A": "Innovation can still occur.",
        "C": "Documentation remains essential.",
        "D": "Versioning remains necessary."
      }
    }
  },

  {
    "id": "CH02-0276",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Audit logging",
    "difficulty": "Hard",
    "question": "Why is audit logging important for APIs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To support compliance and forensic analysis",
      "C": "To eliminate authentication",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Audit logs enable traceability and compliance.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication is essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0277",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Dashboards",
    "difficulty": "Easy",
    "question": "What is the main purpose of API monitoring dashboards?",
    "options": {
      "A": "Expose internal code",
      "B": "Visualize health, performance, and usage",
      "C": "Eliminate logging",
      "D": "Avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Dashboards provide visibility into API behavior.",
      "incorrect": {
        "A": "Internal code should not be exposed.",
        "C": "Logging is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0278",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Product mindset",
    "difficulty": "Medium",
    "question": "What does adopting a product mindset for APIs imply?",
    "options": {
      "A": "One-time delivery",
      "B": "Ongoing improvement based on consumer feedback",
      "C": "Minimal governance",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product mindset focuses on lifecycle and consumer experience.",
      "incorrect": {
        "A": "APIs require ongoing care.",
        "C": "Governance remains essential.",
        "D": "Documentation must be accessible."
      }
    }
  },
  {
    "id": "CH02-0279",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Value tracking",
    "difficulty": "Medium",
    "question": "Why should API programs track business value metrics?",
    "options": {
      "A": "To reduce payload size",
      "B": "To demonstrate ROI and justify investment",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Value metrics show the impact of APIs on business outcomes.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance remains essential.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0280",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Long-term evolution",
    "difficulty": "Hard",
    "question": "What best supports long-term API evolution?",
    "options": {
      "A": "Tight coupling",
      "B": "Clear contracts, governance, and backward compatibility",
      "C": "Minimal documentation",
      "D": "Hidden errors"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stable contracts and governance enable safe evolution.",
      "incorrect": {
        "A": "Tight coupling limits evolution.",
        "C": "Documentation remains essential.",
        "D": "Hidden errors reduce trust."
      }
    }
  },

  {
    "id": "CH02-0281",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Layered system constraint",
    "difficulty": "Medium",
    "question": "What advantage does the layered system constraint provide in REST?",
    "options": {
      "A": "Eliminates authentication",
      "B": "Allows intermediaries without client awareness",
      "C": "Reduces payload size",
      "D": "Prevents caching"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients do not need to know whether they are communicating with the origin server or an intermediary.",
      "incorrect": {
        "A": "Authentication is still required.",
        "C": "Payload size is unaffected.",
        "D": "Caching is compatible with layering."
      }
    }
  },
  {
    "id": "CH02-0282",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "DELETE semantics",
    "difficulty": "Medium",
    "question": "Which statement best describes the DELETE method?",
    "options": {
      "A": "It must always return a response body",
      "B": "It removes the resource representation",
      "C": "It is unsafe and non-idempotent",
      "D": "It cannot be retried"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "DELETE removes the resource identified by the URI.",
      "incorrect": {
        "A": "DELETE may return no content.",
        "C": "DELETE is idempotent.",
        "D": "Idempotent methods can be retried."
      }
    }
  },
  {
    "id": "CH02-0283",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "409 Conflict",
    "difficulty": "Hard",
    "question": "When should an API return HTTP 409 Conflict?",
    "options": {
      "A": "When authentication fails",
      "B": "When a request conflicts with current resource state",
      "C": "When the server crashes",
      "D": "When the request is malformed"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "409 indicates a conflict with the current state, such as version mismatches.",
      "incorrect": {
        "A": "401 is for authentication failures.",
        "C": "500 indicates server errors.",
        "D": "400 indicates malformed requests."
      }
    }
  },
  {
    "id": "CH02-0284",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Hierarchical relationships",
    "difficulty": "Medium",
    "question": "When should nested URIs be used?",
    "options": {
      "A": "Always for all resources",
      "B": "When representing strong ownership relationships",
      "C": "To improve caching",
      "D": "To eliminate query parameters"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Nested URIs express strong parent-child ownership relationships.",
      "incorrect": {
        "A": "Over-nesting increases complexity.",
        "C": "Caching is unrelated.",
        "D": "Query parameters still apply."
      }
    }
  },
  {
    "id": "CH02-0285",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Pagination limits",
    "difficulty": "Medium",
    "question": "Why should APIs enforce maximum page sizes?",
    "options": {
      "A": "To limit functionality",
      "B": "To prevent performance degradation",
      "C": "To eliminate pagination",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Limits protect servers from expensive large requests.",
      "incorrect": {
        "A": "Limits protect reliability.",
        "C": "Pagination remains necessary.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0286",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Media type versioning",
    "difficulty": "Hard",
    "question": "What is a challenge of media type versioning?",
    "options": {
      "A": "It breaks HTTP semantics",
      "B": "It complicates client configuration",
      "C": "It cannot be cached",
      "D": "It eliminates backward compatibility"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clients must manage custom media types carefully.",
      "incorrect": {
        "A": "HTTP semantics still apply.",
        "C": "Caching is supported.",
        "D": "Backward compatibility is a design choice."
      }
    }
  },
  {
    "id": "CH02-0287",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "Shared caches",
    "difficulty": "Medium",
    "question": "What does the Cache-Control: public directive indicate?",
    "options": {
      "A": "Response is client-only",
      "B": "Response may be stored by shared caches",
      "C": "Response must not be cached",
      "D": "Response is encrypted"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Public allows caching by proxies and shared caches.",
      "incorrect": {
        "A": "Private restricts caching.",
        "C": "No-store prevents caching.",
        "D": "Encryption is unrelated."
      }
    }
  },
  {
    "id": "CH02-0288",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Example validation",
    "difficulty": "Medium",
    "question": "Why should RAML examples be valid against schemas?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure documentation accuracy",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Valid examples prevent misleading documentation.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Testing remains necessary.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0289",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Security schemes",
    "difficulty": "Medium",
    "question": "What is defined in RAML securitySchemes?",
    "options": {
      "A": "Runtime authorization logic",
      "B": "Authentication mechanisms used by the API",
      "C": "Deployment topology",
      "D": "Traffic throttling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "securitySchemes document authentication methods like OAuth or Basic Auth.",
      "incorrect": {
        "A": "Logic is implemented at runtime.",
        "C": "Deployment is outside RAML scope.",
        "D": "Throttling is a runtime concern."
      }
    }
  },
  {
    "id": "CH02-0290",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Servers object",
    "difficulty": "Easy",
    "question": "What does the servers object describe in OpenAPI?",
    "options": {
      "A": "Authentication rules",
      "B": "Base URLs for API access",
      "C": "Schema validation",
      "D": "Response formats"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Servers define where the API is hosted.",
      "incorrect": {
        "A": "Authentication is defined elsewhere.",
        "C": "Schemas are defined separately.",
        "D": "Responses are defined per operation."
      }
    }
  },

  {
    "id": "CH02-0291",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Enum usage",
    "difficulty": "Medium",
    "question": "Why should enums be used cautiously in API schemas?",
    "options": {
      "A": "They reduce readability",
      "B": "They can introduce breaking changes when extended",
      "C": "They eliminate validation",
      "D": "They increase payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Adding enum values may break strict consumers.",
      "incorrect": {
        "A": "Enums can improve clarity.",
        "C": "Validation is enhanced, not eliminated.",
        "D": "Payload size impact is minimal."
      }
    }
  },
  {
    "id": "CH02-0292",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "HATEOAS links",
    "difficulty": "Hard",
    "question": "What is the purpose of HATEOAS links?",
    "options": {
      "A": "Reduce payload size",
      "B": "Guide clients through available actions",
      "C": "Eliminate documentation",
      "D": "Avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Links allow clients to discover valid next actions dynamically.",
      "incorrect": {
        "A": "Links increase payload size.",
        "C": "Documentation is still needed.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0293",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Consistent error codes",
    "difficulty": "Medium",
    "question": "Why should APIs use consistent application-level error codes?",
    "options": {
      "A": "To replace HTTP status codes",
      "B": "To enable programmatic error handling",
      "C": "To reduce payload size",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent codes help clients implement logic reliably.",
      "incorrect": {
        "A": "HTTP status codes remain essential.",
        "C": "Payload size is unrelated.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0294",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "Contract stability",
    "difficulty": "Medium",
    "question": "What practice best preserves contract stability?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Additive, backward-compatible changes",
      "C": "Minimal documentation",
      "D": "Hidden behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Additive changes avoid breaking existing consumers.",
      "incorrect": {
        "A": "Breaking changes erode trust.",
        "C": "Documentation remains essential.",
        "D": "Hidden behavior reduces predictability."
      }
    }
  },
  {
    "id": "CH02-0295",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Total counts",
    "difficulty": "Medium",
    "question": "Why should total record counts be optional in paginated responses?",
    "options": {
      "A": "To reduce accuracy",
      "B": "Because counting can be expensive on large datasets",
      "C": "To eliminate pagination",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Counting large datasets may degrade performance.",
      "incorrect": {
        "A": "Accuracy is not reduced.",
        "C": "Pagination is still required.",
        "D": "Documentation remains essential."
      }
    }
  },

  {
    "id": "CH02-0296",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Rate limiting",
    "difficulty": "Medium",
    "question": "What is the primary purpose of rate limiting?",
    "options": {
      "A": "Reduce payload size",
      "B": "Protect APIs from abuse and overload",
      "C": "Eliminate authentication",
      "D": "Avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Rate limiting protects availability and fairness.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Authentication remains essential.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0297",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Correlation IDs",
    "difficulty": "Medium",
    "question": "Why are correlation IDs important in APIs?",
    "options": {
      "A": "They encrypt requests",
      "B": "They help trace requests across systems",
      "C": "They reduce payload size",
      "D": "They eliminate logging"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Correlation IDs enable end-to-end request tracing.",
      "incorrect": {
        "A": "Encryption is unrelated.",
        "C": "Payload size impact is minimal.",
        "D": "Logging is still required."
      }
    }
  },
  {
    "id": "CH02-0298",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "API as product",
    "difficulty": "Medium",
    "question": "Why should APIs be treated as products?",
    "options": {
      "A": "To deliver them once and forget",
      "B": "To focus on consumer experience and lifecycle",
      "C": "To eliminate governance",
      "D": "To hide documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Product mindset emphasizes usability, evolution, and value.",
      "incorrect": {
        "A": "APIs require ongoing care.",
        "C": "Governance remains essential.",
        "D": "Documentation must be accessible."
      }
    }
  },
  {
    "id": "CH02-0299",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Change communication",
    "difficulty": "Medium",
    "question": "Why must API changes be clearly communicated?",
    "options": {
      "A": "To reduce payload size",
      "B": "To allow consumers to plan and adapt",
      "C": "To eliminate versioning",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear communication prevents unexpected disruptions.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning still applies.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0300",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "API trustworthiness",
    "difficulty": "Hard",
    "question": "What most strongly contributes to API trustworthiness?",
    "options": {
      "A": "Hidden behavior",
      "B": "Consistency, reliability, and transparency",
      "C": "Minimal documentation",
      "D": "Frequent breaking changes"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Trust is built through predictable and reliable behavior.",
      "incorrect": {
        "A": "Hidden behavior reduces trust.",
        "C": "Documentation is essential.",
        "D": "Breaking changes erode trust."
      }
    }
  },

  {
    "id": "CH02-0301",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Validation",
    "subtopic": "Consumer reviews",
    "difficulty": "Medium",
    "question": "Why should API designs be reviewed by consumers?",
    "options": {
      "A": "To slow delivery",
      "B": "To ensure usability and clarity",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consumer feedback improves real-world usability.",
      "incorrect": {
        "A": "Feedback improves long-term speed.",
        "C": "Testing remains necessary.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0302",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Design checklists",
    "difficulty": "Easy",
    "question": "What is the role of API design checklists?",
    "options": {
      "A": "Replace governance",
      "B": "Ensure consistent application of best practices",
      "C": "Reduce payload size",
      "D": "Avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Checklists help enforce standards consistently.",
      "incorrect": {
        "A": "Governance remains essential.",
        "C": "Payload size is unrelated.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0303",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "API catalog",
    "difficulty": "Medium",
    "question": "Why is an API catalog important?",
    "options": {
      "A": "To hide APIs",
      "B": "To enable discovery and reuse",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Catalogs help teams discover existing APIs.",
      "incorrect": {
        "A": "Hiding APIs reduces value.",
        "C": "Governance relies on visibility.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0304",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Backward-compatible extensions",
    "difficulty": "Medium",
    "question": "Which change is typically backward compatible?",
    "options": {
      "A": "Removing a required field",
      "B": "Adding an optional field",
      "C": "Changing data types",
      "D": "Renaming fields"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Optional fields do not break existing consumers.",
      "incorrect": {
        "A": "Removing required fields breaks clients.",
        "C": "Type changes break contracts.",
        "D": "Renaming breaks consumers."
      }
    }
  },
  {
    "id": "CH02-0305",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Explicit over implicit",
    "difficulty": "Medium",
    "question": "Why is explicit behavior preferred over implicit behavior?",
    "options": {
      "A": "To increase complexity",
      "B": "To reduce ambiguity for consumers",
      "C": "To eliminate testing",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Explicit behavior reduces misunderstandings.",
      "incorrect": {
        "A": "Complexity should be minimized.",
        "C": "Testing remains essential.",
        "D": "Versioning remains necessary."
      }
    }
  },

  {
    "id": "CH02-0321",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "REST Fundamentals",
    "subtopic": "Uniform interface",
    "difficulty": "Medium",
    "question": "Why is the uniform interface constraint critical in REST?",
    "options": {
      "A": "It enforces database normalization",
      "B": "It decouples clients from server implementation details",
      "C": "It eliminates the need for caching",
      "D": "It removes the need for documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Uniform interfaces reduce coupling, allowing servers to evolve independently.",
      "incorrect": {
        "A": "Database design is unrelated.",
        "C": "Caching is still applicable.",
        "D": "Documentation is still required."
      }
    }
  },
  {
    "id": "CH02-0322",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Methods",
    "subtopic": "HEAD usage",
    "difficulty": "Medium",
    "question": "What is the primary use of the HTTP HEAD method?",
    "options": {
      "A": "Retrieve a full response body",
      "B": "Retrieve response headers without the body",
      "C": "Create a new resource",
      "D": "Modify server state"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HEAD is useful for checking metadata like headers without transferring the body.",
      "incorrect": {
        "A": "GET retrieves the full body.",
        "C": "POST creates resources.",
        "D": "HEAD must not modify state."
      }
    }
  },
  {
    "id": "CH02-0323",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "HTTP Status Codes",
    "subtopic": "422 Unprocessable Entity",
    "difficulty": "Hard",
    "question": "When should an API return HTTP 422 Unprocessable Entity?",
    "options": {
      "A": "When authentication fails",
      "B": "When request syntax is valid but semantic validation fails",
      "C": "When the server is unavailable",
      "D": "When a resource is not found"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "422 indicates semantic errors despite valid request syntax.",
      "incorrect": {
        "A": "401 is for authentication failure.",
        "C": "503 indicates unavailability.",
        "D": "404 indicates missing resources."
      }
    }
  },
  {
    "id": "CH02-0324",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "URI Design",
    "subtopic": "Avoiding verbs",
    "difficulty": "Easy",
    "question": "Why should verbs be avoided in RESTful URIs?",
    "options": {
      "A": "They reduce performance",
      "B": "Actions should be represented by HTTP methods, not URIs",
      "C": "They break caching",
      "D": "They increase payload size"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "HTTP methods already define actions; URIs should represent resources.",
      "incorrect": {
        "A": "Performance is unaffected.",
        "C": "Caching is unrelated.",
        "D": "Payload size is unaffected."
      }
    }
  },
  {
    "id": "CH02-0325",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Query Parameters",
    "subtopic": "Filtering vs searching",
    "difficulty": "Medium",
    "question": "What differentiates filtering from searching in APIs?",
    "options": {
      "A": "Filtering is always slower",
      "B": "Filtering narrows a known collection, searching explores broader criteria",
      "C": "Searching eliminates pagination",
      "D": "Filtering replaces URI paths"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Filtering refines known resources, while searching supports broader discovery.",
      "incorrect": {
        "A": "Performance depends on implementation.",
        "C": "Pagination still applies.",
        "D": "Paths still define resources."
      }
    }
  },

  {
    "id": "CH02-0326",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Versioning",
    "subtopic": "Header-based versioning",
    "difficulty": "Hard",
    "question": "What is a benefit of header-based API versioning?",
    "options": {
      "A": "Simpler client configuration",
      "B": "Cleaner URIs without version identifiers",
      "C": "Automatic backward compatibility",
      "D": "Elimination of documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Header-based versioning avoids cluttering URIs with version numbers.",
      "incorrect": {
        "A": "Clients must manage headers.",
        "C": "Compatibility is not automatic.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0327",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Caching",
    "subtopic": "Conditional requests",
    "difficulty": "Medium",
    "question": "Why are conditional requests beneficial?",
    "options": {
      "A": "They eliminate authentication",
      "B": "They reduce bandwidth by returning data only when changed",
      "C": "They disable caching",
      "D": "They remove the need for headers"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Conditional requests prevent unnecessary data transfer.",
      "incorrect": {
        "A": "Authentication still applies.",
        "C": "They enhance caching.",
        "D": "Headers are essential."
      }
    }
  },
  {
    "id": "CH02-0328",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "RAML",
    "subtopic": "Base URI parameters",
    "difficulty": "Medium",
    "question": "Why are baseUriParameters useful in RAML?",
    "options": {
      "A": "They execute runtime logic",
      "B": "They allow parameterization of environment-specific values",
      "C": "They define security policies",
      "D": "They manage deployment"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Base URI parameters support flexible environment configuration.",
      "incorrect": {
        "A": "RAML does not execute logic.",
        "C": "Security is defined separately.",
        "D": "Deployment is outside RAML scope."
      }
    }
  },
  {
    "id": "CH02-0329",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "OAS",
    "subtopic": "Security requirements",
    "difficulty": "Medium",
    "question": "What do security requirements define in OpenAPI?",
    "options": {
      "A": "Runtime authorization code",
      "B": "Which security schemes apply to operations",
      "C": "Deployment environments",
      "D": "Response schemas"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Security requirements specify which schemes protect operations.",
      "incorrect": {
        "A": "Logic is implemented separately.",
        "C": "Deployment is unrelated.",
        "D": "Schemas are defined elsewhere."
      }
    }
  },
  {
    "id": "CH02-0330",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Data Modeling",
    "subtopic": "Backward-compatible schemas",
    "difficulty": "Medium",
    "question": "Which schema change is safest for backward compatibility?",
    "options": {
      "A": "Removing fields",
      "B": "Adding optional fields",
      "C": "Renaming properties",
      "D": "Changing data types"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Optional fields do not break existing consumers.",
      "incorrect": {
        "A": "Removing fields breaks clients.",
        "C": "Renaming breaks contracts.",
        "D": "Type changes break compatibility."
      }
    }
  },

  {
    "id": "CH02-0331",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Response Design",
    "subtopic": "Minimal responses",
    "difficulty": "Medium",
    "question": "Why should APIs avoid returning excessive data?",
    "options": {
      "A": "To reduce functionality",
      "B": "To improve performance and security",
      "C": "To eliminate pagination",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Returning only necessary data improves efficiency and reduces exposure.",
      "incorrect": {
        "A": "Functionality remains intact.",
        "C": "Pagination still applies.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0332",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Error Handling",
    "subtopic": "Human-readable messages",
    "difficulty": "Easy",
    "question": "Why should error responses include human-readable messages?",
    "options": {
      "A": "To replace machine-readable codes",
      "B": "To help developers understand and fix issues",
      "C": "To expose stack traces",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Clear messages reduce debugging time.",
      "incorrect": {
        "A": "Codes are still required.",
        "C": "Stack traces should not be exposed.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0333",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Strategy",
    "subtopic": "API consistency",
    "difficulty": "Medium",
    "question": "Why is consistency across APIs important?",
    "options": {
      "A": "To reduce payload size",
      "B": "To reduce learning curve for consumers",
      "C": "To eliminate governance",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Consistent APIs are easier to learn and adopt.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance supports consistency.",
        "D": "Versioning is still required."
      }
    }
  },
  {
    "id": "CH02-0334",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Pagination",
    "subtopic": "Client control",
    "difficulty": "Medium",
    "question": "Why should clients control pagination parameters?",
    "options": {
      "A": "To overload the server",
      "B": "To balance flexibility and performance",
      "C": "To eliminate pagination",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Client control allows flexible yet efficient data access.",
      "incorrect": {
        "A": "Servers enforce limits.",
        "C": "Pagination remains required.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0335",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Sensitive data exposure",
    "difficulty": "Hard",
    "question": "What is the primary risk of exposing sensitive data in APIs?",
    "options": {
      "A": "Increased payload size",
      "B": "Security breaches and compliance violations",
      "C": "Reduced usability",
      "D": "Slower performance only"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sensitive data exposure can lead to severe security and legal issues.",
      "incorrect": {
        "A": "Payload size is secondary.",
        "C": "Usability is not the main risk.",
        "D": "Performance is not the primary concern."
      }
    }
  },

  {
    "id": "CH02-0336",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Service-level objectives",
    "difficulty": "Medium",
    "question": "Why should APIs define service-level objectives (SLOs)?",
    "options": {
      "A": "To eliminate monitoring",
      "B": "To set clear reliability expectations",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "SLOs align teams around measurable reliability goals.",
      "incorrect": {
        "A": "Monitoring is still required.",
        "C": "Payload size is unrelated.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0337",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Consumer trust",
    "difficulty": "Medium",
    "question": "What most directly builds consumer trust in APIs?",
    "options": {
      "A": "Frequent new features",
      "B": "Predictable behavior and stability",
      "C": "Minimal documentation",
      "D": "Hidden error handling"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Stability and predictability encourage long-term adoption.",
      "incorrect": {
        "A": "Features without stability reduce trust.",
        "C": "Documentation is essential.",
        "D": "Hidden behavior reduces trust."
      }
    }
  },
  {
    "id": "CH02-0338",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Governance automation",
    "difficulty": "Hard",
    "question": "Why is governance automation essential at scale?",
    "options": {
      "A": "To eliminate standards",
      "B": "To consistently enforce rules across many APIs",
      "C": "To reduce documentation",
      "D": "To hide policies"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Automation ensures governance without slowing delivery.",
      "incorrect": {
        "A": "Standards remain critical.",
        "C": "Documentation remains essential.",
        "D": "Hidden policies reduce effectiveness."
      }
    }
  },
  {
    "id": "CH02-0339",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Enterprise alignment",
    "difficulty": "Medium",
    "question": "Why must API design align with enterprise standards?",
    "options": {
      "A": "To reduce payload size",
      "B": "To enable consistency, reuse, and governance",
      "C": "To eliminate innovation",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alignment supports scale, reuse, and maintainability.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Standards do not prevent innovation.",
        "D": "Documentation remains necessary."
      }
    }
  },
  {
    "id": "CH02-0340",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Maturity",
    "subtopic": "Continuous improvement",
    "difficulty": "Medium",
    "question": "What indicates a mature API design practice?",
    "options": {
      "A": "One-time delivery",
      "B": "Continuous improvement based on feedback and metrics",
      "C": "Minimal governance",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Maturity involves learning and improving over time.",
      "incorrect": {
        "A": "APIs require ongoing care.",
        "C": "Governance is essential.",
        "D": "Documentation must be visible."
      }
    }
  },

  {
    "id": "CH02-0341",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Lifecycle",
    "subtopic": "End-of-life planning",
    "difficulty": "Hard",
    "question": "Why should APIs plan for end-of-life from the beginning?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure predictable retirement for consumers",
      "C": "To eliminate versioning",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Planned retirement avoids abrupt disruptions.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Versioning supports lifecycle.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0342",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Governance",
    "subtopic": "Exception handling",
    "difficulty": "Medium",
    "question": "Why should governance allow controlled exceptions?",
    "options": {
      "A": "To eliminate standards",
      "B": "To address valid edge cases without blocking progress",
      "C": "To reduce documentation",
      "D": "To hide decisions"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Controlled exceptions balance flexibility and consistency.",
      "incorrect": {
        "A": "Standards remain essential.",
        "C": "Documentation remains required.",
        "D": "Transparency is important."
      }
    }
  },
  {
    "id": "CH02-0343",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Cross-team collaboration",
    "difficulty": "Medium",
    "question": "Why is cross-team collaboration important in API programs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure APIs meet diverse consumer needs",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Collaboration ensures APIs serve multiple stakeholders effectively.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance remains essential.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0344",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Quality",
    "subtopic": "Simplicity",
    "difficulty": "Easy",
    "question": "Why is simplicity a key API quality attribute?",
    "options": {
      "A": "It reduces features",
      "B": "It improves usability and adoption",
      "C": "It eliminates documentation",
      "D": "It avoids versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Simple APIs are easier to understand and use.",
      "incorrect": {
        "A": "Simplicity does not mean fewer features.",
        "C": "Documentation is still required.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0345",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Principles",
    "subtopic": "Least astonishment",
    "difficulty": "Medium",
    "question": "What does the principle of least astonishment aim to achieve?",
    "options": {
      "A": "Unexpected behavior",
      "B": "Behavior that matches user expectations",
      "C": "Minimal documentation",
      "D": "Hidden logic"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Expected behavior improves usability and trust.",
      "incorrect": {
        "A": "Unexpected behavior harms adoption.",
        "C": "Documentation remains essential.",
        "D": "Hidden logic reduces trust."
      }
    }
  },

  {
    "id": "CH02-0346",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Security",
    "subtopic": "Defense in depth",
    "difficulty": "Hard",
    "question": "What does defense in depth mean for API security?",
    "options": {
      "A": "Single security layer",
      "B": "Multiple complementary security controls",
      "C": "No authentication",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Multiple layers reduce the impact of individual control failures.",
      "incorrect": {
        "A": "Single layers are insufficient.",
        "C": "Authentication is essential.",
        "D": "Documentation remains required."
      }
    }
  },
  {
    "id": "CH02-0347",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Observability",
    "subtopic": "Error budgets",
    "difficulty": "Hard",
    "question": "What is the purpose of an error budget?",
    "options": {
      "A": "To eliminate errors",
      "B": "To balance reliability and innovation",
      "C": "To reduce payload size",
      "D": "To avoid versioning"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Error budgets allow controlled risk-taking while maintaining reliability.",
      "incorrect": {
        "A": "Zero errors are unrealistic.",
        "C": "Payload size is unrelated.",
        "D": "Versioning remains necessary."
      }
    }
  },
  {
    "id": "CH02-0348",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Strategy",
    "subtopic": "Long-term value",
    "difficulty": "Medium",
    "question": "What best ensures long-term API value?",
    "options": {
      "A": "Frequent breaking changes",
      "B": "Reuse, governance, and consumer focus",
      "C": "Minimal security",
      "D": "Hidden documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Long-term value depends on reuse and trust.",
      "incorrect": {
        "A": "Breaking changes reduce value.",
        "C": "Security must be strong.",
        "D": "Documentation must be visible."
      }
    }
  },
  {
    "id": "CH02-0349",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "API Programs",
    "subtopic": "Organizational alignment",
    "difficulty": "Medium",
    "question": "Why is organizational alignment critical for API programs?",
    "options": {
      "A": "To reduce payload size",
      "B": "To ensure APIs support business goals consistently",
      "C": "To eliminate governance",
      "D": "To avoid documentation"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Alignment ensures APIs deliver real business value.",
      "incorrect": {
        "A": "Payload size is unrelated.",
        "C": "Governance remains essential.",
        "D": "Documentation remains essential."
      }
    }
  },
  {
    "id": "CH02-0350",
    "chapter": 2,
    "chapterTitle": "Designing APIs",
    "topic": "Design Excellence",
    "subtopic": "Sustainable API ecosystems",
    "difficulty": "Hard",
    "question": "What is essential for building a sustainable API ecosystem?",
    "options": {
      "A": "Ad-hoc design",
      "B": "Clear contracts, governance, and continuous improvement",
      "C": "Minimal documentation",
      "D": "Hidden behavior"
    },
    "correctAnswer": "B",
    "explanation": {
      "correct": "Sustainability depends on discipline, reuse, and evolution.",
      "incorrect": {
        "A": "Ad-hoc design does not scale.",
        "C": "Documentation remains essential.",
        "D": "Hidden behavior reduces trust."
      }
    }
  }
]